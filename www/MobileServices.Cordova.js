// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved
// AzureMobileServices - v2.0.0-beta
// ----------------------------------------------------------------------------

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require("./lib/main")
},{"./lib/main":4}],2:[function(require,module,exports){
(function (Buffer){
// Generated by CoffeeScript 1.9.3
(function() {
  var TYPES, fn, key, value, zero;

  TYPES = {
    VarChar: function(length) {
      return {
        type: TYPES.VarChar,
        length: length
      };
    },
    NVarChar: function(length) {
      return {
        type: TYPES.NVarChar,
        length: length
      };
    },
    Text: function() {
      return {
        type: TYPES.Text
      };
    },
    Int: function() {
      return {
        type: TYPES.Int
      };
    },
    BigInt: function() {
      return {
        type: TYPES.BigInt
      };
    },
    TinyInt: function() {
      return {
        type: TYPES.TinyInt
      };
    },
    SmallInt: function() {
      return {
        type: TYPES.SmallInt
      };
    },
    Bit: function() {
      return {
        type: TYPES.Bit
      };
    },
    Float: function() {
      return {
        type: TYPES.Float
      };
    },
    Numeric: function(precision, scale) {
      return {
        type: TYPES.Numeric,
        precision: precision,
        scale: scale
      };
    },
    Decimal: function(precision, scale) {
      return {
        type: TYPES.Decimal,
        precision: precision,
        scale: scale
      };
    },
    Real: function() {
      return {
        type: TYPES.Real
      };
    },
    Date: function() {
      return {
        type: TYPES.Date
      };
    },
    DateTime: function() {
      return {
        type: TYPES.DateTime
      };
    },
    DateTime2: function(scale) {
      return {
        type: TYPES.DateTime2,
        scale: scale
      };
    },
    DateTimeOffset: function(scale) {
      return {
        type: TYPES.DateTimeOffset,
        scale: scale
      };
    },
    SmallDateTime: function() {
      return {
        type: TYPES.SmallDateTime
      };
    },
    Time: function(scale) {
      return {
        type: TYPES.Time,
        scale: scale
      };
    },
    UniqueIdentifier: function() {
      return {
        type: TYPES.UniqueIdentifier
      };
    },
    SmallMoney: function() {
      return {
        type: TYPES.SmallMoney
      };
    },
    Money: function() {
      return {
        type: TYPES.Money
      };
    },
    Binary: function(length) {
      return {
        type: TYPES.Binary,
        length: length
      };
    },
    VarBinary: function(length) {
      return {
        type: TYPES.VarBinary,
        length: length
      };
    },
    Image: function() {
      return {
        type: TYPES.Image
      };
    },
    Xml: function() {
      return {
        type: TYPES.Xml
      };
    },
    Char: function(length) {
      return {
        type: TYPES.Char,
        length: length
      };
    },
    NChar: function(length) {
      return {
        type: TYPES.NChar,
        length: length
      };
    },
    NText: function() {
      return {
        type: TYPES.NText
      };
    },
    TVP: function(tvpType) {
      return {
        type: TYPES.TVP,
        tvpType: tvpType
      };
    },
    UDT: function() {
      return {
        type: TYPES.UDT
      };
    },
    Geography: function() {
      return {
        type: TYPES.Geography
      };
    },
    Geometry: function() {
      return {
        type: TYPES.Geometry
      };
    }
  };

  module.exports.TYPES = TYPES;

  module.exports.DECLARATIONS = {};

  fn = function(key, value) {
    return value.inspect = function() {
      return "[sql." + key + "]";
    };
  };
  for (key in TYPES) {
    value = TYPES[key];
    value.declaration = key.toLowerCase();
    module.exports.DECLARATIONS[value.declaration] = value;
    fn(key, value);
  }

  module.exports.declare = function(type, options) {
    var ref, ref1, ref2, ref3, ref4, ref5;
    switch (type) {
      case TYPES.VarChar:
      case TYPES.NVarChar:
      case TYPES.VarBinary:
        return type.declaration + " (" + (options.length > 8000 ? 'MAX' : (ref = options.length) != null ? ref : 'MAX') + ")";
      case TYPES.NVarChar:
        return type.declaration + " (" + (options.length > 4000 ? 'MAX' : (ref1 = options.length) != null ? ref1 : 'MAX') + ")";
      case TYPES.Char:
      case TYPES.NChar:
      case TYPES.Binary:
        return type.declaration + " (" + ((ref2 = options.length) != null ? ref2 : 1) + ")";
      case TYPES.Decimal:
      case TYPES.Numeric:
        return type.declaration + " (" + ((ref3 = options.precision) != null ? ref3 : 18) + ", " + ((ref4 = options.scale) != null ? ref4 : 0) + ")";
      case TYPES.Time:
      case TYPES.DateTime2:
      case TYPES.DateTimeOffset:
        return type.declaration + " (" + ((ref5 = options.scale) != null ? ref5 : 7) + ")";
      case TYPES.TVP:
        return options.tvpType + " readonly";
      default:
        return type.declaration;
    }
  };

  module.exports.cast = function(value, type, options) {
    var ns, ref, scale;
    if (value == null) {
      return null;
    }
    switch (typeof value) {
      case 'string':
        return "N'" + (value.replace(/'/g, '\'\'')) + "'";
      case 'number':
        return value;
      case 'boolean':
        if (value) {
          return 1;
        } else {
          return 0;
        }
      case 'object':
        if (value instanceof Date) {
          ns = value.getUTCMilliseconds() / 1000;
          if (value.nanosecondDelta != null) {
            ns += value.nanosecondDelta;
          }
          scale = (ref = options.scale) != null ? ref : 7;
          if (scale > 0) {
            ns = String(ns).substr(1, scale + 1);
          } else {
            ns = "";
          }
          return "N'" + (value.getUTCFullYear()) + "-" + (zero(value.getUTCMonth() + 1)) + "-" + (zero(value.getUTCDate())) + " " + (zero(value.getUTCHours())) + ":" + (zero(value.getUTCMinutes())) + ":" + (zero(value.getUTCSeconds())) + ns + "'";
        } else if (Buffer.isBuffer(value)) {
          return "0x" + (value.toString('hex'));
        } else {
          return null;
        }
        break;
      default:
        return null;
    }
  };

  zero = function(value, length) {
    var i, j, ref;
    if (length == null) {
      length = 2;
    }
    value = String(value);
    if (value.length < length) {
      for (i = j = 1, ref = length - value.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        value = "0" + value;
      }
    }
    return value;
  };

}).call(this);

}).call(this,{"isBuffer":require("d:\\repos\\shrishrirang\\azure-mobile-services\\sdk\\Javascript\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js")})
},{"d:\\repos\\shrishrirang\\azure-mobile-services\\sdk\\Javascript\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js":115}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
(function() {
  module.exports = {
    READ_UNCOMMITTED: 0x01,
    READ_COMMITTED: 0x02,
    REPEATABLE_READ: 0x03,
    SERIALIZABLE: 0x04,
    SNAPSHOT: 0x05
  };

}).call(this);

},{}],4:[function(require,module,exports){
(function (process,global,Buffer){
// Generated by CoffeeScript 1.9.3
(function() {
  var Connection, ConnectionError, DRIVERS, EventEmitter, ISOLATION_LEVEL, PreparedStatement, PreparedStatementError, Request, RequestError, TYPES, Table, Transaction, TransactionError, declare, fs, getTypeByValue, global_connection, key, map, ref, ref1, util, value,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  EventEmitter = require('events').EventEmitter;

  util = require('util');

  fs = require('fs');

  ref = require('./datatypes'), TYPES = ref.TYPES, declare = ref.declare;

  ISOLATION_LEVEL = require('./isolationlevel');

  DRIVERS = ['msnodesql', 'tedious', 'tds'];

  Table = require('./table');

  global_connection = null;

  map = [];


  /*
  Register you own type map.
  
  **Example:**
  ```
  sql.map.register(MyClass, sql.Text);
  ```
  You can also overwrite default type map.
  ```
  sql.map.register(Number, sql.BigInt);
  ```
  
  @path module.exports.map
  @param {*} jstype JS data type.
  @param {*} sqltype SQL data type.
   */

  map.register = function(jstype, sqltype) {
    var i, index, item, len;
    for (index = i = 0, len = this.length; i < len; index = ++i) {
      item = this[index];
      if (!(item.js === jstype)) {
        continue;
      }
      this.splice(index, 1);
      break;
    }
    this.push({
      js: jstype,
      sql: sqltype
    });
    return null;
  };

  map.register(String, TYPES.NVarChar);

  map.register(Number, TYPES.Int);

  map.register(Boolean, TYPES.Bit);

  map.register(Date, TYPES.DateTime);

  map.register(Buffer, TYPES.VarBinary);

  map.register(Table, TYPES.TVP);


  /*
  @ignore
   */

  getTypeByValue = function(value) {
    var i, item, j, k, l, len, len1, len2, len3;
    if (value === null || value === void 0) {
      return TYPES.NVarChar;
    }
    switch (typeof value) {
      case 'string':
        for (i = 0, len = map.length; i < len; i++) {
          item = map[i];
          if (item.js === String) {
            return item.sql;
          }
        }
        return TYPES.NVarChar;
      case 'number':
        for (j = 0, len1 = map.length; j < len1; j++) {
          item = map[j];
          if (item.js === Number) {
            return item.sql;
          }
        }
        return TYPES.Int;
      case 'boolean':
        for (k = 0, len2 = map.length; k < len2; k++) {
          item = map[k];
          if (item.js === Boolean) {
            return item.sql;
          }
        }
        return TYPES.Bit;
      case 'object':
        for (l = 0, len3 = map.length; l < len3; l++) {
          item = map[l];
          if (value instanceof item.js) {
            return item.sql;
          }
        }
        return TYPES.NVarChar;
      default:
        return TYPES.NVarChar;
    }
  };


  /*
  Class Connection.
  
  Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.
  
  @property {Boolean} connected If true, connection is established.
  @property {Boolean} connecting If true, connection is being established.
  @property {*} driver Reference to configured Driver.
  
  @event connect Dispatched after connection has established.
  @event close Dispatched after connection has closed a pool (by calling close).
   */

  Connection = (function(superClass) {
    extend(Connection, superClass);

    Connection.prototype.connected = false;

    Connection.prototype.connecting = false;

    Connection.prototype.driver = null;


    /*
    	Create new Connection.
    	
    	@param {Object} config Connection configuration.
    	@callback [callback] A callback which is called after connection has established, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
     */

    function Connection(config1, callback) {
      var base, base1, base2, base3, base4, err, ref1;
      this.config = config1;
      if ((base = this.config).driver == null) {
        base.driver = 'tedious';
      }
      if ((base1 = this.config).port == null) {
        base1.port = 1433;
      }
      if ((base2 = this.config).options == null) {
        base2.options = {};
      }
      if ((base3 = this.config).stream == null) {
        base3.stream = false;
      }
      if ((base4 = this.config).parseJSON == null) {
        base4.parseJSON = false;
      }
      if (/^(.*)\\(.*)$/.exec(this.config.server)) {
        this.config.server = RegExp.$1;
        this.config.options.instanceName = RegExp.$2;
      }
      if (ref1 = this.config.driver, indexOf.call(DRIVERS, ref1) >= 0) {
        this.driver = this.initializeDriver(require("./" + this.config.driver));
        if (module.exports.fix) {
          this.driver.fix();
        }
      } else {
        err = new ConnectionError("Unknown driver " + this.config.driver + "!", 'EDRIVER');
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        this.connect(callback);
      }
    }


    /*
    	Write message to debug stream.
     */

    Connection.prototype._debug = function(msg) {
      var ref1;
      return (ref1 = this._debugStream) != null ? ref1.write((String(msg).replace(/\x1B\[[0-9;]*m/g, '')) + "\n") : void 0;
    };


    /*
    	Initializes driver for this connection. Separated from constructor and used by co-mssql.
    	
    	@private
    	@param {Function} driver Loaded driver.
    	
    	@returns {Connection}
     */

    Connection.prototype.initializeDriver = function(driver) {
      return driver(Connection, Transaction, Request, ConnectionError, TransactionError, RequestError);
    };


    /*
    	Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
    	
    	@callback [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	
    	@returns {Connection|Promise}
     */

    Connection.prototype.connect = function(callback) {
      if (callback != null) {
        return this._connect(callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._connect(function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    Connection.prototype._connect = function(callback) {
      var go;
      if (!this.driver) {
        return callback(new ConnectionError("Connection was closed. Create a new instance."));
      }
      if (this.connected) {
        return callback(new ConnectionError("Database is already connected! Call close before connecting to different database.", 'EALREADYCONNECTED'));
      }
      if (this.connecting) {
        return callback(new ConnectionError("Already connecting to database! Call close before connecting to different database.", 'EALREADYCONNECTING'));
      }
      go = (function(_this) {
        return function() {
          _this.connecting = true;
          return _this.driver.Connection.prototype.connect.call(_this, _this.config, function(err) {
            if (!_this.connecting) {
              return;
            }
            _this.connecting = false;
            if (err) {
              if (_this._debugStream) {
                _this._debugStream.removeAllListeners();
                _this._debugStream.end();
                _this._debugStream = null;
              }
            } else {
              _this.connected = true;
              _this.emit('connect');
            }
            return callback(err);
          });
        };
      })(this);
      if (this.config.debug) {
        this._debugStream = fs.createWriteStream("./mssql_debug_" + (Date.now()) + ".log");
        this._debugStream.once('open', go);
        this._debugStream.on('error', function(err) {
          if (this.connecting || this.connected) {
            return console.error(err.stack);
          } else {
            this._debugStream.removeListener('open', go);
            return callback(new ConnectionError("Failed to open debug stream. " + err.message, 'EDEBUG'));
          }
        });
      } else {
        go();
      }
      return this;
    };


    /*
    	Close all active connections in the pool.
    	
    	@callback [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	
    	@returns {Connection|Promise}
     */

    Connection.prototype.close = function(callback) {
      if (callback != null) {
        return this._close(callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._close(function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    Connection.prototype._close = function(callback) {
      if (this._debugStream) {
        this._debugStream.removeAllListeners();
        this._debugStream.end();
        this._debugStream = null;
      }
      if (this.connecting) {
        this.connecting = false;
        this.driver.Connection.prototype.close.call(this, (function(_this) {
          return function(err) {
            return callback(err);
          };
        })(this));
        this.driver = null;
      } else if (this.connected) {
        this.connected = false;
        this.driver.Connection.prototype.close.call(this, (function(_this) {
          return function(err) {
            if (!err) {
              _this.connected = false;
              _this.emit('close');
            }
            return callback(err);
          };
        })(this));
        this.driver = null;
      }
      return this;
    };


    /*
    	Returns new request using this connection.
    	
    	@returns {Request}
     */

    Connection.prototype.request = function() {
      return new Request(this);
    };


    /*
    	Returns new transaction using this connection.
    	
    	@returns {Transaction}
     */

    Connection.prototype.transaction = function() {
      return new Transaction(this);
    };

    return Connection;

  })(EventEmitter);


  /*
  Class PreparedStatement.
  
  IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!
  
  @property {Connection} connection Reference to used connection.
  @property {Boolean} multiple If `true`, `execute` will handle multiple recordsets.
  @property {String} statement Prepared SQL statement.
   */

  PreparedStatement = (function(superClass) {
    extend(PreparedStatement, superClass);

    PreparedStatement.prototype._pooledConnection = null;

    PreparedStatement.prototype._queue = null;

    PreparedStatement.prototype._working = false;

    PreparedStatement.prototype._handle = 0;

    PreparedStatement.prototype.connection = null;

    PreparedStatement.prototype.transaction = null;

    PreparedStatement.prototype.prepared = false;

    PreparedStatement.prototype.statement = null;

    PreparedStatement.prototype.parameters = null;

    PreparedStatement.prototype.multiple = false;

    PreparedStatement.prototype.stream = null;


    /*
    	Create new Prepared Statement.
    	
    	@param {String} statement SQL statement.
    	@param {Connection} [connection] If ommited, global connection is used instead.
     */

    function PreparedStatement(connection) {
      if (connection instanceof Transaction) {
        this.transaction = connection;
        this.connection = connection.connection;
      } else if (connection instanceof Connection) {
        this.connection = connection;
      } else {
        this.connection = global_connection;
      }
      this._queue = [];
      this.parameters = {};
    }


    /*
    	Add an input parameter to the prepared statement.
    	
    	**Example:**
    	```
    	statement.input('input_parameter', sql.Int);
    	statement.input('input_parameter', sql.VarChar(50));
    	```
    	
    	@param {String} name Name of the input parameter without @ char.
    	@param {*} type SQL data type of input parameter.
    	@returns {PreparedStatement}
     */

    PreparedStatement.prototype.input = function(name, type) {
      if (/(--| |\/\*|\*\/|')/.test(name)) {
        throw new PreparedStatementError("SQL injection warning for param '" + name + "'", 'EINJECT');
      }
      if (arguments.length < 2) {
        throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", 'EARGS');
      }
      if (type instanceof Function) {
        type = type();
      }
      this.parameters[name] = {
        name: name,
        type: type.type,
        io: 1,
        length: type.length,
        scale: type.scale,
        precision: type.precision,
        tvpType: type.tvpType
      };
      return this;
    };


    /*
    	Add an output parameter to the prepared statement.
    	
    	**Example:**
    	```
    	statement.output('output_parameter', sql.Int);
    	statement.output('output_parameter', sql.VarChar(50));
    	```
    	
    	@param {String} name Name of the output parameter without @ char.
    	@param {*} type SQL data type of output parameter.
    	@returns {PreparedStatement}
     */

    PreparedStatement.prototype.output = function(name, type) {
      if (/(--| |\/\*|\*\/|')/.test(name)) {
        throw new PreparedStatementError("SQL injection warning for param '" + name + "'", 'EINJECT');
      }
      if (arguments.length < 2) {
        throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", 'EARGS');
      }
      if (type instanceof Function) {
        type = type();
      }
      this.parameters[name] = {
        name: name,
        type: type.type,
        io: 2,
        length: type.length,
        scale: type.scale,
        precision: type.precision
      };
      return this;
    };


    /*
    	Prepare a statement.
    	
    	@property {String} [statement] SQL statement to prepare.
    	@callback [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {PreparedStatement|Promise}
     */

    PreparedStatement.prototype.prepare = function(statement, callback) {
      if (callback != null) {
        return this._prepare(statement, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._prepare(statement, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    PreparedStatement.prototype._prepare = function(statement, callback) {
      var done;
      if (this._pooledConnection) {
        callback(new PreparedStatementError("Statement is already prepared.", 'EALREADYPREPARED'));
        return this;
      }
      if (typeof statement === 'function') {
        callback = statement;
        statement = void 0;
      }
      if (statement != null) {
        this.statement = statement;
      }
      done = (function(_this) {
        return function(err, connection) {
          var name, param, req;
          if (err) {
            return callback(err);
          }
          _this._pooledConnection = connection;
          req = new Request(_this);
          req.stream = false;
          req.output('handle', TYPES.Int);
          req.input('params', TYPES.NVarChar, ((function() {
            var ref1, results;
            ref1 = this.parameters;
            results = [];
            for (name in ref1) {
              param = ref1[name];
              results.push("@" + name + " " + (declare(param.type, param)) + (param.io === 2 ? " output" : ""));
            }
            return results;
          }).call(_this)).join(','));
          req.input('stmt', TYPES.NVarChar, _this.statement);
          return req.execute('sp_prepare', function(err) {
            if (err) {
              if (_this.transaction) {
                _this.transaction.next();
              } else {
                _this.connection.pool.release(_this._pooledConnection);
                _this._pooledConnection = null;
              }
              return callback(err);
            }
            _this._handle = req.parameters.handle.value;
            return callback(null);
          });
        };
      })(this);
      if (this.transaction) {
        if (!this.transaction._pooledConnection) {
          callback(new TransactionError("Transaction has not begun. Call begin() first.", 'ENOTBEGUN'));
          return this;
        }
        this.transaction.queue(done);
      } else {
        this.connection.pool.acquire(done);
      }
      return this;
    };


    /*
    	Execute next request in queue.
    	
    	@private
    	@returns {PreparedStatement}
     */

    PreparedStatement.prototype.next = function() {
      if (this._queue.length) {
        process.nextTick((function(_this) {
          return function() {
            return _this._queue.shift()(null, _this._pooledConnection);
          };
        })(this));
      } else {
        this._working = false;
      }
      return this;
    };


    /*
    	Add request to queue for connection. If queue is empty, execute the request immediately.
    	
    	@private
    	@callback callback A callback to call when connection in ready to execute request.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} conn Internal driver's connection.
    	@returns {PreparedStatement}
     */

    PreparedStatement.prototype.queue = function(callback) {
      if (!this._pooledConnection) {
        callback(new PreparedStatementError("Statement is not prepared. Call prepare() first.", 'ENOTPREPARED'));
        return this;
      }
      if (this._working) {
        this._queue.push(callback);
      } else {
        this._working = true;
        callback(null, this._pooledConnection);
      }
      return this;
    };


    /*
    	Execute a prepared statement.
    	
    	@property {String} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
    	@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Request|Promise}
     */

    PreparedStatement.prototype.execute = function(values, callback) {
      if (callback != null) {
        return this._execute(values, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._execute(values, function(err, recordset) {
            if (err) {
              return reject(err);
            }
            return resolve(recordset);
          });
        };
      })(this));
    };

    PreparedStatement.prototype._execute = function(values, callback) {
      var name, param, ref1, req;
      req = new Request(this);
      if (this.stream != null) {
        req.stream = this.stream;
      }
      req.input('handle', TYPES.Int, this._handle);
      ref1 = this.parameters;
      for (name in ref1) {
        param = ref1[name];
        req.parameters[name] = {
          name: name,
          type: param.type,
          io: param.io,
          value: values[name],
          length: param.length,
          scale: param.scale,
          precision: param.precision
        };
      }
      req.execute('sp_execute', (function(_this) {
        return function(err, recordsets, returnValue) {
          if (err) {
            return callback(err);
          }
          return callback(null, (_this.multiple ? recordsets : recordsets[0]));
        };
      })(this));
      return req;
    };


    /*
    	Unprepare a prepared statement.
    	
    	@callback [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {PreparedStatement|Promise}
     */

    PreparedStatement.prototype.unprepare = function(callback) {
      if (callback != null) {
        return this._unprepare(callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._unprepare(function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    PreparedStatement.prototype._unprepare = function(callback) {
      var done, req;
      if (!this._pooledConnection) {
        callback(new PreparedStatementError("Statement is not prepared. Call prepare() first.", 'ENOTPREPARED'));
        return this;
      }
      done = (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          if (_this.transaction) {
            _this.transaction.next();
          } else {
            _this.connection.pool.release(_this._pooledConnection);
            _this._pooledConnection = null;
          }
          _this._handle = 0;
          return callback(null);
        };
      })(this);
      req = new Request(this);
      req.stream = false;
      req.input('handle', TYPES.Int, this._handle);
      req.execute('sp_unprepare', done);
      return this;
    };

    return PreparedStatement;

  })(EventEmitter);


  /*
  Class Transaction.
  
  @property {Connection} connection Reference to used connection.
  @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.
  @property {String} name Transaction name. Empty string by default.
  
  @event begin Dispatched when transaction begin.
  @event commit Dispatched on successful commit.
  @event rollback Dispatched on successful rollback.
   */

  Transaction = (function(superClass) {
    extend(Transaction, superClass);

    Transaction.prototype._pooledConnection = null;

    Transaction.prototype._queue = null;

    Transaction.prototype._aborted = false;

    Transaction.prototype._working = false;

    Transaction.prototype.name = "";

    Transaction.prototype.connection = null;

    Transaction.prototype.isolationLevel = ISOLATION_LEVEL.READ_COMMITTED;


    /*
    	Create new Transaction.
    	
    	@param {Connection} [connection] If ommited, global connection is used instead.
     */

    function Transaction(connection) {
      this._abort = bind(this._abort, this);
      this.connection = connection != null ? connection : global_connection;
      this._queue = [];
    }


    /*
    	@private
     */

    Transaction.prototype._abort = function() {
      return this.connection.driver.Transaction.prototype._abort.call(this);
    };


    /*
    	Begin a transaction.
    	
    	@param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
    	@callback [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction|Promise}
     */

    Transaction.prototype.begin = function(isolationLevel, callback) {
      if (isolationLevel instanceof Function) {
        callback = isolationLevel;
        isolationLevel = void 0;
      }
      if (callback != null) {
        return this._begin(isolationLevel, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._begin(isolationLevel, function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    Transaction.prototype._begin = function(isolationLevel, callback) {
      if (isolationLevel != null) {
        this.isolationLevel = isolationLevel;
      }
      if (this._pooledConnection) {
        callback(new TransactionError("Transaction has already begun.", 'EALREADYBEGUN'));
        return this;
      }
      this.connection.driver.Transaction.prototype.begin.call(this, (function(_this) {
        return function(err) {
          if (!err) {
            _this.emit('begin');
          }
          return callback(err);
        };
      })(this));
      return this;
    };


    /*
    	Commit a transaction.
    	
    	@callback [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction|Promise}
     */

    Transaction.prototype.commit = function(callback) {
      if (callback != null) {
        return this._commit(callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._commit(function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    Transaction.prototype._commit = function(callback) {
      if (!this._pooledConnection) {
        callback(new TransactionError("Transaction has not begun. Call begin() first.", 'ENOTBEGUN'));
        return this;
      }
      if (this._working) {
        callback(new TransactionError("Can't commit transaction. There is a request in progress.", 'EREQINPROG'));
        return this;
      }
      if (this._queue.length) {
        callback(new TransactionError("Can't commit transaction. There are request in queue.", 'EREQINPROG'));
        return this;
      }
      this.connection.driver.Transaction.prototype.commit.call(this, (function(_this) {
        return function(err) {
          if (!err) {
            _this.emit('commit');
          }
          return callback(err);
        };
      })(this));
      return this;
    };


    /*
    	Execute next request in queue.
    	
    	@private
    	@returns {Transaction}
     */

    Transaction.prototype.next = function() {
      var toAbort;
      if (this._aborted) {
        toAbort = this._queue;
        this._queue = [];
        process.nextTick((function(_this) {
          return function() {
            var results;
            results = [];
            while (toAbort.length) {
              results.push(toAbort.shift()(new TransactionError("Transaction aborted.", "EABORT")));
            }
            return results;
          };
        })(this));
      }
      this._working = false;
      if (this._queue.length) {
        process.nextTick((function(_this) {
          return function() {
            if (_this._aborted) {
              return _this.next();
            }
            _this._working = true;
            return _this._queue.shift()(null, _this._pooledConnection);
          };
        })(this));
      }
      return this;
    };


    /*
    	Add request to queue for connection. If queue is empty, execute the request immediately.
    	
    	@private
    	@callback callback A callback to call when connection in ready to execute request.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} conn Internal driver's connection.
    	@returns {Transaction}
     */

    Transaction.prototype.queue = function(callback) {
      if (this._dedicatedConnection) {
        callback(null, this._dedicatedConnection);
        return this;
      }
      if (!this._pooledConnection) {
        callback(new TransactionError("Transaction has not begun. Call begin() first.", 'ENOTBEGUN'));
        return this;
      }
      if (this._working || this._queue.length) {
        this._queue.push(callback);
      } else {
        this._working = true;
        callback(null, this._pooledConnection);
      }
      return this;
    };


    /*
    	Returns new request using this transaction.
    	
    	@returns {Request}
     */

    Transaction.prototype.request = function() {
      return new Request(this);
    };


    /*
    	Rollback a transaction.
    	
    	@callback [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction|Promise}
     */

    Transaction.prototype.rollback = function(callback) {
      if (callback != null) {
        return this._rollback(callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._rollback(function(err) {
            if (err) {
              return reject(err);
            }
            return resolve();
          });
        };
      })(this));
    };

    Transaction.prototype._rollback = function(callback) {
      if (this._aborted) {
        callback(new TransactionError("Transaction has been aborted.", 'EABORT'));
        return this;
      }
      if (!this._pooledConnection) {
        callback(new TransactionError("Transaction has not begun. Call begin() first.", 'ENOTBEGUN'));
        return this;
      }
      if (this._working) {
        callback(new TransactionError("Can't rollback transaction. There is a request in progress.", 'EREQINPROG'));
        return this;
      }
      if (this._queue.length) {
        this._aborted = true;
      }
      this.connection.driver.Transaction.prototype.rollback.call(this, (function(_this) {
        return function(err) {
          if (!err) {
            _this.emit('rollback', _this._aborted);
          }
          return callback(err);
        };
      })(this));
      return this;
    };

    return Transaction;

  })(EventEmitter);


  /*
  Class Request.
  
  @property {Connection} connection Reference to used connection.
  @property {Transaction} transaction Reference to transaction when request was created in transaction.
  @property {*} parameters Collection of input and output parameters.
  @property {Boolean} verbose If `true`, debug messages are printed to message log.
  @property {Boolean} multiple If `true`, `query` will handle multiple recordsets (`execute` always expect multiple recordsets).
  @property {Boolean} canceled `true` if request was canceled.
  
  @event recordset Dispatched when metadata for new recordset are parsed.
  @event row Dispatched when new row is parsed.
  @event done Dispatched when request is complete.
  @event error Dispatched on error.
   */

  Request = (function(superClass) {
    extend(Request, superClass);

    Request.prototype.connection = null;

    Request.prototype.transaction = null;

    Request.prototype.pstatement = null;

    Request.prototype.parameters = null;

    Request.prototype.verbose = false;

    Request.prototype.multiple = false;

    Request.prototype.canceled = false;

    Request.prototype.stream = null;


    /*
    	Create new Request.
    	
    	@param {Connection|Transaction} connection If ommited, global connection is used instead.
     */

    function Request(connection) {
      if (connection instanceof Transaction) {
        this.transaction = connection;
        this.connection = connection.connection;
      } else if (connection instanceof PreparedStatement) {
        this.pstatement = connection;
        this.connection = connection.connection;
      } else if (connection instanceof Connection) {
        this.connection = connection;
      } else {
        this.connection = global_connection;
      }
      this.parameters = {};
    }


    /*
    	Log to a function if assigned. Else, use console.log.
     */

    Request.prototype._log = function(out) {
      if (typeof this.logger === "function") {
        return this.logger(out);
      } else {
        return console.log(out);
      }
    };


    /*
    	Acquire connection for this request from connection.
     */

    Request.prototype._acquire = function(callback) {
      if (this.transaction) {
        return this.transaction.queue(callback);
      } else if (this.pstatement) {
        return this.pstatement.queue(callback);
      } else {
        if (!this.connection.pool) {
          return callback(new ConnectionError("Connection not yet open.", 'ENOTOPEN'));
        }
        return this.connection.pool.acquire(callback);
      }
    };


    /*
    	Release connection used by this request.
     */

    Request.prototype._release = function(connection) {
      if (this.transaction) {
        return this.transaction.next();
      } else if (this.pstatement) {
        return this.pstatement.next();
      } else {
        return this.connection.pool.release(connection);
      }
    };


    /*
    	Add an input parameter to the request.
    	
    	**Example:**
    	```
    	request.input('input_parameter', value);
    	request.input('input_parameter', sql.Int, value);
    	```
    	
    	@param {String} name Name of the input parameter without @ char.
    	@param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
    	@param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
    	@returns {Request}
     */

    Request.prototype.input = function(name, type, value) {
      if (/(--| |\/\*|\*\/|')/.test(name)) {
        throw new RequestError("SQL injection warning for param '" + name + "'", 'EINJECT');
      }
      if (arguments.length === 1) {
        throw new RequestError("Invalid number of arguments. At least 2 arguments expected.", 'EARGS');
      } else if (arguments.length === 2) {
        value = type;
        type = getTypeByValue(value);
      }
      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {
        value = value.valueOf();
      }
      if (value === void 0) {
        value = null;
      }
      if (value !== value) {
        value = null;
      }
      if (type instanceof Function) {
        type = type();
      }
      this.parameters[name] = {
        name: name,
        type: type.type,
        io: 1,
        value: value,
        length: type.length,
        scale: type.scale,
        precision: type.precision,
        tvpType: type.tvpType
      };
      return this;
    };


    /*
    	Add an output parameter to the request.
    	
    	**Example:**
    	```
    	request.output('output_parameter', sql.Int);
    	request.output('output_parameter', sql.VarChar(50), 'abc');
    	```
    	
    	@param {String} name Name of the output parameter without @ char.
    	@param {*} type SQL data type of output parameter.
    	@param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
    	@returns {Request}
     */

    Request.prototype.output = function(name, type, value) {
      if (!type) {
        type = TYPES.NVarChar;
      }
      if (/(--| |\/\*|\*\/|')/.test(name)) {
        throw new RequestError("SQL injection warning for param '" + name + "'", 'EINJECT');
      }
      if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {
        throw new RequestError("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", 'EDEPRECATED');
      }
      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {
        value = value.valueOf();
      }
      if (value === void 0) {
        value = null;
      }
      if (value !== value) {
        value = null;
      }
      if (type instanceof Function) {
        type = type();
      }
      this.parameters[name] = {
        name: name,
        type: type.type,
        io: 2,
        value: value,
        length: type.length,
        scale: type.scale,
        precision: type.precision
      };
      return this;
    };


    /*
    	Execute the SQL batch.
    
    	@param {String} batch T-SQL batch to be executed.
    	@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} recordset Recordset.
    	
    	@returns {Request|Promise}
     */

    Request.prototype.batch = function(batch, callback) {
      var ref1;
      if (this.stream == null) {
        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;
      }
      if (this.stream || (callback != null)) {
        return this._batch(batch, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._batch(batch, function(err, recordset) {
            if (err) {
              return reject(err);
            }
            return resolve(recordset);
          });
        };
      })(this));
    };

    Request.prototype._batch = function(batch, callback) {
      if (!this.connection) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new RequestError("No connection is specified for that request.", 'ENOCONN');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      if (!this.connection.connected) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new ConnectionError("Connection is closed.", 'ECONNCLOSED');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      this.canceled = false;
      this.connection.driver.Request.prototype.batch.call(this, batch, (function(_this) {
        return function(err, recordset) {
          if (_this.stream) {
            if (err) {
              _this.emit('error', err);
            }
            return _this.emit('done');
          } else {
            return callback(err, recordset);
          }
        };
      })(this));
      return this;
    };


    /*
    	Bulk load.
    
    	@param {Table} table SQL table.
    	@callback [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    	
    	@returns {Request|Promise}
     */

    Request.prototype.bulk = function(table, callback) {
      var ref1;
      if (this.stream == null) {
        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;
      }
      if (this.stream || (callback != null)) {
        return this._bulk(table, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._bulk(table, function(err, rowCount) {
            if (err) {
              return reject(err);
            }
            return resolve(rowCount);
          });
        };
      })(this));
    };

    Request.prototype._bulk = function(table, callback) {
      if (!this.connection) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new RequestError("No connection is specified for that request.", 'ENOCONN');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      if (!this.connection.connected) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new ConnectionError("Connection is closed.", 'ECONNCLOSED');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      this.canceled = false;
      this.connection.driver.Request.prototype.bulk.call(this, table, (function(_this) {
        return function(err, rowCount) {
          if (_this.stream) {
            if (err) {
              _this.emit('error', err);
            }
            return _this.emit('done');
          } else {
            return callback(err, rowCount);
          }
        };
      })(this));
      return this;
    };


    /*
    	Sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
    	
    	@param {Stream} stream Stream to pipe data into.
    	@returns {Stream}
     */

    Request.prototype.pipe = function(stream) {
      this.stream = true;
      this.on('row', stream.write.bind(stream));
      this.on('error', stream.emit.bind(stream, 'error'));
      this.on('done', function() {
        return setImmediate(function() {
          return stream.end();
        });
      });
      stream.emit('pipe', this);
      return stream;
    };


    /*
    	Execute the SQL command.
    	
    	**Example:**
    	```
    	var request = new sql.Request();
    	request.query('select 1 as number', function(err, recordset) {
    	    console.log(recordset[0].number); // return 1
    	
    	    // ...
    	});
    	```
    	
    	You can enable multiple recordsets in querries by `request.multiple = true` command.
    	
    	```
    	var request = new sql.Request();
    	request.multiple = true;
    	
    	request.query('select 1 as number; select 2 as number', function(err, recordsets) {
    	    console.log(recordsets[0][0].number); // return 1
    	    console.log(recordsets[1][0].number); // return 2
    	
    	    // ...
    	});
    	```
    	
    	@param {String} command T-SQL command to be executed.
    	@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} recordset Recordset.
    	
    	@returns {Request|Promise}
     */

    Request.prototype.query = function(command, callback) {
      var ref1;
      if (this.stream == null) {
        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;
      }
      if (this.stream || (callback != null)) {
        return this._query(command, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._query(command, function(err, recordset) {
            if (err) {
              return reject(err);
            }
            return resolve(recordset);
          });
        };
      })(this));
    };

    Request.prototype._query = function(command, callback) {
      if (!this.connection) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new RequestError("No connection is specified for that request.", 'ENOCONN');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      if (!this.connection.connected) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new ConnectionError("Connection is closed.", 'ECONNCLOSED');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      this.canceled = false;
      this.connection.driver.Request.prototype.query.call(this, command, (function(_this) {
        return function(err, recordset) {
          if (_this.stream) {
            if (err) {
              _this.emit('error', err);
            }
            return _this.emit('done');
          } else {
            return callback(err, recordset);
          }
        };
      })(this));
      return this;
    };


    /*
    	Call a stored procedure.
    	
    	**Example:**
    	```
    	var request = new sql.Request();
    	request.input('input_parameter', sql.Int, value);
    	request.output('output_parameter', sql.Int);
    	request.execute('procedure_name', function(err, recordsets, returnValue) {
    	    console.log(recordsets.length); // count of recordsets returned by procedure
    	    console.log(recordset[0].length); // count of rows contained in first recordset
    	    console.log(returnValue); // procedure return value
    	    console.log(recordsets.returnValue); // procedure return value
    	
    	    console.log(request.parameters.output_parameter.value); // output value
    	
    	    // ...
    	});
    	```
    	
    	@param {String} procedure Name of the stored procedure to be executed.
    	@callback [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
    		@param {Error} err Error on error, otherwise null.
    		@param {Array} recordsets Recordsets.
    		@param {Number} returnValue Procedure return value.
    	
    	@returns {Request|Promise}
     */

    Request.prototype.execute = function(command, callback) {
      var ref1;
      if (this.stream == null) {
        this.stream = (ref1 = this.connection) != null ? ref1.config.stream : void 0;
      }
      if (this.stream || (callback != null)) {
        return this._execute(command, callback);
      }
      return new module.exports.Promise((function(_this) {
        return function(resolve, reject) {
          return _this._execute(command, function(err, recordset) {
            if (err) {
              return reject(err);
            }
            return resolve(recordset);
          });
        };
      })(this));
    };

    Request.prototype._execute = function(procedure, callback) {
      if (!this.connection) {
        return process.nextTick(function() {
          var e;
          e = new RequestError("No connection is specified for that request.", 'ENOCONN');
          if (this.stream) {
            this.emit('error', e);
            return this.emit('done');
          } else {
            return callback(e);
          }
        });
      }
      if (!this.connection.connected) {
        return process.nextTick((function(_this) {
          return function() {
            var e;
            e = new ConnectionError("Connection is closed.", 'ECONNCLOSED');
            if (_this.stream) {
              _this.emit('error', e);
              return _this.emit('done');
            } else {
              return callback(e);
            }
          };
        })(this));
      }
      this.canceled = false;
      this.connection.driver.Request.prototype.execute.call(this, procedure, (function(_this) {
        return function(err, recordsets, returnValue) {
          if (_this.stream) {
            if (err) {
              _this.emit('error', err);
            }
            return _this.emit('done', returnValue);
          } else {
            return callback(err, recordsets, returnValue);
          }
        };
      })(this));
      return this;
    };


    /*
    	Cancel currently executed request.
    	
    	@returns {Request}
     */

    Request.prototype.cancel = function() {
      this.canceled = true;
      this.connection.driver.Request.prototype.cancel.call(this);
      return this;
    };

    return Request;

  })(EventEmitter);

  ConnectionError = (function(superClass) {
    extend(ConnectionError, superClass);

    function ConnectionError(message, code) {
      var err;
      if (!(this instanceof ConnectionError)) {
        if (message instanceof Error) {
          err = new ConnectionError(message.message, message.code);
          Object.defineProperty(err, 'originalError', {
            value: message
          });
          Error.captureStackTrace(err, arguments.callee);
          return err;
        } else {
          err = new ConnectionError(message);
          Error.captureStackTrace(err, arguments.callee);
          return err;
        }
      }
      this.name = this.constructor.name;
      this.message = message;
      if (code != null) {
        this.code = code;
      }
      ConnectionError.__super__.constructor.call(this);
      Error.captureStackTrace(this, this.constructor);
    }

    return ConnectionError;

  })(Error);

  TransactionError = (function(superClass) {
    extend(TransactionError, superClass);

    function TransactionError(message, code) {
      var err;
      if (!(this instanceof TransactionError)) {
        if (message instanceof Error) {
          err = new TransactionError(message.message, message.code);
          Object.defineProperty(err, 'originalError', {
            value: message
          });
          Error.captureStackTrace(err, arguments.callee);
          return err;
        } else {
          err = new TransactionError(message);
          Error.captureStackTrace(err, arguments.callee);
          return err;
        }
      }
      this.name = this.constructor.name;
      this.message = message;
      if (code != null) {
        this.code = code;
      }
      TransactionError.__super__.constructor.call(this);
      Error.captureStackTrace(this, this.constructor);
    }

    return TransactionError;

  })(Error);

  RequestError = (function(superClass) {
    extend(RequestError, superClass);

    function RequestError(message, code) {
      var err, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      if (!(this instanceof RequestError)) {
        if (message instanceof Error) {
          err = new RequestError(message.message, (ref1 = message.code) != null ? ref1 : code);
          err.number = (ref2 = (ref3 = message.info) != null ? ref3.number : void 0) != null ? ref2 : message.code;
          err.lineNumber = (ref4 = message.info) != null ? ref4.lineNumber : void 0;
          err.state = (ref5 = (ref6 = message.info) != null ? ref6.state : void 0) != null ? ref5 : message.sqlstate;
          err["class"] = (ref7 = (ref8 = message.info) != null ? ref8["class"] : void 0) != null ? ref7 : (ref9 = message.info) != null ? ref9.severity : void 0;
          err.serverName = (ref10 = message.info) != null ? ref10.serverName : void 0;
          err.procName = (ref11 = message.info) != null ? ref11.procName : void 0;
          Object.defineProperty(err, 'originalError', {
            value: message
          });
          Error.captureStackTrace(err, arguments.callee);
          return err;
        } else {
          err = new RequestError(message);
          Error.captureStackTrace(err, arguments.callee);
          return err;
        }
      }
      this.name = this.constructor.name;
      this.message = message;
      if (code != null) {
        this.code = code;
      }
      RequestError.__super__.constructor.call(this);
      Error.captureStackTrace(this, this.constructor);
    }

    return RequestError;

  })(Error);

  PreparedStatementError = (function(superClass) {
    extend(PreparedStatementError, superClass);

    function PreparedStatementError(message, code) {
      var err;
      if (!(this instanceof PreparedStatementError)) {
        if (message instanceof Error) {
          err = new PreparedStatementError(message.message, message.code);
          err.originalError = message;
          Error.captureStackTrace(err, arguments.callee);
          return err;
        } else {
          err = new PreparedStatementError(message);
          Error.captureStackTrace(err, arguments.callee);
          return err;
        }
      }
      this.name = this.constructor.name;
      this.message = message;
      this.code = code;
      PreparedStatementError.__super__.constructor.call(this);
      Error.captureStackTrace(this, this.constructor);
    }

    return PreparedStatementError;

  })(Error);


  /*
  Open global connection.
  
  @param {Object} config Connection configuration.
  @callback callback A callback which is called after connection has established, or an error has occurred.
  	@param {Error} err Error on error, otherwise null.
  	
  @returns {Connection}
   */

  module.exports.connect = function(config, callback) {
    global_connection = new Connection(config);
    return global_connection.connect(callback);
  };


  /*
  Close global connection.
  	
  @returns {Connection}
   */

  module.exports.close = function(callback) {
    return global_connection != null ? global_connection.close(callback) : void 0;
  };

  module.exports.on = function(event, handler) {
    return global_connection != null ? global_connection.on(event, handler) : void 0;
  };

  module.exports.Connection = Connection;

  module.exports.Transaction = Transaction;

  module.exports.Request = Request;

  module.exports.Table = Table;

  module.exports.PreparedStatement = PreparedStatement;

  module.exports.ConnectionError = ConnectionError;

  module.exports.TransactionError = TransactionError;

  module.exports.RequestError = RequestError;

  module.exports.PreparedStatementError = PreparedStatementError;

  module.exports.ISOLATION_LEVEL = ISOLATION_LEVEL;

  module.exports.DRIVERS = DRIVERS;

  module.exports.TYPES = TYPES;

  module.exports.MAX = 65535;

  module.exports.map = map;

  module.exports.fix = true;

  module.exports.Promise = (ref1 = global.Promise) != null ? ref1 : require('promise');

  for (key in TYPES) {
    value = TYPES[key];
    module.exports[key] = value;
    module.exports[key.toUpperCase()] = value;
  }

  module.exports.pool = {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  };

  module.exports.connection = {
    userName: '',
    password: '',
    server: ''
  };


  /*
  Initialize Tedious connection pool.
  
  @deprecated
   */

  module.exports.init = function() {
    return module.exports.connect({
      user: module.exports.connection.userName,
      password: module.exports.connection.password,
      server: module.exports.connection.server,
      options: module.exports.connection.options,
      driver: 'tedious',
      pool: module.exports.pool
    });
  };

}).call(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./datatypes":2,"./isolationlevel":3,"./table":5,"_process":116,"buffer":108,"events":113,"fs":107,"promise":6,"util":118}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.3
(function() {
  var JSON_COLUMN_ID, MAX, TYPES, Table, declare, ref,
    slice = [].slice;

  ref = require('./datatypes'), TYPES = ref.TYPES, declare = ref.declare;

  MAX = 65535;

  JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';

  Table = (function() {
    function Table(name) {
      var buffer, char, cursor, escaped, length, path;
      if (name) {
        length = name.length;
        cursor = -1;
        buffer = '';
        escaped = false;
        path = [];
        while (++cursor < length) {
          char = name.charAt(cursor);
          if (char === '[') {
            if (escaped) {
              buffer += char;
            } else {
              escaped = true;
            }
          } else if (char === ']') {
            if (escaped) {
              escaped = false;
            } else {
              throw new Error("Invalid table name.");
            }
          } else if (char === '.') {
            if (escaped) {
              buffer += char;
            } else {
              path.push(buffer);
              buffer = '';
            }
          } else {
            buffer += char;
          }
        }
        if (buffer) {
          path.push(buffer);
        }
        switch (path.length) {
          case 1:
            this.name = path[0];
            this.schema = null;
            this.database = null;
            break;
          case 2:
            this.name = path[1];
            this.schema = path[0];
            this.database = null;
            break;
          case 3:
            this.name = path[2];
            this.schema = path[1];
            this.database = path[0];
        }
        this.path = "" + (this.database ? "[" + this.database + "]." : "") + (this.schema ? "[" + this.schema + "]." : "") + "[" + this.name + "]";
        this.temporary = this.name.charAt(0) === '#';
      }
      this.columns = [];
      this.rows = [];
      Object.defineProperty(this.columns, "add", {
        value: function(name, column, options) {
          if (options == null) {
            options = {};
          }
          if (column == null) {
            throw new Error("Column data type is not defined.");
          }
          if (column instanceof Function) {
            column = column();
          }
          column.name = name;
          column.nullable = options.nullable;
          return this.push(column);
        }
      });
      Object.defineProperty(this.rows, "add", {
        value: function() {
          var values;
          values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return this.push(values);
        }
      });
    }


    /*
    	@private
     */

    Table.prototype._makeBulk = function() {
      var col, i, len, ref1;
      ref1 = this.columns;
      for (i = 0, len = ref1.length; i < len; i++) {
        col = ref1[i];
        switch (col.type) {
          case TYPES.Xml:
            col.type = TYPES.NVarChar(MAX).type;
            break;
          case TYPES.UDT:
          case TYPES.Geography:
          case TYPES.Geometry:
            col.type = TYPES.VarBinary(MAX).type;
        }
      }
      return this;
    };

    Table.prototype.declare = function() {
      var col;
      return "create table " + this.path + " (" + (((function() {
        var i, len, ref1, results;
        ref1 = this.columns;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          col = ref1[i];
          results.push("[" + col.name + "] " + (declare(col.type, col)) + (col.nullable === true ? " null" : col.nullable === false ? " not null" : ""));
        }
        return results;
      }).call(this)).join(', ')) + ")";
    };

    Table.fromRecordset = function(recordset) {
      var col, i, j, len, len1, name, ref1, ref2, row, t;
      t = new this;
      ref1 = recordset.columns;
      for (name in ref1) {
        col = ref1[name];
        t.columns.add(name, {
          type: col.type,
          length: col.length,
          scale: col.scale,
          precision: col.precision
        }, {
          nullable: col.nullable
        });
      }
      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
        for (i = 0, len = recordset.length; i < len; i++) {
          row = recordset[i];
          t.rows.add(JSON.stringify(row));
        }
      } else {
        for (j = 0, len1 = recordset.length; j < len1; j++) {
          row = recordset[j];
          (ref2 = t.rows).add.apply(ref2, (function() {
            var k, len2, ref2, results;
            ref2 = t.columns;
            results = [];
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              col = ref2[k];
              results.push(row[col.name]);
            }
            return results;
          })());
        }
      }
      return t;
    };

    return Table;

  })();

  module.exports = Table;

}).call(this);

},{"./datatypes":2}],6:[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":11}],7:[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._37 = 0;
  this._12 = null;
  this._59 = [];
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._99 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._37 === 3) {
    self = self._12;
  }
  if (self._37 === 0) {
    self._59.push(deferred);
    return;
  }
  asap(function() {
    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._37 === 1) {
        resolve(deferred.promise, self._12);
      } else {
        reject(deferred.promise, self._12);
      }
      return;
    }
    var ret = tryCallOne(cb, self._12);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._37 = 3;
      self._12 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._37 = 1;
  self._12 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._37 = 2;
  self._12 = newValue;
  finale(self);
}
function finale(self) {
  for (var i = 0; i < self._59.length; i++) {
    handle(self, self._59[i]);
  }
  self._59 = null;
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":15}],8:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":7}],9:[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._99);
  p._37 = 1;
  p._12 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._37 === 3) {
            val = val._12;
          }
          if (val._37 === 1) return res(i, val._12);
          if (val._37 === 2) reject(val._12);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":7}],10:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":7}],11:[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');

},{"./core.js":7,"./done.js":8,"./es6-extensions.js":9,"./finally.js":10,"./node-extensions.js":12}],12:[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity;
  return function () {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0,
        argumentCount > 0 ? argumentCount : 0);
    return new Promise(function (resolve, reject) {
      args.push(function (err, res) {
        if (err) reject(err);
        else resolve(res);
      })
      var res = fn.apply(self, args);
      if (res &&
        (
          typeof res === 'object' ||
          typeof res === 'function'
        ) &&
        typeof res.then === 'function'
      ) {
        resolve(res);
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
}

},{"./core.js":7,"asap":13}],13:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":14}],14:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(require,module,exports){
(function (process){
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = require("domain");
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}

}).call(this,require('_process'))
},{"_process":116,"domain":112}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var JS, JavaScript, JavaScriptToQueryVisitor, PartialEvaluator, esprima;

  esprima = require('esprima');

  JS = require('./JavaScriptNodes');

  PartialEvaluator = require('./PartialEvaluator').PartialEvaluator;

  JavaScriptToQueryVisitor = require('./JavaScriptToQueryVisitor').JavaScriptToQueryVisitor;


  /*
   * Define operations on JavaScript
   */

  exports.JavaScript = JavaScript = (function() {
    function JavaScript() {}


    /*
     * Static method to transform a constraint specified as a function into
     * a QueryExpression tree.
     */

    JavaScript.transformConstraint = function(func, env) {

      /*
       * Parse the body of the function into a JavaScriptExpression tree
       * (into a context that also contains its source and manually reified
       * environment)
       */
      var context, translator;
      context = JavaScript.getExpression(func, env);

      /*
       * Evaluate any independent subexpressions and turn them into
       * literals.
       */
      context.expression = PartialEvaluator.evaluate(context);

      /*
       * Convert the JavaScriptExpression tree into a QueryExpression tree
       */
      translator = new JavaScriptToQueryVisitor(context);
      return translator.visit(context.expression);
    };


    /*
     * Static method to walk a projection specified as a function and
     * determine which fields it uses.
     */

    JavaScript.getProjectedFields = function(func) {

      /*
       * This currently returns an empty array which indicates all fields.
       * At some point we'll need to go through and walk the expression
       * tree for func and see exactly which fields it uses.  This is
       * complicated by the fact that we support arbitrary expressions and
       * could for example pass 'this' to a nested lambda which means we
       * can't just check for MemberExpressions (though in that case we'll
       * probably just default to [] rather than trying to do alias
       * analysis across function calls, etc.)
       */
      return [];
    };


    /*
     * Turn a function and its explicitly passed environment into an
     * expression tree
     */

    JavaScript.getExpression = function(func, env) {

      /*
       * An anonymous function isn't considered a valid program, so we'll wrap
       * it in an assignment statement to keep the parser happy
       */
      var environment, expr, i, name, names, program, source, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      source = "var _$$_stmt_$$_ = " + func + ";";

      /*
       * Use esprima to parse the source of the function body (and have it
       * return source locations in character ranges )
       */
      program = esprima.parse(source, {
        range: true
      });

      /*
       * Get the expression from return statement of the function body to use
       * as our lambda expression
       */
      expr = (program != null ? program.type : void 0) === 'Program' && (program != null ? (_ref = program.body) != null ? _ref.length : void 0 : void 0) === 1 && ((_ref1 = program.body[0]) != null ? _ref1.type : void 0) === 'VariableDeclaration' && ((_ref2 = program.body[0]) != null ? (_ref3 = _ref2.declarations) != null ? _ref3.length : void 0 : void 0) === 1 && ((_ref4 = program.body[0].declarations[0]) != null ? _ref4.type : void 0) === 'VariableDeclarator' && ((_ref5 = program.body[0].declarations[0]) != null ? (_ref6 = _ref5.init) != null ? _ref6.type : void 0 : void 0) === 'FunctionExpression' && ((_ref7 = program.body[0].declarations[0].init) != null ? (_ref8 = _ref7.body) != null ? _ref8.type : void 0 : void 0) === 'BlockStatement' && ((_ref9 = program.body[0].declarations[0].init.body) != null ? (_ref10 = _ref9.body) != null ? _ref10.length : void 0 : void 0) === 1 && ((_ref11 = program.body[0].declarations[0].init.body.body[0]) != null ? _ref11.type : void 0) === 'ReturnStatement' && ((_ref12 = program.body[0].declarations[0].init.body.body[0]) != null ? _ref12.argument : void 0);
      if (!expr) {
        throw "Expected a predicate with a single return statement, not " + func;
      }

      /*
       * Create the environment mqpping parameters to values
       */
      names = (_ref13 = program.body[0].declarations[0].init.params) != null ? _ref13.map(function(p) {
        return p.name;
      }) : void 0;
      if (names.length > env.length) {
        throw "Expected value(s) for parameter(s) " + names.slice(env.length);
      } else if (env.length > names.length) {
        throw "Expected parameter(s) for value(s) " + env.slice(names.length);
      }
      environment = {};
      for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
        name = names[i];
        environment[name] = env[i];
      }
      return {

        /*
         * Return the environment context
         */
        source: source,
        expression: expr,
        environment: environment
      };
    };

    return JavaScript;

  })();

}).call(this);

},{"./JavaScriptNodes":17,"./JavaScriptToQueryVisitor":18,"./PartialEvaluator":21,"esprima":25}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/*
 * Define the Esprima node structure for JavaScript parse trees.  This is mostly
 * identical to the SpiderMonkey API defined at
 * https://developer.mozilla.org/en/SpiderMonkey/Parser_API without any of the
 * SpiderMonkey specifics and a few simplifications made by Esprima (i.e. it
 * doesn't have separate objects for operator types, etc.).
 *
 * It's important to note that the Esprima parse tree will return object literals
 * and not instances of these types.  They're provided primarily for reference
 * and for easily constructing new subtrees during transformations by visitors.
 */


/* Get the base Node and Visitor classes. */

(function() {
  var ArrayExpression, ArrayPattern, AssignmentExpression, BinaryExpression, BlockStatement, BreakStatement, CallExpression, CatchClause, ConditionalExpression, ContinueStatement, DebuggerStatement, Declaration, DoWhileStatement, EmptyStatement, Expression, ExpressionStatement, ForInStatement, ForStatement, Function, FunctionDeclaration, FunctionExpression, Identifier, IfStatement, JavaScriptNode, JavaScriptVisitor, LabeledStatement, Literal, LogicalExpression, MemberExpression, NewExpression, Node, ObjectExpression, ObjectPattern, Pattern, Program, ReturnStatement, SequenceExpression, Statement, SwitchCase, SwitchStatement, ThisExpression, ThrowStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclarator, Visitor, WhileStatement, WithStatement, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./Node'), Node = _ref.Node, Visitor = _ref.Visitor;


  /*
   * Base node for all JavaScript nodes.
   */

  exports.JavaScriptNode = JavaScriptNode = (function(_super) {
    __extends(JavaScriptNode, _super);

    function JavaScriptNode() {
      JavaScriptNode.__super__.constructor.call(this);
    }

    return JavaScriptNode;

  })(Node);


  /*
   * Base visitor for all JavaScript nodes.
   */

  exports.JavaScriptVisitor = JavaScriptVisitor = (function(_super) {
    __extends(JavaScriptVisitor, _super);

    function JavaScriptVisitor() {
      JavaScriptVisitor.__super__.constructor.call(this);
    }

    JavaScriptVisitor.prototype.JavaScriptNode = function(node) {
      return node;
    };

    return JavaScriptVisitor;

  })(Visitor);


  /*
   * A complete program source tree.
   */

  exports.Program = Program = (function(_super) {
    __extends(Program, _super);


    /*
     * @elements: [Statement]
     */

    function Program(elements) {
      this.elements = elements;
      Program.__super__.constructor.call(this);
    }

    return Program;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Program = function(node) {
    node = this.JavaScriptNode(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * A function declaration or expression. The body of the function is a  block
   * statement.
   */

  exports.Function = Function = (function(_super) {
    __extends(Function, _super);


    /*
     * @id: Identifier | null
     * @params: [Pattern]
     * @body: BlockStatement
     */

    function Function(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      Function.__super__.constructor.call(this);
    }

    return Function;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Function = function(node) {
    node = this.JavaScriptNode(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * Any statement.
   */

  exports.Statement = Statement = (function(_super) {
    __extends(Statement, _super);

    function Statement() {
      Statement.__super__.constructor.call(this);
    }

    return Statement;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Statement = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * An empty statement, i.e., a solitary semicolon.
   */

  exports.EmptyStatement = EmptyStatement = (function(_super) {
    __extends(EmptyStatement, _super);

    function EmptyStatement() {
      EmptyStatement.__super__.constructor.call(this);
    }

    return EmptyStatement;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.EmptyStatement = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A block statement, i.e., a sequence of statements surrounded by braces.
   */

  exports.BlockStatement = BlockStatement = (function(_super) {
    __extends(BlockStatement, _super);


    /*
     * @body: [Statement]
     */

    function BlockStatement(body) {
      this.body = body;
      BlockStatement.__super__.constructor.call(this);
    }

    return BlockStatement;

  })(Statement);

  JavaScriptVisitor.prototype.BlockStatement = function(node) {
    node = this.Statement(node);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * An expression statement, i.e., a statement consisting of a single expression.
   */

  exports.ExpressionStatement = ExpressionStatement = (function(_super) {
    __extends(ExpressionStatement, _super);

    function ExpressionStatement() {
      ExpressionStatement.__super__.constructor.call(this);
    }

    return ExpressionStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ExpressionStatement = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * An if statement.
   */

  exports.IfStatement = IfStatement = (function(_super) {
    __extends(IfStatement, _super);


    /*
     * @test: Expression
     * @consequent: Statement
     * @alternate: Statement | null
     */

    function IfStatement(test, consequent, alternate) {
      this.test = test;
      this.consequent = consequent;
      this.alternate = alternate;
      IfStatement.__super__.constructor.call(this);
    }

    return IfStatement;

  })(Statement);

  JavaScriptVisitor.prototype.IfStatement = function(node) {
    node = this.Statement(node);
    node.test = this.visit(node.test);
    node.consequent = this.visit(node.consequent);
    node.alternate = this.visit(node.alternate);
    return node;
  };


  /*
   * A labeled statement, i.e., a statement prefixed by a break/continue label.
   */

  exports.LabeledStatement = LabeledStatement = (function(_super) {
    __extends(LabeledStatement, _super);


    /*
     * @label: Identifier
     * @body: Statement
     */

    function LabeledStatement(label, body) {
      this.label = label;
      this.body = body;
      LabeledStatement.__super__.constructor.call(this);
    }

    return LabeledStatement;

  })(Statement);

  JavaScriptVisitor.prototype.LabeledStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A break statement.
   */

  exports.BreakStatement = BreakStatement = (function(_super) {
    __extends(BreakStatement, _super);


    /*
     * @label: Identifier | null
     */

    function BreakStatement(label) {
      this.label = label;
      BreakStatement.__super__.constructor.call(this);
    }

    return BreakStatement;

  })(Statement);

  JavaScriptVisitor.prototype.BreakStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    return node;
  };


  /*
  A continue statement.
   */

  exports.ContinueStatement = ContinueStatement = (function(_super) {
    __extends(ContinueStatement, _super);


    /*
    @label: Identifier | null
     */

    function ContinueStatement(label) {
      this.label = label;
      ContinueStatement.__super__.constructor.call(this);
    }

    return ContinueStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ContinueStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    return node;
  };


  /*
   * A with statement.
   */

  exports.WithStatement = WithStatement = (function(_super) {
    __extends(WithStatement, _super);


    /*
     * @object: Expression
     * @body: Statement
     */

    function WithStatement(object, body) {
      this.object = object;
      this.body = body;
      WithStatement.__super__.constructor.call(this);
    }

    return WithStatement;

  })(Statement);

  JavaScriptVisitor.prototype.WithStatement = function(node) {
    node = this.Statement(node);
    node.object = this.visit(node.object);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A switch statement.
   */

  exports.SwitchStatement = SwitchStatement = (function(_super) {
    __extends(SwitchStatement, _super);


    /*
     * @discriminant: Expression
     * @cases: [SwitchCase]
     */

    function SwitchStatement(discriminant, cases) {
      this.discriminant = discriminant;
      this.cases = cases;
      SwitchStatement.__super__.constructor.call(this);
    }

    return SwitchStatement;

  })(Statement);

  JavaScriptVisitor.prototype.SwitchStatement = function(node) {
    node = this.Statement(node);
    node.discriminant = this.visit(node.discriminant);
    node.cases = this.visit(node.cases);
    return node;
  };


  /*
   * A return statement.
   */

  exports.ReturnStatement = ReturnStatement = (function(_super) {
    __extends(ReturnStatement, _super);


    /*
     * @argument: Expression | null
     */

    function ReturnStatement(argument) {
      this.argument = argument;
      ReturnStatement.__super__.constructor.call(this);
    }

    return ReturnStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ReturnStatement = function(node) {
    node = this.Statement(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A throw statement.
   */

  exports.ThrowStatement = ThrowStatement = (function(_super) {
    __extends(ThrowStatement, _super);


    /*
     * @argument: Expression
     */

    function ThrowStatement(argument) {
      this.argument = argument;
      ThrowStatement.__super__.constructor.call(this);
    }

    return ThrowStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ThrowStatement = function(node) {
    node = this.Statement(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A try statement.
   */

  exports.TryStatement = TryStatement = (function(_super) {
    __extends(TryStatement, _super);


    /*
     * @block: BlockStatement
     * @handlers: [CatchClause]
     * @finalizer: BlockStatement | null
     */

    function TryStatement(block, handlers, finalizer) {
      this.block = block;
      this.handlers = handlers;
      this.finalizer = finalizer;
      TryStatement.__super__.constructor.call(this);
    }

    return TryStatement;

  })(Statement);

  JavaScriptVisitor.prototype.TryStatement = function(node) {
    node = this.Statement(node);
    node.block = this.visit(node.block);
    node.handlers = this.visit(node.handlers);
    node.finalizer = this.visit(node.finalizer);
    return node;
  };


  /*
   * A while statement.
   */

  exports.WhileStatement = WhileStatement = (function(_super) {
    __extends(WhileStatement, _super);


    /*
     * @test: Expression
     * @body: Statement
     */

    function WhileStatement(test, body) {
      this.test = test;
      this.body = body;
      WhileStatement.__super__.constructor.call(this);
    }

    return WhileStatement;

  })(Statement);

  JavaScriptVisitor.prototype.WhileStatement = function(node) {
    node = this.Statement(node);
    node.test = this.visit(node.test);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A do/while statement.
   */

  exports.DoWhileStatement = DoWhileStatement = (function(_super) {
    __extends(DoWhileStatement, _super);


    /*
     * @body: Statement
     * @test: Expression
     */

    function DoWhileStatement(body, test) {
      this.body = body;
      this.test = test;
      DoWhileStatement.__super__.constructor.call(this);
    }

    return DoWhileStatement;

  })(Statement);

  JavaScriptVisitor.prototype.DoWhileStatement = function(node) {
    node = this.Statement(node);
    node.body = this.visit(node.body);
    node.test = this.visit(node.test);
    return node;
  };


  /*
   * A for statement.
   */

  exports.ForStatement = ForStatement = (function(_super) {
    __extends(ForStatement, _super);


    /*
     * @init: VariableDeclaration | Expression | null
     * @test: Expression | null
     * @update: Expression | null
     * @body: Statement
     */

    function ForStatement(init, test, update, body) {
      this.init = init;
      this.test = test;
      this.update = update;
      this.body = body;
      ForStatement.__super__.constructor.call(this);
    }

    return ForStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ForStatement = function(node) {
    node = this.Statement(node);
    node.init = this.visit(node.init);
    node.test = this.visit(node.test);
    node.update = this.visit(node.update);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A for/in statement, or, if each is true, a for each/in statement.
   */

  exports.ForInStatement = ForInStatement = (function(_super) {
    __extends(ForInStatement, _super);


    /*
     * @left: VariableDeclaration |  Expression
     * @right: Expression
     * @body: Statement
     */

    function ForInStatement(left, right, body) {
      this.left = left;
      this.right = right;
      this.body = body;
      ForInStatement.__super__.constructor.call(this);
    }

    return ForInStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ForInStatement = function(node) {
    node = this.Statement(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A debugger statement.
   */

  exports.DebuggerStatement = DebuggerStatement = (function(_super) {
    __extends(DebuggerStatement, _super);

    function DebuggerStatement() {
      DebuggerStatement.__super__.constructor.call(this);
    }

    return DebuggerStatement;

  })(Statement);

  JavaScriptVisitor.prototype.DebuggerStatement = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * Any declaration node. Note that declarations are considered statements; this
   * is because declarations can appear in any statement context in the language.
   */

  exports.Declaration = Declaration = (function(_super) {
    __extends(Declaration, _super);

    function Declaration() {
      Declaration.__super__.constructor.call(this);
    }

    return Declaration;

  })(Statement);

  JavaScriptVisitor.prototype.Declaration = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * A function declaration.  Note: The id field cannot be null.
   */

  exports.FunctionDeclaration = FunctionDeclaration = (function(_super) {
    __extends(FunctionDeclaration, _super);


    /*
     * @id: Identifier
     * @params: [ Pattern ]
     * @body: BlockStatement | Expression
     */

    function FunctionDeclaration(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      FunctionDeclaration.__super__.constructor.call(this);
    }

    return FunctionDeclaration;

  })(Declaration);

  JavaScriptVisitor.prototype.FunctionDeclaration = function(node) {
    node = this.Declaration(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A variable declaration, via one of var, let, or const.
   */

  exports.VariableDeclaration = VariableDeclaration = (function(_super) {
    __extends(VariableDeclaration, _super);


    /*
     * @declarations: [ VariableDeclarator ]
     * @kind: "var"
     */

    function VariableDeclaration(declarations, kind) {
      this.declarations = declarations;
      this.kind = kind;
      VariableDeclaration.__super__.constructor.call(this);
    }

    return VariableDeclaration;

  })(Declaration);

  JavaScriptVisitor.prototype.VariableDeclaration = function(node) {
    node = this.Declaration(node);
    node.declarations = this.visit(node.declarations);
    return node;
  };


  /*
   * A variable declarator.  Note: The id field cannot be null.
   */

  exports.VariableDeclarator = VariableDeclarator = (function(_super) {
    __extends(VariableDeclarator, _super);


    /*
     * @id: Pattern
     * @init: Expression | null
     */

    function VariableDeclarator(id, init) {
      this.id = id;
      this.init = init;
      VariableDeclarator.__super__.constructor.call(this);
    }

    return VariableDeclarator;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.VariableDeclarator = function(node) {
    node = this.JavaScriptNode(node);
    node.id = this.visit(node.id);
    node.init = this.visit(node.init);
    return node;
  };


  /*
   * Any expression node. Since the left-hand side of an assignment may be any
   * expression in general, an expression can also be a pattern.
   */

  exports.Expression = Expression = (function(_super) {
    __extends(Expression, _super);

    function Expression() {
      return Expression.__super__.constructor.apply(this, arguments);
    }

    Expression.prototype.constuctor = function() {
      return Expression.__super__.constuctor.call(this);
    };

    return Expression;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Expression = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A this expression.
   */

  exports.ThisExpression = ThisExpression = (function(_super) {
    __extends(ThisExpression, _super);

    function ThisExpression() {
      ThisExpression.__super__.constructor.call(this);
    }

    return ThisExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ThisExpression = function(node) {
    node = this.Expression(node);
    return node;
  };


  /*
   * An array expression.
   */

  exports.ArrayExpression = ArrayExpression = (function(_super) {
    __extends(ArrayExpression, _super);


    /*
     * @elements: [ Expression | null ]
     */

    function ArrayExpression(elements) {
      this.elements = elements;
      ArrayExpression.__super__.constructor.call(this);
    }

    return ArrayExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ArrayExpression = function(node) {
    node = this.Expression(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * An object expression. A literal property in an object expression can have
   * either a string or number as its value.  Ordinary property initializers have a
   * kind value "init"; getters and setters have the kind values "get" and "set",
   * respectively.
   */

  exports.ObjectExpression = ObjectExpression = (function(_super) {
    __extends(ObjectExpression, _super);


    /*
     * @properties: [ { key: Literal | Identifier,
     *                 value: Expression,
     *                 kind: "init" | "get" | "set" } ];
     */

    function ObjectExpression(properties) {
      this.properties = properties;
      ObjectExpression.__super__.constructor.call(this);
    }

    return ObjectExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ObjectExpression = function(node) {
    var setter, _i, _len, _ref1;
    node = this.Expression(node);
    _ref1 = node.properties;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      setter = _ref1[_i];
      setter.key = this.visit(setter.key);
      setter.value = this.visit(setter.value);
    }
    return node;
  };


  /*
   * A function expression.
   */

  exports.FunctionExpression = FunctionExpression = (function(_super) {
    __extends(FunctionExpression, _super);


    /*
     * @id: Identifier | null
     * @params: [ Pattern ]
     * @body: BlockStatement | Expression
     */

    function FunctionExpression(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      FunctionExpression.__super__.constructor.call(this);
    }

    return FunctionExpression;

  })(Expression);

  JavaScriptVisitor.prototype.FunctionExpression = function(node) {
    node = this.Expression(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A sequence expression, i.e., a comma-separated sequence of expressions.
   */

  exports.SequenceExpression = SequenceExpression = (function(_super) {
    __extends(SequenceExpression, _super);


    /*
     * @expressions: [ Expression ]
     */

    function SequenceExpression(expressions) {
      this.expressions = expressions;
      SequenceExpression.__super__.constructor.call(this);
    }

    return SequenceExpression;

  })(Expression);

  JavaScriptVisitor.prototype.SequenceExpression = function(node) {
    node = this.Expression(node);
    node.expressions = this.visit(node.expressions);
    return node;
  };


  /*
   * A unary operator expression.
   */

  exports.UnaryExpression = UnaryExpression = (function(_super) {
    __extends(UnaryExpression, _super);


    /*
     * @operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
     * @prefix: boolean
     * @argument: Expression
     */

    function UnaryExpression(operator, prefix, argument) {
      this.operator = operator;
      this.prefix = prefix;
      this.argument = argument;
      UnaryExpression.__super__.constructor.call(this);
    }

    return UnaryExpression;

  })(Expression);

  JavaScriptVisitor.prototype.UnaryExpression = function(node) {
    node = this.Expression(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A binary operator expression.
   */

  exports.BinaryExpression = BinaryExpression = (function(_super) {
    __extends(BinaryExpression, _super);


    /*
     * @operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">="
     *     | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%"
     *     | "|" | "&" | "^" | "in" | "instanceof" | ".."
     * @left: Expression
     * @right: Expression
     */

    function BinaryExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      BinaryExpression.__super__.constructor.call(this);
    }

    return BinaryExpression;

  })(Expression);

  JavaScriptVisitor.prototype.BinaryExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * An assignment operator expression.
   */

  exports.AssignmentExpression = AssignmentExpression = (function(_super) {
    __extends(AssignmentExpression, _super);


    /*
     * @operator: "=" | "+=" | "-=" | "*=" | "/=" | "%="
     *     | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
     * @left: Expression
     * @right: Expression
     */

    function AssignmentExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      AssignmentExpression.__super__.constructor.call(this);
    }

    return AssignmentExpression;

  })(Expression);

  JavaScriptVisitor.prototype.AssignmentExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * An update (increment or decrement) operator expression.
   */

  exports.UpdateExpression = UpdateExpression = (function(_super) {
    __extends(UpdateExpression, _super);


    /*
     * @operator: "++" | "--"
     * @argument: Expression
     * @prefix: boolean
     */

    function UpdateExpression(operator, argument, prefix) {
      this.operator = operator;
      this.argument = argument;
      this.prefix = prefix;
      UpdateExpression.__super__.constructor.call(this);
    }

    return UpdateExpression;

  })(Expression);

  JavaScriptVisitor.prototype.UpdateExpression = function(node) {
    node = this.Expression(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A logical operator expression.
   */

  exports.LogicalExpression = LogicalExpression = (function(_super) {
    __extends(LogicalExpression, _super);


    /*
     * @operator: "||" | "&&"
     * @left: Expression
     * @right: Expression
     */

    function LogicalExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      LogicalExpression.__super__.constructor.call(this);
    }

    return LogicalExpression;

  })(Expression);

  JavaScriptVisitor.prototype.LogicalExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * A conditional expression, i.e., a ternary ?/: expression.
   */

  exports.ConditionalExpression = ConditionalExpression = (function(_super) {
    __extends(ConditionalExpression, _super);


    /*
     * @test: Expression
     * @alternate: Expression
     * @consequent: Expression
     */

    function ConditionalExpression(test, alternate, consequent) {
      this.test = test;
      this.alternate = alternate;
      this.consequent = consequent;
      ConditionalExpression.__super__.constructor.call(this);
    }

    return ConditionalExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ConditionalExpression = function(node) {
    node = this.Expression(node);
    node.test = this.visit(node.test);
    node.alternate = this.visit(node.alternate);
    node.consequent = this.visit(node.consequent);
    return node;
  };


  /*
   * A new expression.
   */

  exports.NewExpression = NewExpression = (function(_super) {
    __extends(NewExpression, _super);


    /*
     * @callee: Expression
     * @arguments: [ Expression ] | null
     */

    function NewExpression(callee, _arguments) {
      this.callee = callee;
      this["arguments"] = _arguments;
      NewExpression.__super__.constructor.call(this);
    }

    return NewExpression;

  })(Expression);

  JavaScriptVisitor.prototype.NewExpression = function(node) {
    node = this.Expression(node);
    node.callee = this.visit(node.callee);
    node["arguments"] = this.visit(node["arguments"]);
    return node;
  };


  /*
   * A function or method call expression.
   */

  exports.CallExpression = CallExpression = (function(_super) {
    __extends(CallExpression, _super);


    /*
     * @callee: Expression
     * @arguments: [ Expression ]
     */

    function CallExpression(callee, _arguments) {
      this.callee = callee;
      this["arguments"] = _arguments;
      CallExpression.__super__.constructor.call(this);
    }

    return CallExpression;

  })(Expression);

  JavaScriptVisitor.prototype.CallExpression = function(node) {
    node = this.Expression(node);
    node.callee = this.visit(node.callee);
    node["arguments"] = this.visit(node["arguments"]);
    return node;
  };


  /*
   * A member expression. If computed === true, the node corresponds to a computed
   * e1[e2] expression and property is an Expression. If computed === false, the
   * node corresponds to a static e1.x expression and property is an Identifier.
   */

  exports.MemberExpression = MemberExpression = (function(_super) {
    __extends(MemberExpression, _super);


    /*
     * @object: Expression
     * @property: Identifier | Expression
     * @computed : boolean
     */

    function MemberExpression(object, property, computed) {
      this.object = object;
      this.property = property;
      this.computed = computed;
      MemberExpression.__super__.constructor.call(this);
    }

    return MemberExpression;

  })(Expression);

  JavaScriptVisitor.prototype.MemberExpression = function(node) {
    node = this.Expression(node);
    node.object = this.visit(node.object);
    node.property = this.visit(node.property);
    return node;
  };


  /*
   * JavaScript 1.7 introduced destructuring assignment and binding forms.  All
   * binding forms (such as function parameters, variable declarations, and catch
   * block headers), accept array and object destructuring patterns in addition to
   * plain identifiers. The left-hand sides of assignment expressions can be
   * arbitrary expressions, but in the case where the expression is an object or
   * array literal, it is interpreted by SpiderMonkey as a destructuring pattern.
   *
   * Since the left-hand side of an assignment can in general be any expression, in
   * an assignment context, a pattern can be any expression. In binding positions
   * (such as function parameters, variable declarations, and catch headers),
   * patterns can only be identifiers in the base case, not arbitrary expressions.
   */

  exports.Pattern = Pattern = (function(_super) {
    __extends(Pattern, _super);

    function Pattern() {
      Pattern.__super__.constructor.call(this);
    }

    return Pattern;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Pattern = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * An object-destructuring pattern. A literal property in an object pattern can
   * have either a string or number as its value.
   */

  exports.ObjectPattern = ObjectPattern = (function(_super) {
    __extends(ObjectPattern, _super);


    /*
     * @properties: [ { key: Literal | Identifier, value: Pattern } ]
     */

    function ObjectPattern(properties) {
      this.properties = properties;
      ObjectPattern.__super__.constructor.call(this);
    }

    return ObjectPattern;

  })(Pattern);

  JavaScriptVisitor.prototype.ObjectPattern = function(node) {
    var setter, _i, _len, _ref1;
    node = this.Pattern(node);
    _ref1 = node.properties;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      setter = _ref1[_i];
      setter.key = this.visit(setter.key);
      setter.value = this.visit(setter.value);
    }
    return node;
  };


  /*
   * An array-destructuring pattern.
   */

  exports.ArrayPattern = ArrayPattern = (function(_super) {
    __extends(ArrayPattern, _super);


    /*
     * @elements: [ Pattern | null ]
     */

    function ArrayPattern(elements) {
      this.elements = elements;
      ArrayPattern.__super__.constructor.call(this);
    }

    return ArrayPattern;

  })(Pattern);

  JavaScriptVisitor.prototype.ArrayPattern = function(node) {
    node = this.Pattern(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * A case (if test is an Expression) or default (if test === null) clause in the
   * body of a switch statement.
   */

  exports.SwitchCase = SwitchCase = (function(_super) {
    __extends(SwitchCase, _super);


    /*
     * @test: Expression | null
     * @consequent: [ Statement ]
     */

    function SwitchCase(test, consequent) {
      this.test = test;
      this.consequent = consequent;
      SwitchCase.__super__.constructor.call(this);
    }

    return SwitchCase;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.SwitchCase = function(node) {
    node = this.JavaScriptNode(node);
    node.test = this.visit(node.test);
    node.consequent = this.visit(node.consequent);
    return node;
  };


  /*
   * A catch clause following a try block. The optional guard property corresponds
   * to the optional expression guard on the bound variable.
   */

  exports.CatchClause = CatchClause = (function(_super) {
    __extends(CatchClause, _super);


    /*
     * @param: Pattern
     * @body: BlockStatement
     */

    function CatchClause(param, body) {
      this.param = param;
      this.body = body;
      CatchClause.__super__.constructor.call(this);
    }

    return CatchClause;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.CatchClause = function(node) {
    node = this.JavaScriptNode(node);
    node.param = this.visit(node.param);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * An identifier. Note that an identifier may be an expression or a destructuring
   * pattern.
   */

  exports.Identifier = Identifier = (function(_super) {
    __extends(Identifier, _super);


    /*
     * @name: string
     */

    function Identifier(name) {
      this.name = name;
      Identifier.__super__.constructor.call(this);
    }

    return Identifier;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Identifier = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A literal token. Note that a literal can be an expression.
   */

  exports.Literal = Literal = (function(_super) {
    __extends(Literal, _super);


    /*
     * @value: string | boolean | null | number | RegExp
     */

    function Literal(value) {
      this.value = value;
      Literal.__super__.constructor.call(this);
    }

    return Literal;

  })(Expression);

  JavaScriptVisitor.prototype.Literal = function(node) {
    node = this.Expression(node);
    return node;
  };

}).call(this);

},{"./Node":19}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var JS, JavaScriptToQueryVisitor, Q, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('./Utilities');

  JS = require('./JavaScriptNodes');

  Q = require('./QueryNodes');


  /*
   * Walk the JavaScriptExpression tree and convert its nodes into QueryExpression
   * trees
   */

  exports.JavaScriptToQueryVisitor = JavaScriptToQueryVisitor = (function(_super) {
    __extends(JavaScriptToQueryVisitor, _super);

    function JavaScriptToQueryVisitor(context) {
      this.context = context;
    }


    /* Get the source code for a given node */

    JavaScriptToQueryVisitor.prototype.getSource = function(node) {
      var _ref, _ref1;
      return this.context.source.slice(node != null ? (_ref = node.range) != null ? _ref[0] : void 0 : void 0, +((node != null ? (_ref1 = node.range) != null ? _ref1[1] : void 0 : void 0) - 1) + 1 || 9e9);
    };


    /* Throw an exception for an invalid node. */

    JavaScriptToQueryVisitor.prototype.invalid = function(node) {
      throw "The expression '" + (this.getSource(node)) + "'' is not supported.";
    };


    /* Unary expressions just map operators */

    JavaScriptToQueryVisitor.prototype.translateUnary = function(node, mapping) {
      var op, value;
      op = mapping[node.operator];
      if (op) {
        value = this.visit(node.argument);
        return new Q.UnaryExpression(op, value);
      } else {
        return null;
      }
    };


    /* Binary expressions just map operators */

    JavaScriptToQueryVisitor.prototype.translateBinary = function(node, mapping) {
      var left, op, right;
      op = mapping[node.operator];
      if (op) {
        left = this.visit(node.left);
        right = this.visit(node.right);
        return new Q.BinaryExpression(op, left, right);
      } else {
        return null;
      }
    };


    /*
     * The base visit method will throw exceptions for any nodes that remain
     * untransformed (which allows us to only bother defining meaningful
     * translations)
     */

    JavaScriptToQueryVisitor.prototype.visit = function(node) {
      var visited;
      visited = JavaScriptToQueryVisitor.__super__.visit.call(this, node);
      if (node === visited) {
        this.invalid(node);
      }
      return visited;
    };

    JavaScriptToQueryVisitor.prototype.MemberExpression = function(node) {
      var expr;
      expr = (function() {
        var _ref, _ref1, _ref2, _ref3;
        if ((node != null ? (_ref = node.object) != null ? _ref.type : void 0 : void 0) === 'ThisExpression' && (node != null ? (_ref1 = node.property) != null ? _ref1.type : void 0 : void 0) === 'Identifier') {

          /* Simple member access */
          return new Q.MemberExpression(node.property.name);
        } else if ((node != null ? (_ref2 = node.object) != null ? _ref2.type : void 0 : void 0) === 'MemberExpression' && ((_ref3 = node.object.object) != null ? _ref3.type : void 0) === 'ThisExpression' && node.property.type === 'Identifier') {

          /* Methods that look like properties */
          if (node.property.name === 'length') {
            return new Q.InvocationExpression(Q.Methods.Length, new Q.MemberExpression(node.object.property.name));
          }
        }
      })();
      return expr != null ? expr : JavaScriptToQueryVisitor.__super__.MemberExpression.call(this, node);
    };

    JavaScriptToQueryVisitor.prototype.Literal = function(node) {
      return new Q.ConstantExpression(node.value);
    };

    JavaScriptToQueryVisitor.prototype.UnaryExpression = function(node) {
      var mapping, _ref;
      if (node.operator === '+') {

        /* Ignore the + in '+52' */
        return this.visit(node.argument);
      } else {
        mapping = {
          '!': Q.UnaryOperators.Not,
          '-': Q.UnaryOperators.Negate
        };
        return (_ref = this.translateUnary(node, mapping)) != null ? _ref : JavaScriptToQueryVisitor.__super__.UnaryExpression.call(this, node);
      }
    };

    JavaScriptToQueryVisitor.prototype.UpdateExpression = function(node) {
      var mapping, _ref;
      mapping = {
        '++': Q.UnaryOperators.Increment,
        '--': Q.UnaryOperators.Decrement
      };
      return (_ref = this.translateUnary(node, mapping)) != null ? _ref : JavaScriptToQueryVisitor.__super__.UpdateExpression.call(this, node);
    };

    JavaScriptToQueryVisitor.prototype.LogicalExpression = function(node) {
      var mapping, _ref;
      mapping = {
        '&&': Q.BinaryOperators.And,
        '||': Q.BinaryOperators.Or
      };
      return (_ref = this.translateBinary(node, mapping)) != null ? _ref : JavaScriptToQueryVisitor.__super__.LogicalExpression.call(this, node);
    };

    JavaScriptToQueryVisitor.prototype.BinaryExpression = function(node) {
      var k, left, mapping, properties, v, value, _ref;
      mapping = {
        '+': Q.BinaryOperators.Add,
        '-': Q.BinaryOperators.Subtract,
        '*': Q.BinaryOperators.Multiply,
        '/': Q.BinaryOperators.Divide,
        '%': Q.BinaryOperators.Modulo,
        '>': Q.BinaryOperators.GreaterThan,
        '>=': Q.BinaryOperators.GreaterThanOrEqual,
        '<': Q.BinaryOperators.LessThan,
        '<=': Q.BinaryOperators.LessThanOrEqual,
        '!=': Q.BinaryOperators.NotEqual,
        '!==': Q.BinaryOperators.NotEqual,
        '==': Q.BinaryOperators.Equal,
        '===': Q.BinaryOperators.Equal
      };
      return (function() {
        var _ref1, _ref2;
        if ((_ref = this.translateBinary(node, mapping)) != null) {
          return _ref;
        } else if (node.operator === 'in' && ((_ref1 = node.right) != null ? _ref1.type : void 0) === 'Literal' && _.isArray((_ref2 = node.right) != null ? _ref2.value : void 0)) {

          /*
           * Transform the 'varName in [x, y, z]' operator into a series of
           * comparisons like varName == x || varName == y || varName == z.
           */
          if (node.right.value.length > 0) {
            left = this.visit(node.left);
            return Q.QueryExpression.groupClauses(Q.BinaryOperators.Or, (function() {
              var _i, _len, _ref3, _results;
              _ref3 = node.right.value;
              _results = [];
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                value = _ref3[_i];

                /*
                 * If we've got an array of objects who each have
                 * a single property, we'll use the value of that
                 * property.  Otherwise we'll throw an exception.
                 */
                if (_.isObject(value)) {
                  properties = (function() {
                    var _results1;
                    _results1 = [];
                    for (k in value) {
                      v = value[k];
                      _results1.push(v);
                    }
                    return _results1;
                  })();
                  if ((properties != null ? properties.length : void 0) !== 1) {
                    throw "in operator requires comparison objects with a single field, not " + value + " (" + (JSON.stringify(value)) + "), for expression '" + (this.getSource(node)) + "'";
                  }
                  value = properties[0];
                }
                _results.push(new Q.BinaryExpression(Q.BinaryOperators.Equal, left, new Q.ConstantExpression(value)));
              }
              return _results;
            }).call(this));
          } else {

            /*
             * If the array of values is empty, change the query to
             * true == false since it can't be satisfied.
             */
            return new Q.BinaryExpression(Q.BinaryOperators.Equal, new Q.ConstantExpression(true), new Q.ConstantExpression(false));
          }
        } else {
          return JavaScriptToQueryVisitor.__super__.BinaryExpression.call(this, node);
        }
      }).call(this);
    };

    JavaScriptToQueryVisitor.prototype.CallExpression = function(node) {
      var expr, func, getSingleArg, getTwoArgs, member, method, _ref;
      getSingleArg = (function(_this) {
        return function(name) {
          var _ref;
          if (((_ref = node["arguments"]) != null ? _ref.length : void 0) !== 1) {
            throw "Function " + name + " expects one argument in expression '" + (_this.getSource(node)) + "'";
          }
          return _this.visit(node["arguments"][0]);
        };
      })(this);
      getTwoArgs = (function(_this) {
        return function(member, name) {
          var _ref;
          if (((_ref = node["arguments"]) != null ? _ref.length : void 0) !== 2) {
            throw "Function " + name + " expects two arguments in expression '" + (_this.getSource(node)) + "'";
          }
          return [member, _this.visit(node["arguments"][0]), _this.visit(node["arguments"][1])];
        };
      })(this);

      /*
       * Translate known method calls that aren't attached to an instance.
       * Note that we can compare against the actual method because the
       * partial evaluator will have converted it into a literal for us.
       */
      func = node != null ? (_ref = node.callee) != null ? _ref.value : void 0 : void 0;
      expr = (function() {
        var _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
        if (func === Math.floor) {
          return new Q.InvocationExpression(Q.Methods.Floor, [getSingleArg('floor')]);
        } else if (func === Math.ceil) {
          return new Q.InvocationExpression(Q.Methods.Ceiling, [getSingleArg('ceil')]);
        } else if (func === Math.round) {
          return new Q.InvocationExpression(Q.Methods.Round, [getSingleArg('round')]);
        } else {

          /*
           * Translate methods dangling off an instance
           */
          if (node.callee.type === 'MemberExpression' && ((_ref1 = node.callee.object) != null ? _ref1.__hasThisExp : void 0) === true) {
            if ((node != null ? (_ref2 = node.callee) != null ? (_ref3 = _ref2.object) != null ? _ref3.type : void 0 : void 0 : void 0) === 'CallExpression') {
              member = this.visit(node.callee.object);
            } else {
              member = new Q.MemberExpression((_ref4 = node.callee.object) != null ? (_ref5 = _ref4.property) != null ? _ref5.name : void 0 : void 0);
            }
            method = (_ref6 = node.callee) != null ? (_ref7 = _ref6.property) != null ? _ref7.name : void 0 : void 0;
            if (method === 'toUpperCase') {
              return new Q.InvocationExpression(Q.Methods.ToUpperCase, [member]);
            } else if (method === 'toLowerCase') {
              return new Q.InvocationExpression(Q.Methods.ToLowerCase, [member]);
            } else if (method === 'trim') {
              return new Q.InvocationExpression(Q.Methods.Trim, [member]);
            } else if (method === 'indexOf') {
              return new Q.InvocationExpression(Q.Methods.IndexOf, [member, getSingleArg('indexOf')]);
            } else if (method === 'concat') {
              return new Q.InvocationExpression(Q.Methods.Concat, [member, getSingleArg('concat')]);
            } else if (method === 'substring' || method === 'substr') {
              return new Q.InvocationExpression(Q.Methods.Substring, getTwoArgs(member, 'substring'));
            } else if (method === 'replace') {
              return new Q.InvocationExpression(Q.Methods.Replace, getTwoArgs(member, 'replace'));
            } else if (method === 'getFullYear' || method === 'getUTCFullYear') {
              return new Q.InvocationExpression(Q.Methods.Year, [member]);
            } else if (method === 'getYear') {
              return new Q.BinaryExpression(Q.BinaryOperators.Subtract, new Q.InvocationExpression(Q.Methods.Year, [member]), new Q.ConstantExpression(1900));
            } else if (method === 'getMonth' || method === 'getUTCMonth') {

              /* getMonth is 0 indexed in JavaScript */
              return new Q.BinaryExpression(Q.BinaryOperators.Subtract, new Q.InvocationExpression(Q.Methods.Month, [member]), new Q.ConstantExpression(1));
            } else if (method === 'getDate' || method === 'getUTCDate') {
              return new Q.InvocationExpression(Q.Methods.Day, [member]);
            }
          }
        }
      }).call(this);
      return expr != null ? expr : JavaScriptToQueryVisitor.__super__.CallExpression.call(this, node);
    };

    return JavaScriptToQueryVisitor;

  })(JS.JavaScriptVisitor);

}).call(this);

},{"./JavaScriptNodes":17,"./QueryNodes":23,"./Utilities":24}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var Node, Visitor, _;

  _ = require('./Utilities');


  /*
   * The base Node class for all expressions used for analysis and translation by
   * visitors.  It's designed to interop with other modules that create expression
   * trees using object literals with a type tag.
   */

  exports.Node = Node = (function() {

    /*
     * Type tag of the node that allows for eash dispatch in visitors.  This is
     * automatically set in the constructor (so it's important to call super() in
     * derived Node classes).
     */
    Node.prototype.type = 'Node';


    /*
     * Initializes a new instance of the Node class and sets its type tag.
     */

    function Node() {
      this.type = _.functionName(this.constructor);
    }

    return Node;

  })();


  /*
   * Base class for all visitors
   */

  exports.Visitor = Visitor = (function() {
    function Visitor() {}


    /*
     * Visit a node.
     */

    Visitor.prototype.visit = function(node) {
      var element, _i, _len, _results;
      if (_.isArray(node)) {
        _results = [];
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          element = node[_i];
          _results.push(this.visit(element));
        }
        return _results;
      } else if (!(node != null ? node.type : void 0)) {
        return node;
      } else if (!_.isFunction(this[node.type])) {
        throw "Unsupported expression " + (this.getSource(node));
      } else {
        return this[node.type](node);
      }
    };


    /*
     * Get the source code corresponding to a node.
     */

    Visitor.prototype.getSource = function(node) {

      /* It is expected this will be overridden in derived visitors. */
      return null;
    };

    return Visitor;

  })();

}).call(this);

},{"./Utilities":24}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var ODataFilterQueryVisitor, ODataProvider, Q, Query, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('./Utilities');

  Q = require('./QueryNodes');

  Query = require('./Query').Query;

  exports.ODataProvider = ODataProvider = (function() {
    function ODataProvider() {}


    /*
     * Convert a query into an OData URI.
     */

    ODataProvider.prototype.toQuery = function(query) {
      var odata, s, url;
      odata = this.toOData(query, true);
      url = "/" + odata.table;
      s = '?';
      if (odata.filters) {
        url += "" + s + "$filter=" + odata.filters;
        s = '&';
      }
      if (odata.orderClauses) {
        url += "" + s + "$orderby=" + odata.orderClauses;
        s = '&';
      }
      if (odata.skip) {
        url += "" + s + "$skip=" + odata.skip;
        s = '&';
      }
      if (odata.take || odata.take === 0) {
        url += "" + s + "$top=" + odata.take;
        s = '&';
      }
      if (odata.selections) {
        url += "" + s + "$select=" + odata.selections;
        s = '&';
      }
      if (odata.includeTotalCount) {
        url += "" + s + "$inlinecount=allpages";
      }
      return url;
    };


    /*
     * Translate the query components into OData strings
     */

    ODataProvider.prototype.toOData = function(query, encodeForUri) {
      var asc, components, name, odata, order, orderClauses, ordering, _ref, _ref1;
      if (encodeForUri == null) {
        encodeForUri = false;
      }
      components = (_ref = query != null ? query.getComponents() : void 0) != null ? _ref : {};
      ordering = (function() {
        var _ref1, _results;
        _ref1 = components != null ? components.ordering : void 0;
        _results = [];
        for (name in _ref1) {
          asc = _ref1[name];
          _results.push(asc ? name : "" + name + " desc");
        }
        return _results;
      })();
      orderClauses = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = components != null ? components.orderClauses : void 0;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          order = _ref1[_i];
          _results.push(order.ascending ? order.name : "" + order.name + " desc");
        }
        return _results;
      })();
      return odata = {
        table: components != null ? components.table : void 0,
        filters: ODataFilterQueryVisitor.convert(components.filters, encodeForUri),
        ordering: ordering != null ? ordering.toString() : void 0,
        orderClauses: orderClauses != null ? orderClauses.toString() : void 0,
        skip: components != null ? components.skip : void 0,
        take: components != null ? components.take : void 0,
        selections: components != null ? (_ref1 = components.selections) != null ? _ref1.toString() : void 0 : void 0,
        includeTotalCount: components != null ? components.includeTotalCount : void 0
      };
    };


    /*
     * Convert OData components into a query object
     */

    ODataProvider.prototype.fromOData = function(table, filters, ordering, skip, take, selections, includeTotalCount) {
      var direction, field, item, query, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      query = new Query(table);
      if (filters) {
        query.where(filters);
      }
      if (skip || skip === 0) {
        query.skip(skip);
      }
      if (take || take === 0) {
        query.take(take);
      }
      if (includeTotalCount) {
        query.includeTotalCount();
      }
      _ref1 = (_ref = selections != null ? selections.split(',') : void 0) != null ? _ref : [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        field = _ref1[_i];
        query.select(field.trim());
      }
      _ref2 = (function() {
        var _k, _len1, _ref2, _ref3, _results;
        _ref3 = (_ref2 = ordering != null ? ordering.split(',') : void 0) != null ? _ref2 : [];
        _results = [];
        for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
          item = _ref3[_k];
          _results.push(item.trim().split(' '));
        }
        return _results;
      })();
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        _ref3 = _ref2[_j], field = _ref3[0], direction = _ref3[1];
        if ((direction != null ? direction.toUpperCase() : void 0) !== 'DESC') {
          query.orderBy(field);
        } else {
          query.orderByDescending(field);
        }
      }
      return query;
    };

    return ODataProvider;

  })();


  /*
   * Visitor that converts query expression trees into OData filter statements.
   */

  ODataFilterQueryVisitor = (function(_super) {
    __extends(ODataFilterQueryVisitor, _super);

    function ODataFilterQueryVisitor(encodeForUri) {
      this.encodeForUri = encodeForUri;
    }

    ODataFilterQueryVisitor.convert = function(filters, encodeForUri) {
      var visitor, _ref;
      visitor = new ODataFilterQueryVisitor(encodeForUri);
      return (_ref = (filters ? visitor.visit(filters) : void 0)) != null ? _ref : null;
    };

    ODataFilterQueryVisitor.prototype.toOData = function(value) {
      var text;
      if ((_.isNumber(value)) || (_.isBoolean(value))) {
        return value.toString();
      } else if (_.isString(value)) {
        value = value.replace(/'/g, "''");
        if ((this.encodeForUri != null) && this.encodeForUri === true) {
          value = encodeURIComponent(value);
        }
        return "'" + value + "'";
      } else if (_.isDate(value)) {

        /*
         * Dates are expected in the format
         *   "datetime'yyyy-mm-ddThh:mm[:ss[.fffffff]]'"
         * which JSON.stringify gives us by default
         */
        text = JSON.stringify(value);
        if (text.length > 2) {
          text = text.slice(1, +(text.length - 2) + 1 || 9e9);
        }
        text = text.replace(/(T\d{2}:\d{2}:\d{2})Z$/, function(all, time) {
          var msec;
          msec = String(value.getMilliseconds() + 1000).substring(1);
          return "" + time + "." + msec + "Z";
        });
        return "datetime'" + text + "'";
      } else if (!value) {
        return "null";
      } else {
        throw "Unsupported literal value " + value;
      }
    };

    ODataFilterQueryVisitor.prototype.ConstantExpression = function(node) {
      return this.toOData(node.value);
    };

    ODataFilterQueryVisitor.prototype.MemberExpression = function(node) {
      return node.member;
    };

    ODataFilterQueryVisitor.prototype.UnaryExpression = function(node) {
      if (node.operator === Q.UnaryOperators.Not) {
        return "not " + (this.visit(node.operand));
      } else if (node.operator === Q.UnaryOperators.Negate) {
        return "(0 sub " + (this.visit(node.operand)) + ")";
      } else {
        throw "Unsupported operator " + node.operator;
      }
    };

    ODataFilterQueryVisitor.prototype.BinaryExpression = function(node) {
      var mapping, op;
      mapping = {
        And: 'and',
        Or: 'or',
        Add: 'add',
        Subtract: 'sub',
        Multiply: 'mul',
        Divide: 'div',
        Modulo: 'mod',
        GreaterThan: 'gt',
        GreaterThanOrEqual: 'ge',
        LessThan: 'lt',
        LessThanOrEqual: 'le',
        NotEqual: 'ne',
        Equal: 'eq'
      };
      op = mapping[node.operator];
      if (op) {
        return "(" + (this.visit(node.left)) + " " + op + " " + (this.visit(node.right)) + ")";
      } else {
        throw "Unsupported operator " + node.operator;
      }
    };

    ODataFilterQueryVisitor.prototype.InvocationExpression = function(node) {
      var mapping, method;
      mapping = {
        Length: 'length',
        ToUpperCase: 'toupper',
        ToLowerCase: 'tolower',
        Trim: 'trim',
        IndexOf: 'indexof',
        Replace: 'replace',
        Substring: 'substring',
        Concat: 'concat',
        Day: 'day',
        Month: 'month',
        Year: 'year',
        Floor: 'floor',
        Ceiling: 'ceiling',
        Round: 'round'
      };
      method = mapping[node.method];
      if (method) {
        return "" + method + "(" + (this.visit(node.args)) + ")";
      } else {
        throw "Invocation of unsupported method " + node.method;
      }
    };

    ODataFilterQueryVisitor.prototype.LiteralExpression = function(node) {
      var ch, inString, literal, parenBalance, _i, _len, _ref;
      literal = '';
      parenBalance = 0;
      inString = false;
      _ref = node.queryString;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ch = _ref[_i];
        if (parenBalance < 0) {
          break;
        } else if (inString) {
          literal += ch;
          inString = ch !== "'";
        } else if (ch === '?') {
          if ((!node.args) || (node.args.length <= 0)) {
            throw "Too few arguments for " + node.queryString + ".";
          }
          literal += this.toOData(node.args.shift());
        } else if (ch === "'") {
          literal += ch;
          inString = true;
        } else if (ch === '(') {
          parenBalance += 1;
          literal += ch;
        } else if (ch === ')') {
          parenBalance -= 1;
          literal += ch;
        } else {
          literal += ch;
        }
      }
      if (node.args && node.args.length > 0) {
        throw "Too many arguments for " + node.queryString;
      }
      if (parenBalance !== 0) {
        throw "Unbalanced parentheses in " + node.queryString;
      }
      if (literal.trim().length > 0) {
        return "(" + literal + ")";
      } else {
        return literal;
      }
    };

    return ODataFilterQueryVisitor;

  })(Q.QueryExpressionVisitor);

}).call(this);

},{"./Query":22,"./QueryNodes":23,"./Utilities":24}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var IndependenceNominator, JS, PartialEvaluator, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('./Utilities');

  JS = require('./JavaScriptNodes');


  /*
   * Partially evaluate a complex expression in the context of its environment.
   * This allows us to support arbitrary JavaScript expressions even though we
   * only explicitly transform a subset of expressions into QueryExpressions.
   *
   * For example, assuming we have an expression like (x) -> @id == x + 1 with an
   * environment where x == 12, then the entire right hand side of the comparison
   * is independent of any values computed by the query and could be replaced with
   * the literal value 13.
   */

  exports.PartialEvaluator = PartialEvaluator = (function(_super) {
    __extends(PartialEvaluator, _super);

    function PartialEvaluator(context) {
      this.context = context;
    }

    PartialEvaluator.prototype.visit = function(node) {
      var key, params, source, thunk, value, values, _ref, _ref1, _ref2, _ref3;
      if (!node.__independent || node.type === 'Literal' || (!node.type)) {

        /*
         * If the node isn't independent or it's already a literal, then
         * just keep walking the tree
         */
        return PartialEvaluator.__super__.visit.call(this, node);
      } else {

        /*
         * Otherwse we'll evaluate the node in the context of the
         * environment by either looking up identifiers directly or
         * evaluating whole sub expressions
         */
        if (node.type === 'Identifier' && this.context.environment[node.name]) {
          return new JS.Literal(this.context.environment[node.name]);
        } else {

          /*
           * Evaluate the source of the sub expression in the context
           * of the environment
           */
          source = this.context.source.slice(node != null ? (_ref = node.range) != null ? _ref[0] : void 0 : void 0, +((node != null ? (_ref1 = node.range) != null ? _ref1[1] : void 0 : void 0) - 1) + 1 || 9e9);
          params = (_ref2 = (function() {
            var _ref3, _results;
            _ref3 = this.context.environment;
            _results = [];
            for (key in _ref3) {
              value = _ref3[key];
              _results.push(key);
            }
            return _results;
          }).call(this)) != null ? _ref2 : [];
          values = (_ref3 = (function() {
            var _ref4, _results;
            _ref4 = this.context.environment;
            _results = [];
            for (key in _ref4) {
              value = _ref4[key];
              _results.push(JSON.stringify(value));
            }
            return _results;
          }).call(this)) != null ? _ref3 : [];
          thunk = "(function(" + params + ") { return " + source + "; })(" + values + ")";
          value = eval(thunk);
          return new JS.Literal(value);
        }
      }
    };

    PartialEvaluator.evaluate = function(context) {
      var evaluator, nominator;
      nominator = new IndependenceNominator(context);
      nominator.visit(context.expression);
      evaluator = new PartialEvaluator(context);
      return evaluator.visit(context.expression);
    };

    return PartialEvaluator;

  })(JS.JavaScriptVisitor);


  /*
   * Nominate independent nodes in an expression tree that don't depend on any
   * server side values.
   */

  exports.IndependenceNominator = IndependenceNominator = (function(_super) {
    __extends(IndependenceNominator, _super);

    function IndependenceNominator(context) {
      this.context = context;
    }

    IndependenceNominator.prototype.Literal = function(node) {
      IndependenceNominator.__super__.Literal.call(this, node);
      node.__independent = true;
      node.__hasThisExp = false;
      return node;
    };

    IndependenceNominator.prototype.ThisExpression = function(node) {
      IndependenceNominator.__super__.ThisExpression.call(this, node);
      node.__independent = false;
      node.__hasThisExp = true;
      return node;
    };

    IndependenceNominator.prototype.Identifier = function(node) {
      IndependenceNominator.__super__.Identifier.call(this, node);
      node.__independent = true;
      node.__hasThisExp = false;
      return node;
    };

    IndependenceNominator.prototype.MemberExpression = function(node) {
      var _ref;
      IndependenceNominator.__super__.MemberExpression.call(this, node);

      /*
       * Undo independence of identifiers when they're members of this.* or
       * this.member.* (the latter allows for member functions)
       */
      node.__hasThisExp = (_ref = node.object) != null ? _ref.__hasThisExp : void 0;
      if (node.__hasThisExp) {
        node.__independent = false;
        if (node != null) {
          node.property.__independent = false;
        }
      }
      return node;
    };

    IndependenceNominator.prototype.CallExpression = function(node) {
      IndependenceNominator.__super__.CallExpression.call(this, node);
      node.__hasThisExp = node.callee.__hasThisExp;
      return node;
    };

    IndependenceNominator.prototype.ObjectExpression = function(node) {
      var independence, setter, _i, _j, _len, _len1, _ref, _ref1;
      IndependenceNominator.__super__.ObjectExpression.call(this, node);

      /*
       * Prevent literal key identifiers from being evaluated out of
       * context
       */
      _ref = node.properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.key.__independent = false;
      }

      /*
       * An object literal is independent if all of its values are
       * independent
       */
      independence = true;
      _ref1 = node.properties;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        setter = _ref1[_j];
        independence &= setter.value.__independent;
      }
      node.__independent = independence ? true : false;
      return node;
    };

    IndependenceNominator.prototype.visit = function(node) {

      /*
       * Call the base visit method which will both visit all of our
       * subexpressions and also call the couple of overrides above which
       * handle the base independence cases
       */
      var independence, isIndependent, name, v, value, _i, _len;
      IndependenceNominator.__super__.visit.call(this, node);

      /*
       * If the node's independence wasn't determined automatically by the
       * base cases above, then it's independence is determined by checking
       * all of its values and aggregating their independence
       */
      if (!(Object.prototype.hasOwnProperty.call(node, '__independent'))) {
        independence = true;
        isIndependent = function(node) {
          var _ref;
          if (_.isObject(node)) {
            return (_ref = value.__independent) != null ? _ref : false;
          } else {
            return true;
          }
        };
        for (name in node) {
          value = node[name];
          if (_.isArray(value)) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              v = value[_i];
              independence &= isIndependent(v);
            }
          } else if (_.isObject(value)) {
            independence &= isIndependent(value);
          }
        }

        /* &= will turn true/false into 1/0 so we'll turn it back */
        node.__independent = independence ? true : false;
      }
      return node;
    };

    return IndependenceNominator;

  })(JS.JavaScriptVisitor);

}).call(this);

},{"./JavaScriptNodes":17,"./Utilities":24}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/* Pull in references */

(function() {
  var JavaScript, ODataProvider, Q, Query, _,
    __slice = [].slice;

  _ = require('./Utilities');

  Q = require('./QueryNodes');

  JavaScript = require('./JavaScript').JavaScript;


  /*
   * Define a query that can be translated into a desired query language and
   * executed remotely.
   */

  exports.Query = Query = (function() {
    function Query(table, context) {
      var _context, _filters, _includeTotalCount, _orderClauses, _ordering, _projection, _selections, _skip, _table, _take, _version;
      if (!table || !(_.isString(table))) {
        throw 'Expected the name of a table!';
      }

      /* Store the table name and any extra context */
      _table = table;
      _context = context;

      /* Private Query component members */
      _filters = null;
      _projection = null;
      _selections = [];
      _ordering = {};
      _orderClauses = [];
      _skip = null;
      _take = null;
      _includeTotalCount = false;

      /*
       * Keep a version flag that's updated on each mutation so we can
       * track whether changes have been made.  This is to enable caching
       * of compiled queries without reevaluating unless necessary.
       */
      _version = 0;

      /* Get the individual components of the query */
      this.getComponents = function() {
        return {
          filters: _filters,
          selections: _selections,
          projection: _projection,
          ordering: _ordering,
          orderClauses: _orderClauses,
          skip: _skip,
          take: _take,
          table: _table,
          context: _context,
          includeTotalCount: _includeTotalCount,
          version: _version
        };
      };

      /*
       * Set the individual components of the query (this is primarily
       * meant to be used for rehydrating a query).
       */
      this.setComponents = function(components) {
        var ascending, name, property, _i, _len, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        _version++;
        _filters = (_ref = components != null ? components.filters : void 0) != null ? _ref : null;
        _selections = (_ref1 = components != null ? components.selections : void 0) != null ? _ref1 : [];
        _projection = (_ref2 = components != null ? components.projection : void 0) != null ? _ref2 : null;
        _skip = (_ref3 = components != null ? components.skip : void 0) != null ? _ref3 : null;
        _take = (_ref4 = components != null ? components.take : void 0) != null ? _ref4 : null;
        _includeTotalCount = (_ref5 = components != null ? components.includeTotalCount : void 0) != null ? _ref5 : false;
        _table = (_ref6 = components != null ? components.table : void 0) != null ? _ref6 : null;
        _context = (_ref7 = components != null ? components.context : void 0) != null ? _ref7 : null;
        if (components != null ? components.orderClauses : void 0) {
          _orderClauses = (_ref8 = components != null ? components.orderClauses : void 0) != null ? _ref8 : [];
          _ordering = {};
          for (_i = 0, _len = _orderClauses.length; _i < _len; _i++) {
            _ref9 = _orderClauses[_i], name = _ref9.name, ascending = _ref9.ascending;
            _ordering[name] = ascending;
          }
        } else {
          _ordering = (_ref10 = components != null ? components.ordering : void 0) != null ? _ref10 : {};
          _orderClauses = [];
          for (property in _ordering) {
            _orderClauses.push({
              name: property,
              ascending: !!_ordering[property]
            });
          }
        }
        return this;
      };

      /*
       * Add a constraint to a query.  Constraints can take the form of
       * a function with a single return statement, key/value pairs of
       * equality comparisons, or provider-specific literal strings (note
       * that not all providers support literals).
       */
      this.where = function() {
        var args, constraint, expr, name, value;
        constraint = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        _version++;

        /*
         * Translate the constraint from its high level form into a
         * QueryExpression tree that can be manipulated by a query
         * provider
         */
        expr = (function() {
          if (_.isFunction(constraint)) {
            return JavaScript.transformConstraint(constraint, args);
          } else if (_.isObject(constraint)) {

            /*
             * Turn an object of key value pairs into a series of
             * equality expressions that are and'ed together to form
             * a single expression
             */
            return Q.QueryExpression.groupClauses(Q.BinaryOperators.And, (function() {
              var _results;
              _results = [];
              for (name in constraint) {
                value = constraint[name];
                _results.push(expr = new Q.BinaryExpression(Q.BinaryOperators.Equal, new Q.MemberExpression(name), new Q.ConstantExpression(value)));
              }
              return _results;
            })());
          } else if (_.isString(constraint)) {

            /*
             * Store the literal query along with any arguments for
             * providers that support basic string replacement (i.e.,
             * something like where('name eq ?', 'Steve'))
             */
            return new Q.LiteralExpression(constraint, args);
          } else {
            throw "Expected a function, object, or string, not " + constraint;
          }
        })();

        /* Merge the new filters with any existing filters */
        _filters = Q.QueryExpression.groupClauses(Q.BinaryOperators.And, [_filters, expr]);
        return this;
      };

      /*
       * Project the query results.  A projection can either be defined as
       * a set of fields that we'll pull back (instead of the entire row)
       * or a function that will transform a row into a new type.  If a
       * function is used, we'll analyze the function to pull back the
       * minimal number of fields required.
       */
      this.select = function() {
        var param, parameters, projectionOrParameter, _i, _len;
        projectionOrParameter = arguments[0], parameters = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        _version++;
        if (_.isString(projectionOrParameter)) {

          /* Add all the literal string parameters */
          _selections.push(projectionOrParameter);
          for (_i = 0, _len = parameters.length; _i < _len; _i++) {
            param = parameters[_i];
            if (!(_.isString(param))) {
              throw "Expected string parameters, not " + param;
            }
            _selections.push(param);
          }
        } else if (_.isFunction(projectionOrParameter)) {

          /* Set the projection and calculate the fields it uses */
          _projection = projectionOrParameter;
          _selections = JavaScript.getProjectedFields(_projection);
        } else {
          throw "Expected a string or a function, not " + projectionOrParameter;
        }
        return this;
      };
      this.orderBy = function() {
        var order, param, parameters, replacement, _i, _j, _len, _len1;
        parameters = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _version++;
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          param = parameters[_i];
          if (!(_.isString(param))) {
            throw "Expected string parameters, not " + param;
          }
          _ordering[param] = true;
          replacement = false;
          for (_j = 0, _len1 = _orderClauses.length; _j < _len1; _j++) {
            order = _orderClauses[_j];
            if (order.name === param) {
              replacement = true;
              order.ascending = true;
            }
          }
          if (!replacement) {
            _orderClauses.push({
              name: param,
              ascending: true
            });
          }
        }
        return this;
      };
      this.orderByDescending = function() {
        var order, param, parameters, replacement, _i, _j, _len, _len1;
        parameters = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _version++;
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          param = parameters[_i];
          if (!(_.isString(param))) {
            throw "Expected string parameters, not " + param;
          }
          _ordering[param] = false;
          replacement = false;
          for (_j = 0, _len1 = _orderClauses.length; _j < _len1; _j++) {
            order = _orderClauses[_j];
            if (order.name === param) {
              replacement = true;
              order.ascending = false;
            }
          }
          if (!replacement) {
            _orderClauses.push({
              name: param,
              ascending: false
            });
          }
        }
        return this;
      };
      this.skip = function(count) {
        _version++;
        if (!(_.isNumber(count))) {
          throw "Expected a number, not " + count;
        }
        _skip = count;
        return this;
      };
      this.take = function(count) {
        _version++;
        if (!(_.isNumber(count))) {
          throw "Expected a number, not " + count;
        }
        _take = count;
        return this;
      };

      /*
       * Indicate that the query should include the total count for all the
       * records that would have been returned ignoring any take paging
       * limit clause specified by client or server.
       */
      this.includeTotalCount = function() {
        _version++;
        _includeTotalCount = true;
        return this;
      };
    }


    /*
     * Static method to register custom provider types.  A custom provider is
     * an object with a toQuery method that takes a Query instance and
     * returns a compiled query for that provider.
     */

    Query.registerProvider = function(name, provider) {
      Query.Providers[name] = provider;
      return Query.prototype["to" + name] = function() {
        return provider != null ? typeof provider.toQuery === "function" ? provider.toQuery(this) : void 0 : void 0;
      };
    };


    /*
     * Expose the registered providers via the Query.Providers namespace.
     */

    Query.Providers = {};


    /*
     * Expose the query expressions and visitors externally via a
     * Query.Expressions namespace.
     */

    Query.Expressions = Q;

    return Query;

  })();


  /* Register the built in OData provider */

  ODataProvider = require('./ODataProvider').ODataProvider;

  Query.registerProvider('OData', new ODataProvider);

}).call(this);

},{"./JavaScript":16,"./ODataProvider":20,"./QueryNodes":23,"./Utilities":24}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/*
 * Define a low level intermediate query expression language that we can
 * translate other expressions languages (like JavaScript) into.
 */


/* Get the base Node class. */

(function() {
  var BinaryExpression, ConstantExpression, InvocationExpression, LiteralExpression, MemberExpression, Node, QueryExpression, QueryExpressionVisitor, UnaryExpression, Visitor, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./Node'), Node = _ref.Node, Visitor = _ref.Visitor;


  /*
   * Provides the base class from which the classes that represent expression tree
   * nodes are derived.
   */

  exports.QueryExpression = QueryExpression = (function(_super) {
    __extends(QueryExpression, _super);

    function QueryExpression() {
      QueryExpression.__super__.constructor.call(this);
    }


    /*
     * Group a sequence of clauses together with a given operator (like And
     * or Or).
     */

    QueryExpression.groupClauses = function(operator, clauses) {
      var combine;
      combine = function(left, right) {
        if (!left) {
          return right;
        } else if (!right) {
          return left;
        } else {
          return new BinaryExpression(operator, left, right);
        }
      };
      return clauses.reduce(combine, null);
    };

    return QueryExpression;

  })(Node);

  exports.QueryExpressionVisitor = QueryExpressionVisitor = (function(_super) {
    __extends(QueryExpressionVisitor, _super);

    function QueryExpressionVisitor() {
      QueryExpressionVisitor.__super__.constructor.call(this);
    }

    QueryExpressionVisitor.prototype.QueryExpression = function(node) {
      return node;
    };

    return QueryExpressionVisitor;

  })(Visitor);


  /*
   * Represents an expression that has a constant value.
   */

  exports.ConstantExpression = ConstantExpression = (function(_super) {
    __extends(ConstantExpression, _super);


    /*
     * @value: The value of the constant expression.
     */

    function ConstantExpression(value) {
      this.value = value;
      ConstantExpression.__super__.constructor.call(this);
    }

    return ConstantExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.ConstantExpression = function(node) {
    return this.QueryExpression(node);
  };


  /*
   * Represents accessing a field.
   */

  exports.MemberExpression = MemberExpression = (function(_super) {
    __extends(MemberExpression, _super);


    /*
     * @member: Gets the field to be accessed.
     */

    function MemberExpression(member) {
      this.member = member;
      MemberExpression.__super__.constructor.call(this);
    }

    return MemberExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.MemberExpression = function(node) {
    return this.QueryExpression(node);
  };


  /*
   * Represents an expression that has a binary operator.
   */

  exports.BinaryExpression = BinaryExpression = (function(_super) {
    __extends(BinaryExpression, _super);


    /*
     * @operator: The operator of the binary expression.
     * @left: The left operand of the binary operation.
     * @right: The right operand of the binary operation.
     */

    function BinaryExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      BinaryExpression.__super__.constructor.call(this);
    }

    return BinaryExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.BinaryExpression = function(node) {
    node = this.QueryExpression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * Represents the known binary operators.
   */

  exports.BinaryOperators = {
    And: 'And',
    Or: 'Or',
    Add: 'Add',
    Subtract: 'Subtract',
    Multiply: 'Multiply',
    Divide: 'Divide',
    Modulo: 'Modulo',
    GreaterThan: 'GreaterThan',
    GreaterThanOrEqual: 'GreaterThanOrEqual',
    LessThan: 'LessThan',
    LessThanOrEqual: 'LessThanOrEqual',
    NotEqual: 'NotEqual',
    Equal: 'Equal'
  };


  /*
   * Represents the known unary operators.
   */

  exports.UnaryExpression = UnaryExpression = (function(_super) {
    __extends(UnaryExpression, _super);


    /*
     * @operator: The operator of the unary expression.
     * @operand: The operand of the unary expression.
     */

    function UnaryExpression(operator, operand) {
      this.operator = operator;
      this.operand = operand;
      UnaryExpression.__super__.constructor.call(this);
    }

    return UnaryExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.UnaryExpression = function(node) {
    node = this.QueryExpression(node);
    node.operand = this.visit(node.operand);
    return node;
  };


  /*
   * Represents the known unary operators.
   */

  exports.UnaryOperators = {
    Not: 'Not',
    Negate: 'Negate',
    Increment: 'Increment',
    Decrement: 'Decrement'
  };


  /*
   * Represents a method invocation.
   */

  exports.InvocationExpression = InvocationExpression = (function(_super) {
    __extends(InvocationExpression, _super);


    /*
     * @method: The name of the method to invoke.
     * @args: The arguments to the method.
     */

    function InvocationExpression(method, args) {
      this.method = method;
      this.args = args;
      InvocationExpression.__super__.constructor.call(this);
    }

    return InvocationExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.InvocationExpression = function(node) {
    node = this.QueryExpression(node);
    node.args = this.visit(node.args);
    return node;
  };


  /*
   * Represents the known unary operators.
   */

  exports.Methods = {
    Length: 'Length',
    ToUpperCase: 'ToUpperCase',
    ToLowerCase: 'ToLowerCase',
    Trim: 'Trim',
    IndexOf: 'IndexOf',
    Replace: 'Replace',
    Substring: 'Substring',
    Concat: 'Concat',
    Day: 'Day',
    Month: 'Month',
    Year: 'Year',
    Floor: 'Floor',
    Ceiling: 'Ceiling',
    Round: 'Round'
  };


  /*
   * Represents a literal string in the query language.
   */

  exports.LiteralExpression = LiteralExpression = (function(_super) {
    __extends(LiteralExpression, _super);


    /*
     * @queryString
     * @args
     */

    function LiteralExpression(queryString, args) {
      this.queryString = queryString;
      this.args = args != null ? args : [];
      LiteralExpression.__super__.constructor.call(this);
    }

    return LiteralExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.LiteralExpression = function(node) {
    return this.QueryExpression(node);
  };

}).call(this);

},{"./Node":19}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var classOf,
    __slice = [].slice;

  classOf = function(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
  };

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function() {
      var accumulator, array, arrayLength, currentIndex, currentValue, moreArgs;
      accumulator = arguments[0], moreArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      array = this;
      arrayLength = array.length;
      currentIndex = 0;
      currentValue = void 0;
      if (array == null) {
        throw new TypeError("Object is null or undefined");
      }
      if (typeof accumulator !== "function") {
        throw new TypeError("First argument is not callable");
      }
      if (moreArgs.length === 0) {
        if (arrayLength === 0) {
          throw new TypeError("Array length is 0 and no second argument");
        } else {
          currentValue = array[0];
          currentIndex = 1;
        }
      } else {
        currentValue = moreArgs[0];
      }
      while (currentIndex < arrayLength) {
        if (currentIndex in array) {
          currentValue = accumulator.call(void 0, currentValue, array[currentIndex], array);
        }
        ++currentIndex;
      }
      return currentValue;
    };
  }

  if (Array.prototype.map == null) {
    Array.prototype.map = function(callback, thisArg) {
      var elem, index, inputArray, len, outputArray, _i, _len;
      if (typeof this === "undefined" || this === null) {
        throw new TypeError("this is null or not defined");
      }
      if (typeof callback !== "function") {
        throw new TypeError(callback + " is not a function");
      }
      thisArg = thisArg ? thisArg : void 0;
      inputArray = Object(this);
      len = inputArray.length >>> 0;
      outputArray = new Array(len);
      for (index = _i = 0, _len = inputArray.length; _i < _len; index = ++_i) {
        elem = inputArray[index];
        if (index in inputArray) {
          outputArray[index] = callback.call(thisArg, elem, index, inputArray);
        }
      }
      return outputArray;
    };
  }

  if (Array.isArray == null) {
    Array.isArray = function(vArg) {
      return Object.prototype.toString.call(vArg) === "[object Array]";
    };
  }

  exports.isObject = function(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() === 'object';
  };

  exports.isString = function(obj) {
    return typeof obj === 'string';
  };

  exports.isFunction = function(obj) {
    return typeof obj === 'function';
  };

  exports.isArray = Array.isArray;

  exports.isNumber = function(obj) {
    return typeof obj === 'number';
  };

  exports.isBoolean = function(obj) {
    return typeof obj === 'boolean';
  };

  exports.isDate = function(obj) {
    return classOf(obj) === 'date';
  };

  exports.functionName = function(fn) {
    var index, prefix, source;
    if (typeof Function.prototype.name === 'function') {
      return Function.prototype.name.call(fn);
    } else {
      source = fn.toString();
      prefix = 'function ';
      if (source.slice(0, +(prefix.length - 1) + 1 || 9e9) === prefix) {
        index = source.indexOf('(', prefix.length);
        if (index > prefix.length) {
          return source.slice(prefix.length, +(index - 1) + 1 || 9e9);
        }
      }
      return null;
    }
  };

}).call(this);

},{}],25:[function(require,module,exports){
/*
  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForOfStatement: 'ForOfStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token',
        DuplicateBinding: 'Duplicate binding %0'
    };

    // See also tools/generate-unicode-regex.js.
    Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // ECMA-262 11.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // ECMA-262 11.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // ECMA-262 11.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        return (cp < 0x10000) ? String.fromCharCode(cp) :
            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
    }

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
    }

    // ECMA-262 11.6.2.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // ECMA-262 11.6.2.1 Keywords

    function isKeyword(id) {

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // ECMA-262 11.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        return fromCodePoint(code);
    }

    function codePointAt(i) {
        var cp, first, second;

        cp = source.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF) {
            second = source.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                first = cp;
                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }

        return cp;
    }

    function getComplexIdentifier() {
        var cp, ch, id;

        cp = codePointAt(index);
        id = fromCodePoint(cp);
        index += id.length;

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (cp === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            if (source[index] === '{') {
                ++index;
                ch = scanUnicodeCodePointEscape();
            } else {
                ch = scanHexEscape('u');
                cp = ch.charCodeAt(0);
                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
                    throwUnexpectedToken();
                }
            }
            id = ch;
        }

        while (index < length) {
            cp = codePointAt(index);
            if (!isIdentifierPart(cp)) {
                break;
            }
            ch = fromCodePoint(cp);
            id += ch;
            index += ch.length;

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (cp === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                if (source[index] === '{') {
                    ++index;
                    ch = scanUnicodeCodePointEscape();
                } else {
                    ch = scanHexEscape('u');
                    cp = ch.charCodeAt(0);
                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
                        throwUnexpectedToken();
                    }
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getComplexIdentifier();
            } else if (ch >= 0xD800 && ch < 0xDFFF) {
                // Need to handle surrogate pairs.
                index = start;
                return getComplexIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // ECMA-262 11.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokens.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokens.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // ECMA-262 11.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        str += ch;
                        tolerateUnexpectedToken();
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.6 Template Literal Lexical Components

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // ECMA-262 11.8.5 Regular Expression Literals

    function testRegExp(pattern, flags) {
        // The BMP character to use as a replacement for astral symbols when
        // translating an ES6 "u"-flagged pattern to an ES5-compatible
        // approximation.
        // Note: replacing with '\uFFFF' enables false positives in unlikely
        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
        // pattern that would not be detected by this substitution.
        var astralSubstitute = '\uFFFF',
            tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            tmp = tmp
                // Replace every Unicode escape sequence with the equivalent
                // BMP character or a constant ASCII code point in the case of
                // astral symbols. (See the above note on `astralSubstitute`
                // for more information.)
                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
                    var codePoint = parseInt($1 || $2, 16);
                    if (codePoint > 0x10FFFF) {
                        throwUnexpectedToken(null, Messages.InvalidRegExp);
                    }
                    if (codePoint <= 0xFFFF) {
                        return String.fromCharCode(codePoint);
                    }
                    return astralSubstitute;
                })
                // Replace each paired surrogate with a single ASCII symbol to
                // avoid throwing on regular expressions that are only valid in
                // combination with the "u" flag.
                .replace(
                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    astralSubstitute
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;
        scanning = true;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var cp, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        cp = source.charCodeAt(index);

        if (isIdentifierStart(cp)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (cp === 0x27 || cp === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (cp === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(cp)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && cp === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        // Possible identifier start in a surrogate pair.
        if (cp >= 0xD800 && cp < 0xDFFF) {
            cp = codePointAt(index);
            if (isIdentifierStart(cp)) {
                return scanIdentifier();
            }
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            while (last && last.range[0] >= this.range[0]) {
                lastChild = bottomRight.pop();
                last = bottomRight[bottomRight.length - 1];
            }

            if (lastChild) {
                if (lastChild.leadingComments) {
                    leadingComments = [];
                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
                        comment = lastChild.leadingComments[i];
                        if (comment.range[1] <= this.range[0]) {
                            leadingComments.unshift(comment);
                            lastChild.leadingComments.splice(i, 1);
                        }
                    }

                    if (!lastChild.leadingComments.length) {
                        lastChild.leadingComments = undefined;
                    }
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForOfStatement: function (left, right, body) {
            this.type = Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body, generator) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishMetaProperty: function (meta, property) {
            this.type = Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body, sourceType) {
            this.type = Syntax.Program;
            this.body = body;
            this.sourceType = sourceType;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [handler] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishYieldExpression: function (argument, delegate) {
            this.type = Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function constructError(msg, column) {
        var error = new Error(msg);
        try {
            throw error;
        } catch (base) {
            /* istanbul ignore else */
            if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, 'column', { value: column });
            }
        } finally {
            return error;
        }
    }

    function createError(line, pos, description) {
        var msg, column, error;

        msg = 'Line ' + line + ': ' + description;
        column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error = constructError(msg, column);
        error.lineNumber = line;
        error.description = description;
        error.index = pos;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements  AssignmentTargets  AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    // ECMA-262 13.3.3 Destructuring Binding Patterns

    function parseArrayPattern(params, kind) {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    params.push(lookahead);
                    rest = parseVariableIdentifier(params, kind);
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault(params, kind));
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern(params, kind) {
        var node = new Node(), key, keyToken, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            keyToken = lookahead;
            key = parseVariableIdentifier();
            if (match('=')) {
                params.push(keyToken);
                lex();
                init = parseAssignmentExpression();

                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);
            } else if (!match(':')) {
                params.push(keyToken);
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey(params, kind);
        }
        expect(':');
        init = parsePatternWithDefault(params, kind);
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern(params, kind) {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern(params, kind));
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern(params, kind) {
        if (match('[')) {
            return parseArrayPattern(params, kind);
        } else if (match('{')) {
            return parseObjectPattern(params, kind);
        }
        params.push(lookahead);
        return parseVariableIdentifier(kind);
    }

    function parsePatternWithDefault(params, kind) {
        var startToken = lookahead, pattern, previousAllowYield, right;
        pattern = parsePattern(params, kind);
        if (match('=')) {
            lex();
            previousAllowYield = state.allowYield;
            state.allowYield = true;
            right = isolateCoverGrammar(parseAssignmentExpression);
            state.allowYield = previousAllowYield;
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // ECMA-262 12.2.5 Array Initializer

    function parseArrayInitializer() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // ECMA-262 12.2.6 Object Initializer

    function parsePropertyFunction(node, paramInfo, isGenerator) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node(),
            previousAllowYield = state.allowYield;

        state.allowYield = false;
        params = parseParams();
        state.allowYield = previousAllowYield;

        state.allowYield = false;
        method = parsePropertyFunction(node, params, false);
        state.allowYield = previousAllowYield;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode, params,
            previousAllowYield = state.allowYield;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                }, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    state.allowYield = false;
                    parseParam(options);
                    state.allowYield = previousAllowYield;
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                state.allowYield = false;
                value = parsePropertyFunction(methodNode, options, false);
                state.allowYield = previousAllowYield;

                return node.finishProperty('set', key, computed, value, false, false);
            }
        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
            computed = match('[');
            key = parseObjectPropertyKey();
            methodNode = new Node();

            state.allowYield = true;
            params = parseParams();
            state.allowYield = previousAllowYield;

            state.allowYield = false;
            value = parsePropertyFunction(methodNode, params, true);
            state.allowYield = previousAllowYield;

            return node.finishProperty('init', key, computed, value, true, false);
        }

        if (key && match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

        computed = match('[');
        if (match('*')) {
            lex();
        } else {
            key = parseObjectPropertyKey();
        }
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
        if (maybeMethod) {
            return maybeMethod;
        }

        if (!key) {
            throwUnexpectedToken(lookahead);
        }

        // Check for duplicated __proto__
        if (!computed) {
            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
                (key.type === Syntax.Literal && key.value === '__proto__');
            if (hasProto.value && proto) {
                tolerateError(Messages.DuplicateProtoProperty);
            }
            hasProto.value |= proto;
        }

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitializer() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    // ECMA-262 12.2.9 Template Literals

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [quasi];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // ECMA-262 12.2.10 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i, params = [];

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [],
                rawParams: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement(params);
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement(params));
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
                return {
                    type: PlaceHolders.ArrowParameterPlaceHolder,
                    params: [expr]
                };
            }

            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // ECMA-262 12.2 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitializer);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitializer);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            if (state.sourceType === 'module' && lookahead.value === 'await') {
                tolerateUnexpectedToken(lookahead);
            }
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (!strict && state.allowYield && matchKeyword('yield')) {
                return parseNonComputedProperty();
            }
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], expr;

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                if (match('...')) {
                    expr = new Node();
                    lex();
                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
                } else {
                    expr = isolateCoverGrammar(parseAssignmentExpression);
                }
                args.push(expr);
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    // ECMA-262 12.3.3 The new Operator

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');

        if (match('.')) {
            lex();
            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
                if (state.inFunctionBody) {
                    lex();
                    return node.finishMetaProperty('new', 'target');
                }
            }
            throwUnexpectedToken(lookahead);
        }

        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    // ECMA-262 12.3.4 Function Calls

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    // ECMA-262 12.3 Left-Hand-Side Expressions

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // ECMA-262 12.4 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // ECMA-262 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // ECMA-262 12.5 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // ECMA-262 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // ECMA-262 12.6 Multiplicative Operators
    // ECMA-262 12.7 Additive Operators
    // ECMA-262 12.8 Bitwise Shift Operators
    // ECMA-262 12.9 Relational Operators
    // ECMA-262 12.10 Equality Operators
    // ECMA-262 12.11 Binary Bitwise Operators
    // ECMA-262 12.12 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // ECMA-262 12.13 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // ECMA-262 14.2 Arrow Function Definitions

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        case Syntax.YieldExpression:
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                if (param.right.type === Syntax.YieldExpression) {
                    if (param.right.argument) {
                        throwUnexpectedToken(lookahead);
                    }
                    param.right.type = Syntax.Identifier;
                    param.right.name = 'yield';
                    delete param.right.argument;
                    delete param.right.delegate;
                }
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (strict || !state.allowYield) {
            for (i = 0, len = params.length; i < len; i += 1) {
                param = params[i];
                if (param.type === Syntax.YieldExpression) {
                    throwUnexpectedToken(lookahead);
                }
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, previousAllowYield, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');

        previousStrict = strict;
        previousAllowYield = state.allowYield;
        state.allowYield = true;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // ECMA-262 14.4 Yield expression

    function parseYieldExpression() {
        var argument, expr, delegate, previousAllowYield;

        argument = null;
        expr = new Node();

        expectKeyword('yield');

        if (!hasLineTerminator) {
            previousAllowYield = state.allowYield;
            state.allowYield = false;
            delegate = match('*');
            if (delegate) {
                lex();
                argument = parseAssignmentExpression();
            } else {
                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
                    argument = parseAssignmentExpression();
                }
            }
            state.allowYield = previousAllowYield;
        }

        return expr.finishYieldExpression(argument, delegate);
    }

    // ECMA-262 12.14 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        if (!state.allowYield && matchKeyword('yield')) {
            return parseYieldExpression();
        }

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // ECMA-262 12.1.1
            if (strict && expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
                }
                if (isStrictModeReservedWord(expr.name)) {
                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
                }
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // ECMA-262 12.15 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // ECMA-262 13.2 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (state.sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
            case 'let':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // ECMA-262 13.3.2 Variable Statement

    function parseVariableIdentifier(kind) {
        var token, node = new Node();

        token = lex();

        if (token.type === Token.Keyword && token.value === 'yield') {
            if (strict) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } if (!state.allowYield) {
                throwUnexpectedToken(token);
            }
        } else if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                if (strict || token.value !== 'let' || kind !== 'var') {
                    throwUnexpectedToken(token);
                }
            }
        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
            tolerateUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, 'var');

        // ECMA-262 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier && !options.inFor) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(options) {
        var list = [];

        do {
            list.push(parseVariableDeclaration({ inFor: options.inFor }));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList({ inFor: false });

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    // ECMA-262 13.3.1 Let and Const Declarations

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node(), params = [];

        id = parsePattern(params, kind);

        // ECMA-262 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [];

        do {
            list.push(parseLexicalBinding(kind, options));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement(params) {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        params.push(lookahead);

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // ECMA-262 13.4 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // ECMA-262 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 13.6 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // ECMA-262 13.7 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;
        forIn = true;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                declarations = parseVariableDeclarationList({ inFor: true });
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && matchKeyword('in')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishVariableDeclaration(declarations);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    init = init.finishVariableDeclaration(declarations);
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                state.allowIn = false;
                declarations = parseBindingList(kind, {inFor: true});
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                    init = init.finishLexicalDeclaration(declarations, kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
                    init = init.finishLexicalDeclaration(declarations, kind);
                    lex();
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    consumeSemicolon();
                    init = init.finishLexicalDeclaration(declarations, kind);
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchContextualKeyword('of')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForLoop);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseAssignmentExpression();
                    init = null;
                    forIn = false;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                forIn ? node.finishForInStatement(left, right, body) :
                    node.finishForOfStatement(left, right, body);
    }

    // ECMA-262 13.8 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // ECMA-262 13.9 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // ECMA-262 13.10 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // ECMA-262 13.11 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // ECMA-262 13.12 The switch statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // ECMA-262 13.14 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // ECMA-262 13.15 The try statement

    function parseCatchClause() {
        var param, params = [], paramMap = {}, key, i, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern(params);
        for (i = 0; i < params.length; i++) {
            key = '$' + params[i].value;
            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                tolerateError(Messages.DuplicateBinding, params[i].value);
            }
            paramMap[key] = true;
        }

        // ECMA-262 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // ECMA-262 13.16 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 13 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // ECMA-262 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // ECMA-262 14.1 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, params = [], i, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement(params);
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault(params);
        for (i = 0; i < params.length; i++) {
            validateParam(options, params[i], params[i].value);
        }

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        state.allowYield = !isGenerator;
        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }


        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }

        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node(),
            isGenerator, previousAllowYield;

        previousAllowYield = state.allowYield;

        expectKeyword('function');

        isGenerator = match('*');
        if (isGenerator) {
            lex();
        }

        state.allowYield = !isGenerator;
        if (!match('(')) {
            token = lookahead;
            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;
        state.allowYield = previousAllowYield;

        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
    }

    // ECMA-262 14.5 Class Definitions

    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                if (match('*')) {
                    lex();
                } else {
                    key = parseObjectPropertyKey();
                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
                        token = lookahead;
                        isStatic = true;
                        computed = match('[');
                        if (match('*')) {
                            lex();
                        } else {
                            key = parseObjectPropertyKey();
                        }
                    }
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic; // jscs:ignore requireDotNotation
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // ECMA-262 15.2 Modules

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    // ECMA-262 15.2.3 Exports

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        while (!match('}')) {
            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
            specifiers.push(parseExportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitializer();
        } else if (match('[')) {
            expression = parseArrayInitializer();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    // ECMA-262 15.2.2 Imports

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        while (!match('}')) {
            specifiers.push(parseImportSpecifier());
            if (!match('}')) {
                expect(',');
                if (match('}')) {
                    break;
                }
            }
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers = [], src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');

        if (lookahead.type === Token.StringLiteral) {
            // import 'foo';
            src = parseModuleSpecifier();
        } else {

            if (match('{')) {
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            } else if (match('*')) {
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
                // import foo
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                    if (match('*')) {
                        // import foo, * as foo
                        specifiers.push(parseImportNamespaceSpecifier());
                    } else if (match('{')) {
                        // import foo, {bar}
                        specifiers = specifiers.concat(parseNamedImports());
                    } else {
                        throwUnexpectedToken(lookahead);
                    }
                }
            } else {
                throwUnexpectedToken(lex());
            }

            if (!matchContextualKeyword('from')) {
                throwError(lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
        }

        consumeSemicolon();
        return node.finishImportDeclaration(specifiers, src);
    }

    // ECMA-262 15.1 Scripts

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body, state.sourceType);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            allowYield: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: [],
            sourceType: 'script'
        };
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                state.sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.6.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],26:[function(require,module,exports){
var trim = require('./trim');
var decap = require('./decapitalize');

module.exports = function camelize(str, decapitalize) {
  str = trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (decapitalize === true) {
    return decap(str);
  } else {
    return str;
  }
};

},{"./decapitalize":35,"./trim":87}],27:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function capitalize(str, lowercaseRest) {
  str = makeString(str);
  var remainingChars = !lowercaseRest ? str.slice(1) : str.slice(1).toLowerCase();

  return str.charAt(0).toUpperCase() + remainingChars;
};

},{"./helper/makeString":45}],28:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function chars(str) {
  return makeString(str).split('');
};

},{"./helper/makeString":45}],29:[function(require,module,exports){
module.exports = function chop(str, step) {
  if (str == null) return [];
  str = String(str);
  step = ~~step;
  return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
};

},{}],30:[function(require,module,exports){
var capitalize = require('./capitalize');
var camelize = require('./camelize');
var makeString = require('./helper/makeString');

module.exports = function classify(str) {
  str = makeString(str);
  return capitalize(camelize(str.replace(/[\W_]/g, ' ')).replace(/\s/g, ''));
};

},{"./camelize":26,"./capitalize":27,"./helper/makeString":45}],31:[function(require,module,exports){
var trim = require('./trim');

module.exports = function clean(str) {
  return trim(str).replace(/\s\s+/g, ' ');
};

},{"./trim":87}],32:[function(require,module,exports){

var makeString = require('./helper/makeString');

var from  = "",
    to    = "aaaaaaaaaccceeeeeghiiiijllnnoooooooossssttuuuuuunyyczzz";

from += from.toUpperCase();
to += to.toUpperCase();

to = to.split("");

// for tokens requireing multitoken output
from += "";
to.push('ss');


module.exports = function cleanDiacritics(str) {
    return makeString(str).replace(/.{1}/g, function(c){
      var index = from.indexOf(c);
      return index === -1 ? c : to[index];
  });
};

},{"./helper/makeString":45}],33:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function(str, substr) {
  str = makeString(str);
  substr = makeString(substr);

  if (str.length === 0 || substr.length === 0) return 0;
  
  return str.split(substr).length - 1;
};

},{"./helper/makeString":45}],34:[function(require,module,exports){
var trim = require('./trim');

module.exports = function dasherize(str) {
  return trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
};

},{"./trim":87}],35:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function decapitalize(str) {
  str = makeString(str);
  return str.charAt(0).toLowerCase() + str.slice(1);
};

},{"./helper/makeString":45}],36:[function(require,module,exports){
var makeString = require('./helper/makeString');

function getIndent(str) {
  var matches = str.match(/^[\s\\t]*/gm);
  var indent = matches[0].length;
  
  for (var i = 1; i < matches.length; i++) {
    indent = Math.min(matches[i].length, indent);
  }

  return indent;
}

module.exports = function dedent(str, pattern) {
  str = makeString(str);
  var indent = getIndent(str);
  var reg;

  if (indent === 0) return str;

  if (typeof pattern === 'string') {
    reg = new RegExp('^' + pattern, 'gm');
  } else {
    reg = new RegExp('^[ \\t]{' + indent + '}', 'gm');
  }

  return str.replace(reg, '');
};

},{"./helper/makeString":45}],37:[function(require,module,exports){
var makeString = require('./helper/makeString');
var toPositive = require('./helper/toPositive');

module.exports = function endsWith(str, ends, position) {
  str = makeString(str);
  ends = '' + ends;
  if (typeof position == 'undefined') {
    position = str.length - ends.length;
  } else {
    position = Math.min(toPositive(position), str.length) - ends.length;
  }
  return position >= 0 && str.indexOf(ends, position) === position;
};

},{"./helper/makeString":45,"./helper/toPositive":47}],38:[function(require,module,exports){
var makeString = require('./helper/makeString');
var escapeChars = require('./helper/escapeChars');
var reversedEscapeChars = {};

var regexString = "[";
for(var key in escapeChars) {
  regexString += key;
}
regexString += "]";

var regex = new RegExp( regexString, 'g');

module.exports = function escapeHTML(str) {

  return makeString(str).replace(regex, function(m) {
    return '&' + escapeChars[m] + ';';
  });
};

},{"./helper/escapeChars":42,"./helper/makeString":45}],39:[function(require,module,exports){
module.exports = function() {
  var result = {};

  for (var prop in this) {
    if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse|join)$/)) continue;
    result[prop] = this[prop];
  }

  return result;
};

},{}],40:[function(require,module,exports){
var makeString = require('./makeString');

module.exports = function adjacent(str, direction) {
  str = makeString(str);
  if (str.length === 0) {
    return '';
  }
  return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length - 1) + direction);
};

},{"./makeString":45}],41:[function(require,module,exports){
var escapeRegExp = require('./escapeRegExp');

module.exports = function defaultToWhiteSpace(characters) {
  if (characters == null)
    return '\\s';
  else if (characters.source)
    return characters.source;
  else
    return '[' + escapeRegExp(characters) + ']';
};

},{"./escapeRegExp":43}],42:[function(require,module,exports){
/* We're explicitly defining the list of entities we want to escape.
nbsp is an HTML entity, but we don't want to escape all space characters in a string, hence its omission in this map.

*/
var escapeChars = {
  '' : 'cent',
  '' : 'pound',
  '' : 'yen',
  '': 'euro',
  '' :'copy',
  '' : 'reg',
  '<' : 'lt',
  '>' : 'gt',
  '"' : 'quot',
  '&' : 'amp',
  "'": '#39'
};

module.exports = escapeChars;

},{}],43:[function(require,module,exports){
var makeString = require('./makeString');

module.exports = function escapeRegExp(str) {
  return makeString(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};

},{"./makeString":45}],44:[function(require,module,exports){
/*
We're explicitly defining the list of entities that might see in escape HTML strings
*/
var htmlEntities = {
  nbsp: ' ',
  cent: '',
  pound: '',
  yen: '',
  euro: '',
  copy: '',
  reg: '',
  lt: '<',
  gt: '>',
  quot: '"',
  amp: '&',
  apos: "'"
};

module.exports = htmlEntities;

},{}],45:[function(require,module,exports){
/**
 * Ensure some object is a coerced to a string
 **/
module.exports = function makeString(object) {
  if (object == null) return '';
  return '' + object;
};

},{}],46:[function(require,module,exports){
module.exports = function strRepeat(str, qty){
  if (qty < 1) return '';
  var result = '';
  while (qty > 0) {
    if (qty & 1) result += str;
    qty >>= 1, str += str;
  }
  return result;
};

},{}],47:[function(require,module,exports){
module.exports = function toPositive(number) {
  return number < 0 ? 0 : (+number || 0);
};

},{}],48:[function(require,module,exports){
var capitalize = require('./capitalize');
var underscored = require('./underscored');
var trim = require('./trim');

module.exports = function humanize(str) {
  return capitalize(trim(underscored(str).replace(/_id$/, '').replace(/_/g, ' ')));
};

},{"./capitalize":27,"./trim":87,"./underscored":89}],49:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function include(str, needle) {
  if (needle === '') return true;
  return makeString(str).indexOf(needle) !== -1;
};

},{"./helper/makeString":45}],50:[function(require,module,exports){
//  Underscore.string
//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
//  Underscore.string is freely distributable under the terms of the MIT license.
//  Documentation: https://github.com/epeli/underscore.string
//  Some code is borrowed from MooTools and Alexandru Marasteanu.
//  Version '3.2.2'

'use strict';

function s(value) {
  /* jshint validthis: true */
  if (!(this instanceof s)) return new s(value);
  this._wrapped = value;
}

s.VERSION = '3.2.2';

s.isBlank          = require('./isBlank');
s.stripTags        = require('./stripTags');
s.capitalize       = require('./capitalize');
s.decapitalize     = require('./decapitalize');
s.chop             = require('./chop');
s.trim             = require('./trim');
s.clean            = require('./clean');
s.cleanDiacritics  = require('./cleanDiacritics');
s.count            = require('./count');
s.chars            = require('./chars');
s.swapCase         = require('./swapCase');
s.escapeHTML       = require('./escapeHTML');
s.unescapeHTML     = require('./unescapeHTML');
s.splice           = require('./splice');
s.insert           = require('./insert');
s.replaceAll       = require('./replaceAll');
s.include          = require('./include');
s.join             = require('./join');
s.lines            = require('./lines');
s.dedent           = require('./dedent');
s.reverse          = require('./reverse');
s.startsWith       = require('./startsWith');
s.endsWith         = require('./endsWith');
s.pred             = require('./pred');
s.succ             = require('./succ');
s.titleize         = require('./titleize');
s.camelize         = require('./camelize');
s.underscored      = require('./underscored');
s.dasherize        = require('./dasherize');
s.classify         = require('./classify');
s.humanize         = require('./humanize');
s.ltrim            = require('./ltrim');
s.rtrim            = require('./rtrim');
s.truncate         = require('./truncate');
s.prune            = require('./prune');
s.words            = require('./words');
s.pad              = require('./pad');
s.lpad             = require('./lpad');
s.rpad             = require('./rpad');
s.lrpad            = require('./lrpad');
s.sprintf          = require('./sprintf');
s.vsprintf         = require('./vsprintf');
s.toNumber         = require('./toNumber');
s.numberFormat     = require('./numberFormat');
s.strRight         = require('./strRight');
s.strRightBack     = require('./strRightBack');
s.strLeft          = require('./strLeft');
s.strLeftBack      = require('./strLeftBack');
s.toSentence       = require('./toSentence');
s.toSentenceSerial = require('./toSentenceSerial');
s.slugify          = require('./slugify');
s.surround         = require('./surround');
s.quote            = require('./quote');
s.unquote          = require('./unquote');
s.repeat           = require('./repeat');
s.naturalCmp       = require('./naturalCmp');
s.levenshtein      = require('./levenshtein');
s.toBoolean        = require('./toBoolean');
s.exports          = require('./exports');
s.escapeRegExp     = require('./helper/escapeRegExp');
s.wrap             = require('./wrap');

// Aliases
s.strip     = s.trim;
s.lstrip    = s.ltrim;
s.rstrip    = s.rtrim;
s.center    = s.lrpad;
s.rjust     = s.lpad;
s.ljust     = s.rpad;
s.contains  = s.include;
s.q         = s.quote;
s.toBool    = s.toBoolean;
s.camelcase = s.camelize;


// Implement chaining
s.prototype = {
  value: function value() {
    return this._wrapped;
  }
};

function fn2method(key, fn) {
    if (typeof fn !== "function") return;
    s.prototype[key] = function() {
      var args = [this._wrapped].concat(Array.prototype.slice.call(arguments));
      var res = fn.apply(null, args);
      // if the result is non-string stop the chain and return the value
      return typeof res === 'string' ? new s(res) : res;
    };
}

// Copy functions to instance methods for chaining
for (var key in s) fn2method(key, s[key]);

fn2method("tap", function tap(string, fn) {
  return fn(string);
});

function prototype2method(methodName) {
  fn2method(methodName, function(context) {
    var args = Array.prototype.slice.call(arguments, 1);
    return String.prototype[methodName].apply(context, args);
  });
}

var prototypeMethods = [
  "toUpperCase",
  "toLowerCase",
  "split",
  "replace",
  "slice",
  "substring",
  "substr",
  "concat"
];

for (var key in prototypeMethods) prototype2method(prototypeMethods[key]);


module.exports = s;

},{"./camelize":26,"./capitalize":27,"./chars":28,"./chop":29,"./classify":30,"./clean":31,"./cleanDiacritics":32,"./count":33,"./dasherize":34,"./decapitalize":35,"./dedent":36,"./endsWith":37,"./escapeHTML":38,"./exports":39,"./helper/escapeRegExp":43,"./humanize":48,"./include":49,"./insert":51,"./isBlank":52,"./join":53,"./levenshtein":54,"./lines":55,"./lpad":56,"./lrpad":57,"./ltrim":58,"./naturalCmp":59,"./numberFormat":60,"./pad":61,"./pred":62,"./prune":63,"./quote":64,"./repeat":65,"./replaceAll":66,"./reverse":67,"./rpad":68,"./rtrim":69,"./slugify":70,"./splice":71,"./sprintf":72,"./startsWith":73,"./strLeft":74,"./strLeftBack":75,"./strRight":76,"./strRightBack":77,"./stripTags":78,"./succ":79,"./surround":80,"./swapCase":81,"./titleize":82,"./toBoolean":83,"./toNumber":84,"./toSentence":85,"./toSentenceSerial":86,"./trim":87,"./truncate":88,"./underscored":89,"./unescapeHTML":90,"./unquote":91,"./vsprintf":92,"./words":93,"./wrap":94}],51:[function(require,module,exports){
var splice = require('./splice');

module.exports = function insert(str, i, substr) {
  return splice(str, i, 0, substr);
};

},{"./splice":71}],52:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function isBlank(str) {
  return (/^\s*$/).test(makeString(str));
};

},{"./helper/makeString":45}],53:[function(require,module,exports){
var makeString = require('./helper/makeString');
var slice = [].slice;

module.exports = function join() {
  var args = slice.call(arguments),
    separator = args.shift();

  return args.join(makeString(separator));
};

},{"./helper/makeString":45}],54:[function(require,module,exports){
var makeString = require('./helper/makeString');

/**
 * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein
 */
module.exports = function levenshtein(str1, str2) {
  'use strict';
  str1 = makeString(str1);
  str2 = makeString(str2);

  // Short cut cases  
  if (str1 === str2) return 0;
  if (!str1 || !str2) return Math.max(str1.length, str2.length);

  // two rows
  var prevRow = new Array(str2.length + 1);

  // initialise previous row
  for (var i = 0; i < prevRow.length; ++i) {
    prevRow[i] = i;
  }

  // calculate current row distance from previous row
  for (i = 0; i < str1.length; ++i) {
    var nextCol = i + 1;

    for (var j = 0; j < str2.length; ++j) {
      var curCol = nextCol;

      // substution
      nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
      // insertion
      var tmp = curCol + 1;
      if (nextCol > tmp) {
        nextCol = tmp;
      }
      // deletion
      tmp = prevRow[j + 1] + 1;
      if (nextCol > tmp) {
        nextCol = tmp;
      }

      // copy current col value into previous (in preparation for next iteration)
      prevRow[j] = curCol;
    }

    // copy last col value into previous (in preparation for next iteration)
    prevRow[j] = nextCol;
  }

  return nextCol;
};

},{"./helper/makeString":45}],55:[function(require,module,exports){
module.exports = function lines(str) {
  if (str == null) return [];
  return String(str).split(/\r\n?|\n/);
};

},{}],56:[function(require,module,exports){
var pad = require('./pad');

module.exports = function lpad(str, length, padStr) {
  return pad(str, length, padStr);
};

},{"./pad":61}],57:[function(require,module,exports){
var pad = require('./pad');

module.exports = function lrpad(str, length, padStr) {
  return pad(str, length, padStr, 'both');
};

},{"./pad":61}],58:[function(require,module,exports){
var makeString = require('./helper/makeString');
var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
var nativeTrimLeft = String.prototype.trimLeft;

module.exports = function ltrim(str, characters) {
  str = makeString(str);
  if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp('^' + characters + '+'), '');
};

},{"./helper/defaultToWhiteSpace":41,"./helper/makeString":45}],59:[function(require,module,exports){
module.exports = function naturalCmp(str1, str2) {
  if (str1 == str2) return 0;
  if (!str1) return -1;
  if (!str2) return 1;

  var cmpRegex = /(\.\d+|\d+|\D+)/g,
    tokens1 = String(str1).match(cmpRegex),
    tokens2 = String(str2).match(cmpRegex),
    count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i],
      b = tokens2[i];

    if (a !== b) {
      var num1 = +a;
      var num2 = +b;
      if (num1 === num1 && num2 === num2) {
        return num1 > num2 ? 1 : -1;
      }
      return a < b ? -1 : 1;
    }
  }

  if (tokens1.length != tokens2.length)
    return tokens1.length - tokens2.length;

  return str1 < str2 ? -1 : 1;
};

},{}],60:[function(require,module,exports){
module.exports = function numberFormat(number, dec, dsep, tsep) {
  if (isNaN(number) || number == null) return '';

  number = number.toFixed(~~dec);
  tsep = typeof tsep == 'string' ? tsep : ',';

  var parts = number.split('.'),
    fnums = parts[0],
    decimals = parts[1] ? (dsep || '.') + parts[1] : '';

  return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
};

},{}],61:[function(require,module,exports){
var makeString = require('./helper/makeString');
var strRepeat = require('./helper/strRepeat');

module.exports = function pad(str, length, padStr, type) {
  str = makeString(str);
  length = ~~length;

  var padlen = 0;

  if (!padStr)
    padStr = ' ';
  else if (padStr.length > 1)
    padStr = padStr.charAt(0);

  switch (type) {
    case 'right':
      padlen = length - str.length;
      return str + strRepeat(padStr, padlen);
    case 'both':
      padlen = length - str.length;
      return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
    default: // 'left'
      padlen = length - str.length;
      return strRepeat(padStr, padlen) + str;
  }
};

},{"./helper/makeString":45,"./helper/strRepeat":46}],62:[function(require,module,exports){
var adjacent = require('./helper/adjacent');

module.exports = function succ(str) {
  return adjacent(str, -1);
};

},{"./helper/adjacent":40}],63:[function(require,module,exports){
/**
 * _s.prune: a more elegant version of truncate
 * prune extra chars, never leaving a half-chopped word.
 * @author github.com/rwz
 */
var makeString = require('./helper/makeString');
var rtrim = require('./rtrim');

module.exports = function prune(str, length, pruneStr) {
  str = makeString(str);
  length = ~~length;
  pruneStr = pruneStr != null ? String(pruneStr) : '...';

  if (str.length <= length) return str;

  var tmpl = function(c) {
    return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
  },
    template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

  if (template.slice(template.length - 2).match(/\w\w/))
    template = template.replace(/\s*\S+$/, '');
  else
    template = rtrim(template.slice(0, template.length - 1));

  return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
};

},{"./helper/makeString":45,"./rtrim":69}],64:[function(require,module,exports){
var surround = require('./surround');

module.exports = function quote(str, quoteChar) {
  return surround(str, quoteChar || '"');
};

},{"./surround":80}],65:[function(require,module,exports){
var makeString = require('./helper/makeString');
var strRepeat = require('./helper/strRepeat');

module.exports = function repeat(str, qty, separator) {
  str = makeString(str);

  qty = ~~qty;

  // using faster implementation if separator is not needed;
  if (separator == null) return strRepeat(str, qty);

  // this one is about 300x slower in Google Chrome
  for (var repeat = []; qty > 0; repeat[--qty] = str) {}
  return repeat.join(separator);
};

},{"./helper/makeString":45,"./helper/strRepeat":46}],66:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function replaceAll(str, find, replace, ignorecase) {
  var flags = (ignorecase === true)?'gi':'g';
  var reg = new RegExp(find, flags);

  return makeString(str).replace(reg, replace);
};

},{"./helper/makeString":45}],67:[function(require,module,exports){
var chars = require('./chars');

module.exports = function reverse(str) {
  return chars(str).reverse().join('');
};

},{"./chars":28}],68:[function(require,module,exports){
var pad = require('./pad');

module.exports = function rpad(str, length, padStr) {
  return pad(str, length, padStr, 'right');
};

},{"./pad":61}],69:[function(require,module,exports){
var makeString = require('./helper/makeString');
var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
var nativeTrimRight = String.prototype.trimRight;

module.exports = function rtrim(str, characters) {
  str = makeString(str);
  if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp(characters + '+$'), '');
};

},{"./helper/defaultToWhiteSpace":41,"./helper/makeString":45}],70:[function(require,module,exports){
var makeString = require('./helper/makeString');
var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
var trim = require('./trim');
var dasherize = require('./dasherize');
var cleanDiacritics = require("./cleanDiacritics");

module.exports = function slugify(str) {
  return trim(dasherize(cleanDiacritics(str).replace(/[^\w\s-]/g, '-').toLowerCase()), '-');
};

},{"./cleanDiacritics":32,"./dasherize":34,"./helper/defaultToWhiteSpace":41,"./helper/makeString":45,"./trim":87}],71:[function(require,module,exports){
var chars = require('./chars');

module.exports = function splice(str, i, howmany, substr) {
  var arr = chars(str);
  arr.splice(~~i, ~~howmany, substr);
  return arr.join('');
};

},{"./chars":28}],72:[function(require,module,exports){
// sprintf() for JavaScript 0.7-beta1
// http://www.diveintojavascript.com/projects/javascript-sprintf
//
// Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
// All rights reserved.
var strRepeat = require('./helper/strRepeat');
var toString = Object.prototype.toString;
var sprintf = (function() {
  function get_type(variable) {
    return toString.call(variable).slice(8, -1).toLowerCase();
  }

  var str_repeat = strRepeat;

  var str_format = function() {
    if (!str_format.cache.hasOwnProperty(arguments[0])) {
      str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
    }
    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
  };

  str_format.format = function(parse_tree, argv) {
    var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
    for (i = 0; i < tree_length; i++) {
      node_type = get_type(parse_tree[i]);
      if (node_type === 'string') {
        output.push(parse_tree[i]);
      }
      else if (node_type === 'array') {
        match = parse_tree[i]; // convenience purposes only
        if (match[2]) { // keyword argument
          arg = argv[cursor];
          for (k = 0; k < match[2].length; k++) {
            if (!arg.hasOwnProperty(match[2][k])) {
              throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
            }
            arg = arg[match[2][k]];
          }
        } else if (match[1]) { // positional argument (explicit)
          arg = argv[match[1]];
        }
        else { // positional argument (implicit)
          arg = argv[cursor++];
        }

        if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
          throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
        }
        switch (match[8]) {
          case 'b': arg = arg.toString(2); break;
          case 'c': arg = String.fromCharCode(arg); break;
          case 'd': arg = parseInt(arg, 10); break;
          case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
          case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
          case 'o': arg = arg.toString(8); break;
          case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
          case 'u': arg = Math.abs(arg); break;
          case 'x': arg = arg.toString(16); break;
          case 'X': arg = arg.toString(16).toUpperCase(); break;
        }
        arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
        pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
        pad_length = match[6] - String(arg).length;
        pad = match[6] ? str_repeat(pad_character, pad_length) : '';
        output.push(match[5] ? arg + pad : pad + arg);
      }
    }
    return output.join('');
  };

  str_format.cache = {};

  str_format.parse = function(fmt) {
    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
    while (_fmt) {
      if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
        parse_tree.push(match[0]);
      }
      else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
        parse_tree.push('%');
      }
      else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
        if (match[2]) {
          arg_names |= 1;
          var field_list = [], replacement_field = match[2], field_match = [];
          if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
            field_list.push(field_match[1]);
            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
              if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              }
              else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              }
              else {
                throw new Error('[_.sprintf] huh?');
              }
            }
          }
          else {
            throw new Error('[_.sprintf] huh?');
          }
          match[2] = field_list;
        }
        else {
          arg_names |= 2;
        }
        if (arg_names === 3) {
          throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
        }
        parse_tree.push(match);
      }
      else {
        throw new Error('[_.sprintf] huh?');
      }
      _fmt = _fmt.substring(match[0].length);
    }
    return parse_tree;
  };

  return str_format;
})();

module.exports = sprintf;

},{"./helper/strRepeat":46}],73:[function(require,module,exports){
var makeString = require('./helper/makeString');
var toPositive = require('./helper/toPositive');

module.exports = function startsWith(str, starts, position) {
  str = makeString(str);
  starts = '' + starts;
  position = position == null ? 0 : Math.min(toPositive(position), str.length);
  return str.lastIndexOf(starts, position) === position;
};

},{"./helper/makeString":45,"./helper/toPositive":47}],74:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function strLeft(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.indexOf(sep);
  return~ pos ? str.slice(0, pos) : str;
};

},{"./helper/makeString":45}],75:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function strLeftBack(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = str.lastIndexOf(sep);
  return~ pos ? str.slice(0, pos) : str;
};

},{"./helper/makeString":45}],76:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function strRight(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.indexOf(sep);
  return~ pos ? str.slice(pos + sep.length, str.length) : str;
};

},{"./helper/makeString":45}],77:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function strRightBack(str, sep) {
  str = makeString(str);
  sep = makeString(sep);
  var pos = !sep ? -1 : str.lastIndexOf(sep);
  return~ pos ? str.slice(pos + sep.length, str.length) : str;
};

},{"./helper/makeString":45}],78:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function stripTags(str) {
  return makeString(str).replace(/<\/?[^>]+>/g, '');
};

},{"./helper/makeString":45}],79:[function(require,module,exports){
var adjacent = require('./helper/adjacent');

module.exports = function succ(str) {
  return adjacent(str, 1);
};

},{"./helper/adjacent":40}],80:[function(require,module,exports){
module.exports = function surround(str, wrapper) {
  return [wrapper, str, wrapper].join('');
};

},{}],81:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function swapCase(str) {
  return makeString(str).replace(/\S/g, function(c) {
    return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
  });
};

},{"./helper/makeString":45}],82:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function titleize(str) {
  return makeString(str).toLowerCase().replace(/(?:^|\s|-)\S/g, function(c) {
    return c.toUpperCase();
  });
};

},{"./helper/makeString":45}],83:[function(require,module,exports){
var trim = require('./trim');

function boolMatch(s, matchers) {
  var i, matcher, down = s.toLowerCase();
  matchers = [].concat(matchers);
  for (i = 0; i < matchers.length; i += 1) {
    matcher = matchers[i];
    if (!matcher) continue;
    if (matcher.test && matcher.test(s)) return true;
    if (matcher.toLowerCase() === down) return true;
  }
}

module.exports = function toBoolean(str, trueValues, falseValues) {
  if (typeof str === "number") str = "" + str;
  if (typeof str !== "string") return !!str;
  str = trim(str);
  if (boolMatch(str, trueValues || ["true", "1"])) return true;
  if (boolMatch(str, falseValues || ["false", "0"])) return false;
};

},{"./trim":87}],84:[function(require,module,exports){
var trim = require('./trim');

module.exports = function toNumber(num, precision) {
  if (num == null) return 0;
  var factor = Math.pow(10, isFinite(precision) ? precision : 0);
  return Math.round(num * factor) / factor;
};

},{"./trim":87}],85:[function(require,module,exports){
var rtrim = require('./rtrim');

module.exports = function toSentence(array, separator, lastSeparator, serial) {
  separator = separator || ', ';
  lastSeparator = lastSeparator || ' and ';
  var a = array.slice(),
    lastMember = a.pop();

  if (array.length > 2 && serial) lastSeparator = rtrim(separator) + lastSeparator;

  return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
};

},{"./rtrim":69}],86:[function(require,module,exports){
var toSentence = require('./toSentence');

module.exports = function toSentenceSerial(array, sep, lastSep) {
  return toSentence(array, sep, lastSep, true);
};

},{"./toSentence":85}],87:[function(require,module,exports){
var makeString = require('./helper/makeString');
var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
var nativeTrim = String.prototype.trim;

module.exports = function trim(str, characters) {
  str = makeString(str);
  if (!characters && nativeTrim) return nativeTrim.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
};

},{"./helper/defaultToWhiteSpace":41,"./helper/makeString":45}],88:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function truncate(str, length, truncateStr) {
  str = makeString(str);
  truncateStr = truncateStr || '...';
  length = ~~length;
  return str.length > length ? str.slice(0, length) + truncateStr : str;
};

},{"./helper/makeString":45}],89:[function(require,module,exports){
var trim = require('./trim');

module.exports = function underscored(str) {
  return trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
};

},{"./trim":87}],90:[function(require,module,exports){
var makeString = require('./helper/makeString');
var htmlEntities = require('./helper/htmlEntities');

module.exports = function unescapeHTML(str) {
  return makeString(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
    var match;

    if (entityCode in htmlEntities) {
      return htmlEntities[entityCode];
    } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
      return String.fromCharCode(parseInt(match[1], 16));
    } else if (match = entityCode.match(/^#(\d+)$/)) {
      return String.fromCharCode(~~match[1]);
    } else {
      return entity;
    }
  });
};

},{"./helper/htmlEntities":44,"./helper/makeString":45}],91:[function(require,module,exports){
module.exports = function unquote(str, quoteChar) {
  quoteChar = quoteChar || '"';
  if (str[0] === quoteChar && str[str.length - 1] === quoteChar)
    return str.slice(1, str.length - 1);
  else return str;
};

},{}],92:[function(require,module,exports){
var sprintf = require('./sprintf');

module.exports = function vsprintf(fmt, argv) {
  argv.unshift(fmt);
  return sprintf.apply(null, argv);
};

},{"./sprintf":72}],93:[function(require,module,exports){
var isBlank = require('./isBlank');
var trim = require('./trim');

module.exports = function words(str, delimiter) {
  if (isBlank(str)) return [];
  return trim(str, delimiter).split(delimiter || /\s+/);
};

},{"./isBlank":52,"./trim":87}],94:[function(require,module,exports){
// Wrap
// wraps a string by a certain width

makeString = require('./helper/makeString');

module.exports = function wrap(str, options){
	str = makeString(str);

	options = options || {};

	width = options.width || 75;
	seperator = options.seperator || '\n';
	cut = options.cut || false;
	preserveSpaces = options.preserveSpaces || false;
	trailingSpaces = options.trailingSpaces || false;

	if(width <= 0){
		return str;
	}

	else if(!cut){

		words = str.split(" ");
		result = "";
		current_column = 0;

		while(words.length > 0){
			
			// if adding a space and the next word would cause this line to be longer than width...
			if(1 + words[0].length + current_column > width){
				//start a new line if this line is not already empty
				if(current_column > 0){
					// add a space at the end of the line is preserveSpaces is true
					if (preserveSpaces){
						result += ' ';
						current_column++;
					}
					// fill the rest of the line with spaces if trailingSpaces option is true
					else if(trailingSpaces){
						while(current_column < width){
							result += ' ';
							current_column++;
						}						
					}
					//start new line
					result += seperator;
					current_column = 0;
				}
			}

			// if not at the begining of the line, add a space in front of the word
			if(current_column > 0){
				result += " ";
				current_column++;
			}

			// tack on the next word, update current column, a pop words array
			result += words[0];
			current_column += words[0].length;
			words.shift();

		}

		// fill the rest of the line with spaces if trailingSpaces option is true
		if(trailingSpaces){
			while(current_column < width){
				result += ' ';
				current_column++;
			}						
		}

		return result;

	}

	else {

		index = 0;
		result = "";

		// walk through each character and add seperators where appropriate
		while(index < str.length){
			if(index % width == 0 && index > 0){
				result += seperator;
			}
			result += str.charAt(index);
			index++;
		}

		// fill the rest of the line with spaces if trailingSpaces option is true
		if(trailingSpaces){
			while(index % width > 0){
				result += ' ';
				index++;
			}						
		}
		
		return result;
	}
};
},{"./helper/makeString":45}],95:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],96:[function(require,module,exports){
(function (Buffer){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../../utilities/types'),
    strings = require('../../utilities/strings'),
    mssql = require('mssql');

module.exports = {
    // Performs the following validations on the specified identifier:
    // - first char is alphabetic or an underscore
    // - all other characters are alphanumeric or underscore
    // - the identifier is LTE 128 in length
    isValidIdentifier: function (identifier) {
        if (!identifier || !types.isString(identifier) || identifier.length > 128) {
            return false;
        }

        for (var i = 0; i < identifier.length; i++) {
            var char = identifier[i];
            if (i === 0) {
                if (!(strings.isLetter(char) || (char == '_'))) {
                    return false;
                }
            } else {
                if (!(strings.isLetter(char) || strings.isDigit(char) || (char == '_'))) {
                    return false;
                }
            }
        }

        return true;
    },

    validateIdentifier: function (identifier) {
        if (!this.isValidIdentifier(identifier)) {
            throw new Error(identifier + " is not a valid identifier. Identifiers must be under 128 characters in length, start with a letter or underscore, and can contain only alpha-numeric and underscore characters.");
        }
    },

    formatTableName: function (schemaName, tableName) {
        
        this.validateIdentifier(tableName);

        if (schemaName !== undefined) {
            schemaName = module.exports.formatSchemaName(schemaName);
            this.validateIdentifier(schemaName);
            return '[' + schemaName + '].[' + tableName + ']';
        }
        
        return tableName;
    },

    formatSchemaName: function (appName) {
        // Hyphens are not supported in schema names
        return appName.replace(/-/g, '_');
    },

    formatMember: function (memberName) {
        this.validateIdentifier(memberName);
        return '[' + memberName + ']';
    },

    getSqlType: function (value, primaryKey) {
        if(value === undefined || value === null)
            throw new Error('Cannot create column for null or undefined value');

        switch (value.constructor) {
            case String:
                // 900 bytes is the maximum length for a primary key - http://stackoverflow.com/questions/10555642/varcharmax-column-not-allowed-to-be-a-primary-key-in-sql-server
                return primaryKey ? "NVARCHAR(255)" : "NVARCHAR(MAX)";
            case Number:
                return primaryKey ? "INT" : "FLOAT(53)";
            case Boolean:
                return "BIT";
            case Date:
                return "DATETIMEOFFSET(3)";
            default:
                throw new Error("Unable to map value " + value.ToString() + " to a SQL type.");
        }
    },

    getMssqlType: function (value, primaryKey) {
        switch (value && value.constructor) {
            case String:
                return primaryKey ? mssql.NVarChar(255) : mssql.NVarChar();
            case Number:
                return primaryKey || isInteger(value) ? mssql.Int : mssql.Float;
            case Boolean:
                return mssql.Bit;
            case Date:
                return mssql.DateTimeOffset;
            case Buffer:
                return mssql.VarBinary;
        }

        function isInteger(value) {
            // integers larger than the maximum value get inserted as 1 - treat these as float parameters as a workaround
            return value.toFixed() === value.toString() && value < 2147483648 && value > -2147483648;
        }
    },

    getPredefinedColumnType: function (value) {
        switch(value) {
            case 'string':
                return 'NVARCHAR(MAX)';
            case 'number':
                return 'FLOAT(53)';
            case 'boolean':
            case 'bool':
                return 'BIT';
            case 'datetime':
            case 'date':
                return 'DATETIMEOFFSET(3)';
        }

        throw new Error('Unrecognised column type: ' + value);
    },

    getPredefinedType: function (value) {
        switch(value) {
            case 'nvarchar':
                return 'string';
            case 'float':
                return 'number';
            case 'bit':
                return 'boolean';
            case 'datetimeoffset':
                return 'datetime';
            default:
                return value;
        }
    },
};

}).call(this,require("buffer").Buffer)
},{"../../utilities/strings":105,"../../utilities/types":106,"buffer":108,"mssql":1}],97:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../../../utilities/types'),
    ExpressionVisitor = require('../../../query/ExpressionVisitor'),
    expressions = require('../../../query/expressions');

module.exports = function (expr) {
    var booleanizer = new SqlBooleanizer();

    expr = booleanizer.visit(expr);
    expr = ensureExpressionIsBoolean(expr);

    return expr;
};

var SqlBooleanizer = types.deriveClass(ExpressionVisitor, null, {
    visitUnary: function (expr) {
        var operand = this.visit(expr.operand);

        if (operand && expr.expressionType == 'Not') {
            // Convert expression 'x' to a boolean expression '(x = true)' since
            // the SQL Not operator requires a boolean expression (not a BIT)
            return new expressions.Unary(ensureExpressionIsBoolean(operand), 'Not');
        }

        if (operand != expr.operand) {
            return new expressions.Unary(operand, expr.expressionType);
        }

        return expr;
    },

    visitBinary: function (expr) {
        var left = null;
        var right = null;

        // first visit the expressions to do any sub conversions, before
        // doing any transformations below
        if (expr.left !== null) {
            left = this.visit(expr.left);
        }
        if (expr.right !== null) {
            right = this.visit(expr.right);
        }

        if ((expr.expressionType == 'And') || (expr.expressionType == 'Or')) {
            // both operands must be boolean expressions
            left = ensureExpressionIsBoolean(left);
            right = ensureExpressionIsBoolean(right);
        }
        else if ((expr.expressionType == 'Equal') || (expr.expressionType == 'NotEqual')) {
            // remove any comparisons between boolean and bit
            var converted = rewriteBitComparison(left, right);
            if (converted) {
                return converted;
            }
        }

        if (left != expr.left || right != expr.right) {
            return new expressions.Binary(left, right, expr.expressionType);
        }

        return expr;
    }
});

// if a boolean expression is being compared to a bit expression, convert
// by removing the comparison. E.g. (endswith('value', title) eq false) => not(endswith('value', title))
function rewriteBitComparison(left, right) {
    if (isBooleanExpression(left) && isBitConstant(right)) {
        return (right.value === true) ? left : new expressions.Unary(left, 'Not');
    }
    else if (isBooleanExpression(right) && isBitConstant(left)) {
        return (left.value === true) ? right : new expressions.Unary(right, 'Not');
    }

    // no conversion necessary
    return null;
}

// returns true if the expression is the constant 'true' or 'false'
function isBitConstant(expr) {
    return (expr.expressionType == 'Constant') && (expr.value === true || expr.value === false);
}

// if the expression isn't boolean, convert to a boolean expression (e.g. (isDiscontinued) => (isDiscontinued = 1))
function ensureExpressionIsBoolean(expr) {
    if (!isBooleanExpression(expr)) {
        return new expressions.Binary(expr, new expressions.Constant(true), 'Equal');
    }
    return expr;
}

function isBooleanExpression(expr) {
    if (!expr) {
        return false;
    }

    // see if this is a logical boolean expression
    switch (expr.expressionType) {
        case 'And':
        case 'Or':
        case 'GreaterThan':
        case 'GreaterThanOrEqual':
        case 'LessThan':
        case 'LessThanOrEqual':
        case 'Not':
        case 'Equal':
        case 'NotEqual':
            return true;
        default:
            break;
    }

    // boolean odata functions
    if (expr.expressionType == 'Call') {
        switch (expr.memberInfo.memberName) {
            case 'startswith':
            case 'endswith':
            case 'substringof':
                return true;
            default:
                break;
        }
    }

    return false;
}

},{"../../../query/ExpressionVisitor":100,"../../../query/expressions":101,"../../../utilities/types":106}],98:[function(require,module,exports){
(function (Buffer){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../../../utilities/types'),
    _ = require('underscore'),
    ExpressionVisitor = require('../../../query/ExpressionVisitor');

module.exports = function (expr, tableMetadata) {
    return new TypeConverter(tableMetadata).visit(expr);
};

function ctor(tableMetadata) {
    this.tableMetadata = tableMetadata;
}

var TypeConverter = types.deriveClass(ExpressionVisitor, ctor, {
    visitBinary: function (expr) {
        var left = expr.left ? this.visit(expr.left) : null;
        var right = expr.right ? this.visit(expr.right) : null;

        if (this._isStringConstant(left) && this._isBinaryMemberAccess(right)) {
            left.value = new Buffer(left.value, 'base64');
        }
        else if (this._isStringConstant(right) && this._isBinaryMemberAccess(left)) {
            right.value = new Buffer(right.value, 'base64');
        }

        if (left != expr.left || right != expr.right) {
            return new Binary(left, right, expr.expressionType);
        }

        return expr;
    },

    _isStringConstant: function(expr) {
        return expr &&
               expr.expressionType === 'Constant' &&
               types.isString(expr.value);
    },

    _isBinaryMemberAccess: function (expr) {
        return expr &&
               expr.expressionType === 'MemberAccess' &&
               types.isString(expr.member) && // tableConfig.binaryColumns is not currently used - hard coded __version column
               (_.contains(this.tableMetadata.binaryColumns, expr.member.toLowerCase()) || expr.member.toLowerCase() === '__version');
    }
});

}).call(this,require("buffer").Buffer)
},{"../../../query/ExpressionVisitor":100,"../../../utilities/types":106,"buffer":108,"underscore":95}],99:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../../../utilities/types'),
    _ = require('underscore.string'),
    parseOData = require('../../../query/parseOData'),
    ExpressionVisitor = require('../../../query/ExpressionVisitor'),
    convertTypes = require('./convertTypes'),
    booleanize = require('./booleanize'),
    helpers = require('../helpers'),
    expressions = require('../../../query/expressions'),
    mssql = require('mssql');

// query should be in the format as generated by query.js toOData function
module.exports = function (query, tableConfig) {
    var formatter = new SqlFormatter(tableConfig);
    return formatter.format(query);
};

function ctor(tableConfig) {
    this.tableConfig = tableConfig || {};
    this.flavor = this.tableConfig.flavor || 'mssql';
    
    if (this.flavor !== 'sqlite') {
        this.schemaName = this.tableConfig.schemaName || 'dbo';
    }
}

var SqlFormatter = types.deriveClass(ExpressionVisitor, ctor, {
    format: function (query) {
        // if a skip is requested but no top is defined, we need
        // to still generate the paging query, so default top to
        // max. Really when doing paging, the user should also be
        // specifying a top explicitly however.
        if (query.skip > 0 && (query.take === undefined || query.take === null)) {
            query.take = 9007199254740992; // Number.MAX_SAFE_INTEGER + 1; // ES6
        }

        var statements = [];
        this.paramNumber = 0;
        
        this.statement = this._newStatement();
        this.statement.sql = this._formatQuery(query).trim();
        statements.push(this.statement);

        if (query.inlineCount === 'allpages' || query.includeTotalCount) {
            this.statement = this._newStatement();
            this.statement.sql = this._formatCountQuery(helpers.formatTableName(this.schemaName, query.table), query).trim();
            statements.push(this.statement);
        }
        
        return statements;
    },
    
    _newStatement: function() {
        return {
            sql : '',
            parameters : [],
            multiple: true
        };
    },

    _formatQuery: function (query) {

        if (this.flavor !== 'sqlite' && query.skip >= 0 && query.take >= 0 && query.skip !== null && query.take !== null) {
            return this._formatPagedQuery(query);
        }
        
        var takeClause = '',
            skipClause = '',
            whereClause = '',
            orderbyClause = '',
            limit = -1,
            formattedSql,
            selection = query.selections ? this._formatSelection(query.selections, query.systemProperties) : '*';
        
        // set the top clause to be the minimumn of the top
        // and result limit values if either has been set.
        var resultLimit = query.resultLimit || Number.MAX_VALUE;
        if (query.take >= 0 && query.take !== null) {
            limit = Math.min(resultLimit, query.take);
        } else if (resultLimit != Number.MAX_VALUE) {
            limit = query.resultLimit;
        }
        
        if (this.flavor !== 'sqlite') {
            if (limit != -1) {
                takeClause = 'TOP ' + limit.toString() + ' ';
            }
        } else {
            takeClause = ' LIMIT ' + limit.toString();
            if (query.skip > 0) {
                skipClause = ' OFFSET ' + query.skip.toString();
            }
        }
        
        var filter = this._formatFilter(query)
        if (filter.length > 0) {
            whereClause = ' WHERE ' + filter;
        }
        
        var ordering = this._formatOrderBy(query);
        if (ordering.length > 0) {
            orderbyClause = ' ORDER BY ' + ordering;
        }

        var tableName = helpers.formatTableName(this.schemaName, query.table);
        
        if (this.flavor !== 'sqlite') {
            formattedSql = _.sprintf("SELECT %s%s FROM %s%s%s", takeClause, selection, tableName, whereClause, orderbyClause);
        } else {
            formattedSql = _.sprintf("SELECT %s FROM %s%s%s%s%s", selection, tableName, whereClause, orderbyClause, takeClause, skipClause);
        }
        
        return formattedSql;
    },

    _formatPagedQuery: function (query) {
        var formattedSql, selection = '',
            aliasedSelection = '';

        if (query.selections) {
            selection = this._formatSelection(query.selections, query.systemProperties);
            aliasedSelection = '[t1].[ROW_NUMBER], ' + this._formatSelection(query.selections, query.systemProperties, '[t1].');
        } else {
            selection = aliasedSelection = "*";
        }

        var filter = this._formatFilter(query, '(1 = 1)');
        var ordering = this._formatOrderBy(query, '[id]');

        // Plug all the pieces into the template to get the paging sql
        var tableName = helpers.formatTableName(this.schemaName, query.table);
        formattedSql = _.sprintf(
            "SELECT %s FROM (SELECT ROW_NUMBER() OVER (ORDER BY %s) AS [ROW_NUMBER], %s " +
            "FROM %s WHERE %s) AS [t1] " +
            "WHERE [t1].[ROW_NUMBER] BETWEEN %d + 1 AND %d + %d " +
            "ORDER BY [t1].[ROW_NUMBER]",
            aliasedSelection, ordering, selection, tableName, filter, query.skip, query.skip, query.take);

        return formattedSql;
    },

    _formatCountQuery: function (table, query) {
        var filter;

        if (query.filters || query.id !== undefined || this.tableConfig.supportsSoftDelete) {
            this.statement.sql = '';
            filter = this._formatFilter(query);
        }

        var sql = 'SELECT COUNT(*) AS [count] FROM ' + table;
        if (filter) {
            sql += ' WHERE ' + filter;
        }
        return sql;
    },

    _formatOrderBy: function (query, defaultOrder) {
        if (!query.ordering) {
            return defaultOrder || '';
        }

        var orderings = parseOData.orderBy(query.ordering),
            order = '',
            self = this;

        orderings.forEach(function (ordering) {
            if (order.length > 0) {
                order += ', ';
            }
            self.statement.sql = '';
            self.visit(ordering.selector);
            if (!ordering.ascending) {
                self.statement.sql += ' DESC';
            }
            order += self.statement.sql;
        });

        return order;
    },

    _formatSelection: function (selection, systemProperties, prefix) {
        systemProperties = (systemProperties || []).map(systemPropertyToColumnName);

        var formattedSelection = '',
            columns = selection.split(',').concat(systemProperties);

        columns.forEach(function (column) {
            var member = column.trim();
            if (formattedSelection.length > 0) {
                formattedSelection += ', ';
            }
            formattedSelection += (prefix || '') + helpers.formatMember(member);
        });

        return formattedSelection;
    },

    _formatFilter: function (query, defaultFilter) {
        // if we already have a parsed filter use it,
        // otherwise parse the filter
        var filterExpr;
        if (query.filters && query.filters.length > 0) {
            filterExpr = parseOData(query.filters);
        }

        if (query.id !== undefined) {
            var id = this.tableConfig.hasStringId ? "'" + query.id.replace(/'/g, "''") + "'" : query.id;
            var idFilterExpr = parseOData(_.sprintf('(id eq %s)', id));

            // append the id filter to any existing filter
            if (filterExpr) {
                filterExpr = new expressions.Binary(filterExpr, idFilterExpr, 'And');
            }
            else {
                filterExpr = idFilterExpr;
            }
        }

        // if soft delete is enabled filter out deleted records
        if (this.tableConfig.softDelete && !query.includeDeleted) {
            var deletedFilter = parseOData(_.sprintf('(__deleted eq false)'));
            if (filterExpr) {
                filterExpr = new expressions.Binary(filterExpr, deletedFilter, 'And');
            }
            else {
                filterExpr = deletedFilter;
            }
        }

        if (!filterExpr) {
            return defaultFilter || '';
        }

        this.statement.sql = '';
        filterExpr = this._finalizeExpression(filterExpr);
        this.visit(filterExpr);

        return this.statement.sql;
    },

    // run the final query translation pipeline on the specified
    // expression, modifying the expression tree as needed
    _finalizeExpression: function (expr) {
        expr = booleanize(expr);
        expr = convertTypes(expr, this.tableConfig);
        return expr;
    },

    visitBinary: function (expr) {
        this.statement.sql += '(';

        var left = null;
        var right = null;

        // modulo requires the dividend to be an integer, monetary or numeric
        // rewrite the expression to convert to numeric, allowing the DB to apply
        // rounding if needed. our default data type for number is float which
        // is incompatible with modulo.
        if (expr.expressionType == 'Modulo') {
            expr.left = new expressions.Convert('numeric', expr.left);
        }

        if (expr.left) {
            left = this.visit(expr.left);
        }

        if (expr.right && (expr.right.value === null)) {
            // inequality expressions against a null literal have a special
            // translation in SQL
            if (expr.expressionType == 'Equal') {
                this.statement.sql += ' IS NULL';
            }
            else if (expr.expressionType == 'NotEqual') {
                this.statement.sql += ' IS NOT NULL';
            }
        }
        else {
            switch (expr.expressionType) {
                case 'Equal':
                    this.statement.sql += ' = ';
                    break;
                case 'NotEqual':
                    this.statement.sql += ' != ';
                    break;
                case 'LessThan':
                    this.statement.sql += ' < ';
                    break;
                case 'LessThanOrEqual':
                    this.statement.sql += ' <= ';
                    break;
                case 'GreaterThan':
                    this.statement.sql += ' > ';
                    break;
                case 'GreaterThanOrEqual':
                    this.statement.sql += ' >= ';
                    break;
                case 'And':
                    this.statement.sql += ' AND ';
                    break;
                case 'Or':
                    this.statement.sql += ' OR ';
                    break;
                case 'Add':
                    this.statement.sql += ' + ';
                    break;
                case 'Subtract':
                    this.statement.sql += ' - ';
                    break;
                case 'Multiply':
                    this.statement.sql += ' * ';
                    break;
                case 'Divide':
                    this.statement.sql += ' / ';
                    break;
                case 'Modulo':
                    this.statement.sql += ' % ';
                    break;
            }

            if (expr.right) {
                right = this.visit(expr.right);
            }
        }

        this.statement.sql += ')';

        if ((left !== expr.left) || (right !== expr.right)) {
            return new expressions.Binary(left, right);
        }

        return expr;
    },

    visitConstant: function (expr) {
        if (expr.value === null) {
            this.statement.sql += 'NULL';
            return expr;
        }

        this.statement.sql += this._createParameter(expr.value);

        return expr;
    },

    visitFloatConstant: function (expr) {
        if (expr.value === null) {
            this.statement.sql += 'NULL';
            return expr;
        }

        this.statement.sql += this._createParameter(expr.value, mssql.FLOAT);

        return expr;
    },

    _createParameter: function (value, type) {
        var parameter = {
            name: 'p' + (++this.paramNumber).toString(),
            pos: this.paramNumber,
            value: value,
            type: type
        };

        this.statement.parameters.push(parameter);

        return '@p' + this.paramNumber.toString();
    },

    visitMember: function (expr) {
        if (typeof expr.member === 'string') {
            this.statement.sql += helpers.formatMember(expr.member);
        }
        else {
            this._formatMappedMember(expr);
        }

        return expr;
    },

    visitUnary: function (expr) {
        if (expr.expressionType == 'Not') {
            this.statement.sql += 'NOT ';
            this.visit(expr.operand);
        }
        else if (expr.expressionType == 'Convert') {
            this.statement.sql += _.sprintf("CONVERT(%s, ", expr.desiredType);
            this.visit(expr.operand);
            this.statement.sql += ')';
        }

        return expr;
    },

    visitFunction: function (expr) {
        if (expr.memberInfo) {
            this._formatMappedFunction(expr);
        }
        return expr;
    },

    _formatMappedFunction: function (expr) {
        if (expr.memberInfo.type == 'string') {
            this._formatMappedStringMember(expr.instance, expr.memberInfo, expr.args);
        }
        else if (expr.memberInfo.type == 'date') {
            this._formatMappedDateMember(expr.instance, expr.memberInfo, expr.args);
        }
        else if (expr.memberInfo.type == 'math') {
            this._formatMappedMathMember(expr.instance, expr.memberInfo, expr.args);
        }
    },

    _formatMappedMember: function (expr) {
        if (expr.member.type == 'string') {
            this._formatMappedStringMember(expr.instance, expr.member, null);
        }
    },

    _formatMappedDateMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'day') {
            this.statement.sql += 'DAY(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'month') {
            this.statement.sql += 'MONTH(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'year') {
            this.statement.sql += 'YEAR(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'hour') {
            this.statement.sql += 'DATEPART(HOUR, ';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'minute') {
            this.statement.sql += 'DATEPART(MINUTE, ';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'second') {
            this.statement.sql += 'DATEPART(SECOND, ';
            this.visit(instance);
            this.statement.sql += ')';
        }
    },

    _formatMappedMathMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'floor') {
            this.statement.sql += 'FLOOR(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (functionName == 'ceiling') {
            this.statement.sql += 'CEILING(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (functionName == 'round') {
            // Use the 'away from zero' midpoint rounding strategy - when
            // a number is halfway between two others, it is rounded toward
            // the nearest number that is away from zero.
            this.statement.sql += 'ROUND(';
            this.visit(instance);
            this.statement.sql += ', 0)';
        }
    },

    _formatMappedStringMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'substringof') {
            this.statement.sql += '(';
            this.visit(instance);

            this.statement.sql += ' LIKE ';

            // form '%' + <arg> + '%'
            this.statement.sql += "('%' + ";
            this.visit(args[0]);
            this.statement.sql += " + '%')";

            this.statement.sql += ')';
        }
        else if (functionName == 'startswith') {
            this.statement.sql += '(';
            this.visit(instance);

            this.statement.sql += ' LIKE ';

            // form '<arg> + '%'
            this.statement.sql += '(';
            this.visit(args[0]);
            this.statement.sql += " + '%')";

            this.statement.sql += ')';
        }
        else if (functionName == 'endswith') {
            this.statement.sql += '(';
            this.visit(instance);

            this.statement.sql += ' LIKE ';

            // form '%' + '<arg>
            this.statement.sql += "('%' + ";
            this.visit(args[0]);
            this.statement.sql += ')';

            this.statement.sql += ')';
        }
        else if (functionName == 'concat') {
            // Rewrite as an string addition with appropriate conversions.
            // Note: due to sql operator precidence, we only need to inject a
            // single conversion - the other will be upcast to string.
            if (!isConstantOfType(args[0], 'string')) {
                args[0] = new expressions.Convert(helpers.getSqlType(''), args[0]);
            } else if (!isConstantOfType(args[1], 'string')) {
                args[1] = new expressions.Convert(helpers.getSqlType(''), args[1]);
            }
            var concat = new expressions.Binary(args[0], args[1], 'Add');
            this.visit(concat);
        }
        else if (functionName == 'tolower') {
            this.statement.sql += 'LOWER(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (functionName == 'toupper') {
            this.statement.sql += 'UPPER(';
            this.visit(instance);
            this.statement.sql += ')';
        }
        else if (functionName == 'length') {
            // special translation since SQL LEN function doesn't
            // preserve trailing spaces
            this.statement.sql += '(LEN(';
            this.visit(instance);
            this.statement.sql += " + 'X') - 1)";
        }
        else if (functionName == 'trim') {
            this.statement.sql += 'LTRIM(RTRIM(';
            this.visit(instance);
            this.statement.sql += '))';
        }
        else if (functionName == 'indexof') {
            this.statement.sql += "(PATINDEX('%' + ";
            this.visit(args[0]);
            this.statement.sql += " + '%', ";
            this.visit(instance);
            this.statement.sql += ') - 1)';
        }
        else if (functionName == 'replace') {
            this.statement.sql += "REPLACE(";
            this.visit(instance);
            this.statement.sql += ", ";
            this.visit(args[0]);
            this.statement.sql += ", ";
            this.visit(args[1]);
            this.statement.sql += ')';
        }
        else if (functionName == 'substring') {
            this.statement.sql += 'SUBSTRING(';
            this.visit(instance);

            this.statement.sql += ", ";
            this.visit(args[0]);
            this.statement.sql += " + 1, ";  // need to add 1 since SQL is 1 based, but OData is zero based

            if (args.length == 1) {
                // Overload not taking an explicit length. The
                // LEN of the entire expression is used in this case
                // which means everything after the start index will
                // be taken.
                this.statement.sql += 'LEN(';
                this.visit(instance);
                this.statement.sql += ')';
            }
            else if (args.length == 2) {
                // overload taking a length
                this.visit(args[1]);
            }

            this.statement.sql += ')';
        }
    }
});

function isConstantOfType(expr, type) {
    return (expr.expressionType == 'Constant') && (typeof expr.value === type);
}

function systemPropertyToColumnName(propertyName) {
    return '__' + propertyName;
}

},{"../../../query/ExpressionVisitor":100,"../../../query/expressions":101,"../../../query/parseOData":103,"../../../utilities/types":106,"../helpers":96,"./booleanize":97,"./convertTypes":98,"mssql":1,"underscore.string":50}],100:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../utilities/types'),
    expressions = require('./expressions');

module.exports = types.defineClass(null, {
    visit: function (expr) {
        return expr.accept(this);
    },

    visitConstant: function (expr) {
        return expr;
    },

    visitFloatConstant: function (expr) {
        return expr;
    },

    visitBinary: function (expr) {
        var left = null;
        var right = null;

        if (expr.left !== null) {
            left = this.visit(expr.left);
        }
        if (expr.right !== null) {
            right = this.visit(expr.right);
        }
        if (left != expr.left || right != expr.right) {
            return new expressions.Binary(left, right, expr.expressionType);
        }

        return expr;
    },

    visitUnary: function (expr) {
        var operand = this.visit(expr.operand);
        if (operand != expr.operand) {
            return new expressions.Unary(operand, expr.expressionType);
        }
        return expr;
    },

    visitMember: function (expr) {
        return expr;
    },

    visitParameter: function (expr) {
        return expr;
    },

    visitFunction: function (expr) {
        var updated = false;

        var instance = expr.instance;
        if (expr.instance) {
            instance = this.visit(expr.instance);
            if (instance != expr.instance) {
                updated = true;
            }
        }

        var args = [expr.args.length],
            i = 0,
            self = this;
        expr.args.forEach(function (arg) {
            var newArg = self.visit(arg);
            args[i++] = arg;
            if (newArg != arg) {
                updated = true;
            }
        });

        if (updated) {
            return new expressions.FunctionCall(instance, expr.memberInfo, args);
        }
        return expr;
    }
});

},{"../utilities/types":106,"./expressions":101}],101:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('../utilities/types');

var Expression = types.defineClass(
    null, {
        accept: function (visitor) {
            return visitor.visit(this);
        }
    },
    null);

module.exports = {
    MappedMemberInfo: types.defineClass(
        function (type, memberName, isStatic, isMethod) {
            this.type = type;
            this.memberName = memberName;
            this.isStatic = isStatic;
            this.isMethod = isMethod;
        }, null, null),

    Constant: types.deriveClass(
        Expression,
        function (value) {
            this.value = value;
            this.expressionType = 'Constant';
        }, {
            accept: function (visitor) {
                return visitor.visitConstant(this);
            }
        },
        null),

    FloatConstant: types.deriveClass(
        Expression,
        function (value) {
            this.value = value;
            this.expressionType = 'FloatConstant';
        }, {
            accept: function (visitor) {
                return visitor.visitFloatConstant(this);
            }
        },
        null),

    Binary: types.deriveClass(
        Expression,
        function (left, right, expressionType) {
            this.left = left;
            this.right = right;
            this.expressionType = expressionType;
        }, {
            accept: function (visitor) {
                return visitor.visitBinary(this);
            }
        },
        null),

    Unary: types.deriveClass(
        Expression,
        function (operand, expressionType) {
            this.operand = operand;
            this.expressionType = expressionType;
        }, {
            accept: function (visitor) {
                return visitor.visitUnary(this);
            }
        },
        null),

    Member: types.deriveClass(
        Expression,
        // member may be either a member name or a MappedMemberInfo
        function (instance, member) {
            this.instance = instance;
            this.member = member;
            this.expressionType = 'MemberAccess';
        }, {
            accept: function (visitor) {
                return visitor.visitMember(this);
            }
        },
        null),

    FunctionCall: types.deriveClass(
        Expression,
        function (instance, memberInfo, args) {
            this.instance = instance;
            this.memberInfo = memberInfo;
            this.args = args;
            this.expressionType = 'Call';
        }, {
            accept: function (visitor) {
                return visitor.visitFunction(this);
            }
        },
        null),

    Parameter: types.defineClass(
        function () {
            this.ExpressionType = 'Parameter';
        }, {
            accept: function (visitor) {
                return visitor.visitParameter(this);
            }
        },
        null),

    Convert: types.deriveClass(
        Expression,
        function (desiredType, operand) {
            this.desiredType = desiredType;
            this.operand = operand;
            this.expressionType = 'Convert';
        }, {
            accept: function (visitor) {
                return visitor.visitUnary(this);
            }
        },
        null)
}

},{"../utilities/types":106}],102:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
/**
@module azure-mobile-apps/query
@description Functionality for creating {@link https://github.com/Azure/queryjs query.js} objects
*/
var Query = require('query.js').Query,
    assert = require('../utilities/assert').argument;

module.exports = {
    /**
    Creates a new query against the specified table
    @param {string} table - Name of the table to query
    */
    create: function (table) {
        assert(table, 'A table name was not specified');
        return new Query(table);
    },
    /**
    Creates a query from an HTTP request object that encapsulates an OData query
    @param {express.Request} req The HTTP request object
    */
    fromRequest: function(req) {
        var url = req.path;
        return Query.Providers.OData.fromOData(
            url.substring(url.lastIndexOf('/') + 1),
            req.query.$filter,
            req.query.$orderby,
            parseInt(req.query.$skip),
            parseInt(req.query.$top),
            req.query.$select,
            req.query.$inlinecount === 'allpages')
    },
    /**
    Converts a query to an object containing OData query information
    @param {module:queryjs/Query} query - The query.js Query object to convert
    */
    toOData: function (query) {
        return Query.Providers.OData.toOData(query)
    }
}

},{"../utilities/assert":104,"query.js":22}],103:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var _ = require('underscore.string'),
    types = require('../utilities/types'),
    strings = require('../utilities/strings'),
    expressions = require('./expressions');

module.exports = function (predicate) {
    return new ODataParser(predicate).parse();
};

module.exports.orderBy = function (ordering) {
    return new ODataParser(ordering).parseOrdering();
};

function ctor(expression) {
    this.keywords = this._createKeywords();

    // define the default root parameter for all member expressions
    this.it = new expressions.Parameter();

    this.text = expression;
    this.textLen = this.text.length;
    this.token = {};
    this._setTextPos(0);
    this._nextToken();
}

var ODataParser = types.defineClass(ctor, {
    parse: function () {
        var expr = this._parseExpression();

        this._validateToken('End', 'Syntax error');
        return expr;
    },

    parseOrdering: function () {
        var orderings = [];
        while (true) {
            var expr = this._parseExpression();
            var ascending = true;
            if (this._tokenIdentifierIs('asc')) {
                this._nextToken();
            }
            else if (this._tokenIdentifierIs('desc')) {
                this._nextToken();
                ascending = false;
            }
            orderings.push({
                selector: expr,
                ascending: ascending
            });
            if (this.token.id != 'Comma') {
                break;
            }
            this._nextToken();
        }
        this._validateToken('End', 'Syntax error');
        return orderings;
    },

    _tokenIdentifierIs: function (id) {
        return this.token.id == 'Identifier' && id == this.token.text;
    },

    _parseExpression: function () {
        return this._parseLogicalOr();
    },

    // 'or' operator
    _parseLogicalOr: function () {
        var left = this._parseLogicalAnd();
        while (this.token.id == 'Or') {
            this._nextToken();
            var right = this._parseLogicalAnd();
            left = new expressions.Binary(left, right, 'Or');
        }
        return left;
    },

    // 'and' operator
    _parseLogicalAnd: function () {
        var left = this._parseComparison();
        while (this.token.id == 'And') {
            this._nextToken();
            var right = this._parseComparison();
            left = new expressions.Binary(left, right, 'And');
        }
        return left;
    },

    _parseComparison: function () {
        var left = this._parseAdditive();
        while (this.token.id == 'Equal' || this.token.id == 'NotEqual' || this.token.id == 'GreaterThan' ||
            this.token.id == 'GreaterThanEqual' || this.token.id == 'LessThan' || this.token.id == 'LessThanEqual') {

            var opId = this.token.id;
            this._nextToken();
            var right = this._parseAdditive();

            switch (opId) {
                case 'Equal':
                    left = new expressions.Binary(left, right, 'Equal');
                    break;
                case 'NotEqual':
                    left = new expressions.Binary(left, right, 'NotEqual');
                    break;
                case 'GreaterThan':
                    left = new expressions.Binary(left, right, 'GreaterThan');
                    break;
                case 'GreaterThanEqual':
                    left = new expressions.Binary(left, right, 'GreaterThanOrEqual');
                    break;
                case 'LessThan':
                    left = new expressions.Binary(left, right, 'LessThan');
                    break;
                case 'LessThanEqual':
                    left = new expressions.Binary(left, right, 'LessThanOrEqual');
                    break;
            }
        }
        return left;
    },

    // 'add','sub' operators
    _parseAdditive: function () {
        var left = this._parseMultiplicative();
        while (this.token.id == 'Add' || this.token.id == 'Sub') {
            var opId = this.token.id;
            this._nextToken();
            var right = this._parseMultiplicative();
            switch (opId) {
                case 'Add':
                    left = new expressions.Binary(left, right, 'Add');
                    break;
                case 'Sub':
                    left = new expressions.Binary(left, right, 'Subtract');
                    break;
            }
        }
        return left;
    },

    // 'mul', 'div', 'mod' operators
    _parseMultiplicative: function () {
        var left = this._parseUnary();
        while (this.token.id == 'Multiply' || this.token.id == 'Divide' ||
                this.token.id == 'Modulo') {
            var opId = this.token.id;
            this._nextToken();
            var right = this._parseUnary();
            switch (opId) {
                case 'Multiply':
                    left = new expressions.Binary(left, right, 'Multiply');
                    break;
                case 'Divide':
                    left = new expressions.Binary(left, right, 'Divide');
                    break;
                case 'Modulo':
                    left = new expressions.Binary(left, right, 'Modulo');
                    break;
            }
        }
        return left;
    },

    // -, 'not' unary operators
    _parseUnary: function () {
        if (this.token.id == 'Minus' || this.token.id == 'Not') {
            var opId = this.token.id;
            var opPos = this.token.pos;
            this._nextToken();
            if (opId == 'Minus' && (this.token.id == 'IntegerLiteral' ||
                this.token.id == 'RealLiteral')) {
                this.token.text = "-" + this.token.text;
                this.token.pos = opPos;
                return this._parsePrimary();
            }

            var expr = this._parseUnary();
            if (opId == 'Minus') {
                expr = new expressions.Unary(expr, 'Negate');
            } else {
                expr = new expressions.Unary(expr, 'Not');
            }
            return expr;
        }
        return this._parsePrimary();
    },

    _parsePrimary: function () {
        var expr = this._parsePrimaryStart();
        while (true) {
            if (this.token.id == 'Dot') {
                this._nextToken();
                expr = this._parseMemberAccess(expr);
            }
            else {
                break;
            }
        }
        return expr;
    },

    _parseMemberAccess: function (instance) {
        var errorPos = this.token.pos;
        var id = this._getIdentifier();
        this._nextToken();
        if (this.token.id == 'OpenParen') {
            var mappedFunction = this._mapFunction(id);
            if (mappedFunction !== null) {
                return this._parseMappedFunction(mappedFunction, errorPos);
            }
            else {
                throw this._parseError(_.sprintf("Unknown identifier '%s'", id), errorPos);
            }
        }
        else {
            return new expressions.Member(instance, id);
        }
    },

    _parseMappedFunction: function (mappedMember, errorPos) {
        var mappedMemberName = mappedMember.memberName;
        var args;
        var instance = null;

        this._beginValidateFunction(mappedMemberName, errorPos);

        if (this.token.id == 'OpenParen') {
            args = this._parseArgumentList();

            this._completeValidateFunction(mappedMemberName, args);

            if (mappedMember.mapParams) {
                mappedMember.mapParams(args);
            }

            // static methods need to include the target
            if (!mappedMember.isStatic) {
                if (args.length === 0) {
                    throw this._parseError(
                        _.sprintf("No applicable method '%s' exists in type '%s'", mappedMember.memberName, mappedMember.type), errorPos);
                }

                instance = args[0];
                args = args.slice(1);
            }
            else {
                instance = null;
            }
        }
        else {
            // if it is a function it should begin with a '('
            throw this._parseError("'(' expected");
        }

        if (mappedMember.isMethod) {
            // a mapped function
            return new expressions.FunctionCall(instance, mappedMember, args);
        }
        else {
            // a mapped Property/Field
            return new expressions.Member(instance, mappedMember);
        }
    },

    _beginValidateFunction: function (functionName, errorPos) {
        if (functionName === 'replace') {
            // Security: nested calls to replace must be prevented to avoid an exploit
            // wherein the client can force the server to allocate arbitrarily large
            // strings.
            if (this.inStringReplace) {
                throw this._parseError("Calls to 'replace' cannot be nested.", errorPos);
            }
            this.inStringReplace = true;
        }
    },

    _completeValidateFunction: function (functionName, functionArgs, errorPos) {
        // validate parameters
        switch (functionName) {
            case 'day':
            case 'month':
            case 'year':
            case 'hour':
            case 'minute':
            case 'second':
            case 'floor':
            case 'ceiling':
            case 'round':
            case 'tolower':
            case 'toupper':
            case 'length':
            case 'trim':
                this._validateFunctionParameters(functionName, functionArgs, 1);
                break;
            case 'substringof':
            case 'startswith':
            case 'endswith':
            case 'concat':
            case 'indexof':
                this._validateFunctionParameters(functionName, functionArgs, 2);
                break;
            case 'replace':
                this._validateFunctionParameters(functionName, functionArgs, 3);
                // Security: we limit the replacement value to avoid an exploit
                // wherein the client can force the server to allocate arbitrarily large
                // strings.
                var replaceArg = functionArgs[2];
                if ((replaceArg.expressionType !== 'Constant') || (replaceArg.value.length > 100)) {
                    throw this._parseError("The third parameter to 'replace' must be a string constant less than 100 in length.", errorPos);
                }
                break;
            case 'substring':
                if (functionArgs.length != 2 && functionArgs.length != 3) {
                    throw new Error("Function 'substring' requires 2 or 3 parameters.");
                }
                break;
        }

        this.inStringReplace = false;
    },

    _validateFunctionParameters: function (functionName, args, expectedArgCount) {
        if (args.length !== expectedArgCount) {
            var error = _.sprintf("Function '%s' requires %d %s",
                functionName, expectedArgCount, (expectedArgCount > 1) ? "parameters." : "parameter.");
            throw new Error(error);
        }
    },

    _parseArgumentList: function () {
        this._validateToken('OpenParen', "'(' expected");
        this._nextToken();
        var args = this.token.id != 'CloseParen' ? this._parseArguments() : [];
        this._validateToken('CloseParen', "')' or ',' expected");
        this._nextToken();
        return args;
    },

    _parseArguments: function () {
        var args = [];
        while (true) {
            args.push(this._parseExpression());
            if (this.token.id != 'Comma') {
                break;
            }
            this._nextToken();
        }
        return args;
    },

    _mapFunction: function (functionName) {
        var mappedMember = this._mapStringFunction(functionName);
        if (mappedMember !== null) {
            return mappedMember;
        }

        mappedMember = this._mapDateFunction(functionName);
        if (mappedMember !== null) {
            return mappedMember;
        }

        mappedMember = this._mapMathFunction(functionName);
        if (mappedMember !== null) {
            return mappedMember;
        }

        return null;
    },

    _mapStringFunction: function (functionName) {
        if (functionName == 'startswith') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'endswith') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'length') {
            return new expressions.MappedMemberInfo('string', functionName, false, false);
        }
        else if (functionName == 'toupper') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'tolower') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'trim') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'substringof') {
            var memberInfo = new expressions.MappedMemberInfo('string', functionName, false, true);
            memberInfo.mapParams = function (args) {
                // reverse the order of arguments for string.Contains
                var tmp = args[0];
                args[0] = args[1];
                args[1] = tmp;
            };
            return memberInfo;
        }
        else if (functionName == 'indexof') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'replace') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'substring') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'trim') {
            return new expressions.MappedMemberInfo('string', functionName, false, true);
        }
        else if (functionName == 'concat') {
            return new expressions.MappedMemberInfo('string', functionName, true, true);
        }

        return null;
    },

    _mapDateFunction: function (functionName) {
        if (functionName == 'day') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        else if (functionName == 'month') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        else if (functionName == 'year') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        if (functionName == 'hour') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        else if (functionName == 'minute') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        else if (functionName == 'second') {
            return new expressions.MappedMemberInfo('date', functionName, false, true);
        }
        return null;
    },

    _mapMathFunction: function (functionName) {
        if (functionName == 'floor') {
            return new expressions.MappedMemberInfo('math', functionName, false, true);
        }
        else if (functionName == 'ceiling') {
            return new expressions.MappedMemberInfo('math', functionName, false, true);
        }
        else if (functionName == 'round') {
            return new expressions.MappedMemberInfo('math', functionName, false, true);
        }
        return null;
    },

    _getIdentifier: function () {
        this._validateToken('Identifier', 'Identifier expected');
        return this.token.text;
    },

    _parsePrimaryStart: function () {
        switch (this.token.id) {
            case 'Identifier':
                return this._parseIdentifier();
            case 'StringLiteral':
                return this._parseStringLiteral();
            case 'IntegerLiteral':
                return this._parseIntegerLiteral();
            case 'RealLiteral':
                return this._parseRealLiteral();
            case 'OpenParen':
                return this._parseParenExpression();
            default:
                throw this._parseError('Expression expected');
        }
    },

    _parseIntegerLiteral: function () {
        this._validateToken('IntegerLiteral');
        var text = this.token.text;

        // parseInt will return the integer portion of the string, and won't
        // error on something like '1234xyz'.
        var value = parseInt(text, 10);
        if (isNaN(value) || (value != text)) {
            throw this._parseError(_.sprintf("Invalid integer literal '%s'", text));
        }

        this._nextToken();
        if (this.token.text.toUpperCase() == 'L') {
            // in JS there is only one type of integer number, so this code is only here
            // to parse the OData 'L/l' correctly
            this._nextToken();
            return new expressions.Constant(value);
        }
        return new expressions.Constant(value);
    },

    _parseRealLiteral: function () {
        this._validateToken('RealLiteral');
        var text = this.token.text;

        var last = text.slice(-1);
        if (last.toUpperCase() == 'F' || last.toUpperCase() == 'M' || last.toUpperCase() == 'D') {
            // in JS there is only one floating point type,
            // so terminating F/f, M/m, D/d have no effect.
            text = text.slice(0, -1);
        }

        var value = parseFloat(text);

        if (isNaN(value) || (value != text)) {
            throw this._parseError(_.sprintf("Invalid real literal '%s'", text));
        }

        this._nextToken();
        return new expressions.FloatConstant(value);
    },

    _parseParenExpression: function () {
        this._validateToken('OpenParen', "'(' expected");
        this._nextToken();
        var e = this._parseExpression();
        this._validateToken('CloseParen', "')' or operator expected");
        this._nextToken();
        return e;
    },

    _parseIdentifier: function () {
        this._validateToken('Identifier');
        var value = this.keywords[this.token.text];
        if (value) {
            // type construction has the format of type'value' e.g. datetime'2001-04-01T00:00:00Z'
            // therefore if the next character is a single quote then we try to
            // interpret this as type construction else its a normal member access
            if (typeof value === 'string' && this.ch == '\'') {
                return this._parseTypeConstruction(value);
            }
            else if (typeof value !== 'string') {  // this is a constant
                this._nextToken();
                return value;
            }
        }

        if (this.it !== null) {
            return this._parseMemberAccess(this.it);
        }

        throw this._parseError(_.sprintf("Unknown identifier '%s'", this.token.text));
    },

    _parseTypeConstruction: function (type) {
        var typeIdentifier = this.token.text;
        var errorPos = this.token.pos;
        this._nextToken();
        var typeExpression = null;

        if (this.token.id == 'StringLiteral') {
            errorPos = this.token.pos;
            var stringExpr = this._parseStringLiteral();
            var literalValue = stringExpr.value;
            var date = null;

            try {
                if (type == 'datetime') {
                    date = strings.parseISODate(literalValue);
                    if (date) {
                        typeExpression = new expressions.Constant(date);
                    }
                }
                else if (type == 'datetimeoffset') {
                    date = strings.parseDateTimeOffset(literalValue);
                    if (date) {
                        typeExpression = new expressions.Constant(date);
                    }
                }
            }
            catch (e) {
                throw this._parseError(e, errorPos);
            }
        }

        if (!typeExpression) {
            throw this._parseError(_.sprintf("Invalid '%s' type creation expression", typeIdentifier), errorPos);
        }

        return typeExpression;
    },

    _parseStringLiteral: function () {
        this._validateToken('StringLiteral');
        // Unwrap string (remove surrounding quotes) and unwrap escaped quotes.
        var s = this.token.text.substr(1, this.token.text.length - 2).replace(/''/g, "'");

        this._nextToken();
        return new expressions.Constant(s);
    },

    _validateToken: function (tokenId, error) {
        if (this.token.id != tokenId) {
            throw this._parseError(error || 'Syntax error');
        }
    },

    _createKeywords: function () {
        return {
            "true": new expressions.Constant(true),
            "false": new expressions.Constant(false),
            "null": new expressions.Constant(null),

            // type keywords
            datetime: 'datetime',
            datetimeoffset: 'datetimeoffset'
        };
    },

    _setTextPos: function (pos) {
        this.textPos = pos;
        this.ch = this.textPos < this.textLen ? this.text[this.textPos] : '\\0';
    },

    _nextToken: function () {
        while (this._isWhiteSpace(this.ch)) {
            this._nextChar();
        }
        var t; // TokenId
        var tokenPos = this.textPos;
        switch (this.ch) {
            case '(':
                this._nextChar();
                t = 'OpenParen';
                break;
            case ')':
                this._nextChar();
                t = 'CloseParen';
                break;
            case ',':
                this._nextChar();
                t = 'Comma';
                break;
            case '-':
                this._nextChar();
                t = 'Minus';
                break;
            case '/':
                this._nextChar();
                t = 'Dot';
                break;
            case '\'':
                var quote = this.ch;
                do {
                    this._nextChar();
                    while (this.textPos < this.textLen && this.ch != quote) {
                        this._nextChar();
                    }

                    if (this.textPos == this.textLen) {
                        throw this._parseError("Unterminated string literal", this.textPos);
                    }
                    this._nextChar();
                }
                while (this.ch == quote);
                t = 'StringLiteral';
                break;
            default:
                if (this._isIdentifierStart(this.ch) || this.ch == '@' || this.ch == '_') {
                    do {
                        this._nextChar();
                    }
                    while (this._isIdentifierPart(this.ch) || this.ch == '_');
                    t = 'Identifier';
                    break;
                }
                if (strings.isDigit(this.ch)) {
                    t = 'IntegerLiteral';
                    do {
                        this._nextChar();
                    }
                    while (strings.isDigit(this.ch));
                    if (this.ch == '.') {
                        t = 'RealLiteral';
                        this._nextChar();
                        this._validateDigit();
                        do {
                            this._nextChar();
                        }
                        while (strings.isDigit(this.ch));
                    }
                    if (this.ch == 'E' || this.ch == 'e') {
                        t = 'RealLiteral';
                        this._nextChar();
                        if (this.ch == '+' || this.ch == '-') {
                            this._nextChar();
                        }
                        this._validateDigit();
                        do {
                            this._nextChar();
                        }
                        while (strings.isDigit(this.ch));
                    }
                    if (this.ch == 'F' || this.ch == 'f' || this.ch == 'M' || this.ch == 'm' || this.ch == 'D' || this.ch == 'd') {
                        t = 'RealLiteral';
                        this._nextChar();
                    }
                    break;
                }
                if (this.textPos == this.textLen) {
                    t = 'End';
                    break;
                }
                throw this._parseError("Syntax error '" + this.ch + "'", this.textPos);
        }
        this.token.id = t;
        this.token.text = this.text.substr(tokenPos, this.textPos - tokenPos);
        this.token.pos = tokenPos;

        this.token.id = this._reclassifyToken(this.token);
    },

    _reclassifyToken: function (token) {
        if (token.id == 'Identifier') {
            if (token.text == "or") {
                return 'Or';
            }
            else if (token.text == "add") {
                return 'Add';
            }
            else if (token.text == "and") {
                return 'And';
            }
            else if (token.text == "div") {
                return 'Divide';
            }
            else if (token.text == "sub") {
                return 'Sub';
            }
            else if (token.text == "mul") {
                return 'Multiply';
            }
            else if (token.text == "mod") {
                return 'Modulo';
            }
            else if (token.text == "ne") {
                return 'NotEqual';
            }
            else if (token.text == "not") {
                return 'Not';
            }
            else if (token.text == "le") {
                return 'LessThanEqual';
            }
            else if (token.text == "lt") {
                return 'LessThan';
            }
            else if (token.text == "eq") {
                return 'Equal';
            }
            else if (token.text == "ge") {
                return 'GreaterThanEqual';
            }
            else if (token.text == "gt") {
                return 'GreaterThan';
            }
        }

        return token.id;
    },

    _nextChar: function () {
        if (this.textPos < this.textLen) {
            this.textPos++;
        }
        this.ch = this.textPos < this.textLen ? this.text[this.textPos] : '\\0';
    },

    _isWhiteSpace: function (ch) {
        return (/\s/).test(ch);
    },

    _validateDigit: function () {
        if (!strings.isDigit(this.ch)) {
            throw this._parseError('Digit expected', this.textPos);
        }
    },

    _parseError: function (error, pos) {
        pos = pos || this.token.pos || 0;
        return new Error(error + ' (at index ' + pos + ')');
    },

    _isIdentifierStart: function (ch) {
        return strings.isLetter(ch);
    },

    _isIdentifierPart: function (ch) {
        if (this._isIdentifierStart(ch)) {
            return true;
        }

        if (strings.isDigit(ch)) {
            return true;
        }

        if (ch == '_' || ch == '-') {
            return true;
        }

        return false;
    }
});

},{"../utilities/strings":105,"../utilities/types":106,"./expressions":101,"underscore.string":50}],104:[function(require,module,exports){
module.exports = {
    argument: function (value, message) {
        if(value === undefined || value === null)
            throw new Error(message);
    }
}

},{}],105:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

// Regex to validate string ids to ensure that it does not include any characters which can be used within a URI
var stringIdValidatorRegex = /([\u0000-\u001F]|[\u007F-\u009F]|["\+\?\\\/\`]|^\.{1,2}$)/;

// Match YYYY-MM-DDTHH:MM:SS.sssZ, with the millisecond (.sss) part optional
// Note: we only support a subset of ISO 8601
var iso8601Regex = /^(\d{4})-(\d{2})-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})(\.(\d{3}))?Z$/;

// Match MS Date format "\/Date(1336003790912-0700)\/"
var msDateRegex = /^\/Date\((-?)(\d+)(([+\-])(\d{2})(\d{2})?)?\)\/$/;

var strings = module.exports = {
    isLetter: function (ch) {
        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
    },

    isDigit: function (ch) {
        return ch >= '0' && ch <= '9';
    },

    isValidStringId: function (id) {
        return !stringIdValidatorRegex.test(id);
    },

    convertDate: function (value) {
        var date = strings.parseISODate(value);
        if (date) {
            return date;
        }

        date = strings.parseMsDate(value);
        if (date) {
            return date;
        }

        return null;
    },

    // attempt to parse the value as an ISO 8601 date (e.g. 2012-05-03T00:06:00.638Z)
    parseISODate: function (value) {
        if (iso8601Regex.test(value)) {
            return strings.parseDateTimeOffset(value);
        }

        return null;
    },

    // parse a date and convert to UTC
    parseDateTimeOffset: function (value) {
        var ms = Date.parse(value);
        if (!isNaN(ms)) {
            return new Date(ms);
        }
        return null;
    },

    // attempt to parse the value as an MS date (e.g. "\/Date(1336003790912-0700)\/")
    parseMsDate: function (value) {
        var match = msDateRegex.exec(value);
        if (match) {
            // Get the ms and offset
            var milliseconds = parseInt(match[2], 10);
            var offsetMinutes = 0;
            if (match[5]) {
                var hours = parseInt(match[5], 10);
                var minutes = parseInt(match[6] || '0', 10);
                offsetMinutes = (hours * 60) + minutes;
            }

            // Handle negation
            if (match[1] === '-') {
                milliseconds = -milliseconds;
            }
            if (match[4] === '-') {
                offsetMinutes = -offsetMinutes;
            }

            var date = new Date();
            date.setTime(milliseconds + offsetMinutes * 60000);
            return date;
        }
        return null;
    },

    parseBoolean: function (bool) {
        if (bool === undefined || bool === null || typeof bool !== 'string') {
            return undefined;
        } else if (bool.toLowerCase() === 'true') {
            return true;
        } else if (bool.toLowerCase() === 'false') {
            return false;
        } else {
            return undefined;
        }
    }
}

},{}],106:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
var types = module.exports = {
    curry: function (fn) {
        var slice = Array.prototype.slice,
            args = slice.call(arguments, 1);
        return function () {
            return fn.apply(null, args.concat(slice.call(arguments)));
        };
    },

    extend: function (target, members) {
        for (var member in members) {
            target[member] = members[member];
        }
        return target;
    },

    defineClass: function (ctor, instanceMembers, classMembers) {
        ctor = ctor || function () { };
        if (instanceMembers) {
            types.extend(ctor.prototype, instanceMembers);
        }
        if (classMembers) {
            types.extend(ctor, classMembers);
        }
        return ctor;
    },

    deriveClass: function (baseClass, ctor, instanceMembers) {
        var basePrototype = baseClass.prototype;
        var prototype = {};
        types.extend(prototype, basePrototype);

        var getPrototype = function (name, fn) {
            return function () {
                var tmp = this._super;
                this._super = basePrototype;
                var ret = fn.apply(this, arguments);
                this._super = tmp;
                return ret;
            };
        };

        if (instanceMembers) {
            for (var name in instanceMembers) {
                // Check if we're overwriting an existing function
                prototype[name] = typeof instanceMembers[name] === 'function' && typeof basePrototype[name] === 'function' ?
                    getPrototype(name, instanceMembers[name]) : instanceMembers[name];
            }
        }

        ctor = ctor ?
            (function (fn) {
                return function () {
                    var tmp = this._super;
                    this._super = basePrototype;
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            })(ctor)
            : function () { };

        ctor.prototype = prototype;
        ctor.prototype.constructor = ctor;
        return ctor;
    },

    classof: function (o) {
        if (o === null) {
            return 'null';
        }
        if (o === undefined) {
            return 'undefined';
        }
        return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
    },

    isArray: function (o) {
        return types.classof(o) === 'array';
    },

    isObject: function (o) {
        return types.classof(o) === 'object';
    },

    isDate: function (o) {
        return types.classof(o) === 'date';
    },

    isFunction: function (o) {
        return types.classof(o) === 'function';
    },

    isString: function (o) {
        return types.classof(o) === 'string';
    },

    isNumber: function (o) {
        return types.classof(o) === 'number';
    },

    isError: function (o) {
        return types.classof(o) === 'error';
    },

    isGuid: function (value) {
        return types.isString(value) && /[a-fA-F\d]{8}-(?:[a-fA-F\d]{4}-){3}[a-fA-F\d]{12}/.test(value);
    },

    isEmpty: function (obj) {
        if (obj === null || obj === undefined) {
            return true;
        }
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
}

},{}],107:[function(require,module,exports){

},{}],108:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : (function () {
      function Bar () {}
      try {
        var arr = new Uint8Array(1)
        arr.foo = function () { return 42 }
        arr.constructor = Bar
        return arr.foo() === 42 && // typed array instances can be augmented
            arr.constructor === Bar && // constructor can be set
            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    })()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":109,"ieee754":110,"is-array":111}],109:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],110:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],111:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],112:[function(require,module,exports){
/*global define:false require:false */
module.exports = (function(){
	// Import Events
	var events = require('events')

	// Export Domain
	var domain = {}
	domain.createDomain = domain.create = function(){
		var d = new events.EventEmitter()

		function emitError(e) {
			d.emit('error', e)
		}

		d.add = function(emitter){
			emitter.on('error', emitError)
		}
		d.remove = function(emitter){
			emitter.removeListener('error', emitError)
		}
		d.bind = function(fn){
			return function(){
				var args = Array.prototype.slice.call(arguments)
				try {
					fn.apply(null, args)
				}
				catch (err){
					emitError(err)
				}
			}
		}
		d.intercept = function(fn){
			return function(err){
				if ( err ) {
					emitError(err)
				}
				else {
					var args = Array.prototype.slice.call(arguments, 1)
					try {
						fn.apply(null, args)
					}
					catch (err){
						emitError(err)
					}
				}
			}
		}
		d.run = function(fn){
			try {
				fn()
			}
			catch (err) {
				emitError(err)
			}
			return this
		};
		d.dispose = function(){
			this.removeAllListeners()
			return this
		};
		d.enter = d.exit = function(){
			return this
		}
		return d
	};
	return domain
}).call(this)
},{"events":113}],113:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],114:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],115:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],116:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],117:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],118:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":117,"_process":116,"inherits":114}],119:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],120:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./JavaScriptNodes":121,"./JavaScriptToQueryVisitor":122,"./PartialEvaluator":125,"dup":16,"esprima":119}],121:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./Node":123,"dup":17}],122:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./JavaScriptNodes":121,"./QueryNodes":127,"./Utilities":128,"dup":18}],123:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./Utilities":128,"dup":19}],124:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./Query":126,"./QueryNodes":127,"./Utilities":128,"dup":20}],125:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./JavaScriptNodes":121,"./Utilities":128,"dup":21}],126:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./JavaScript":120,"./ODataProvider":124,"./QueryNodes":127,"./Utilities":128,"dup":22}],127:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Node":123,"dup":23}],128:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],129:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved
// AzureMobileServices - v2.0.0-beta
// ----------------------------------------------------------------------------

exports.FileVersion = '2.0.0-beta';

exports.Resources = {};

exports.Resources['en-US'] = {
    "Validate_NotNullError"                                 : "{0} cannot be null.",
    "Validate_NotNullOrEmptyError"                          : "{0} cannot be null or empty.",
    "Validate_InvalidId"                                    : "{0} is not valid.",
    "Validate_TypeCheckError"                               : "{0} is expected to be a value of type {1}, not {2}.",
    "Validate_LengthUnexpected"                             : "{0} is expected to have length {1}, not {2}.",
    "Validate_InvalidUserParameter"                         : "{0} contains an invalid user-defined query string parameter: {1}. User-defined query string parameters must not begin with a '$'.",
    "Extensions_DefaultErrorMessage"                        : "Unexpected failure.",
    "Extensions_ConnectionFailureMessage"                   : "Unexpected connection failure.",
    "MobileServiceTable_ReadMismatchedQueryTables"          : "Cannot get the results of a query for table '{1}' via table '{0}'.",
    "MobileServiceTable_InsertIdAlreadySet"                 : "Cannot insert if the {0} member is already set.",
    "MobileServiceLogin_AuthenticationProviderNotSupported" : "Unsupported authentication provider name. Please specify one of {0}.",
    "MobileServiceLogin_LoginErrorResponse"                 : "Cannot start a login operation because login is already in progress.",
    "MobileServiceLogin_InvalidResponseFormat"              : "Invalid format of the authentication response.",
    "MobileServiceLogin_InvalidProvider"                    : "The first parameter must be the name of the autentication provider or a Microsoft Account authentication token.",
    "MobileServiceTable_NotSingleObject"                    : "Could not get object from response {0}.",
    "Push_ConflictWithReservedName"                         : "Template name conflicts with reserved name '{0}'.",
    "Push_InvalidTemplateName"                              : "Template name can't contain ';' or ':'.",
    "Push_NotSupportedXMLFormatAsBodyTemplateWin8"          : "The bodyTemplate is not in accepted XML format. The first node of the bodyTemplate should be Badge\/Tile\/Toast, except for the wns\/raw template, which need to be a valid XML.",
    "Push_BodyTemplateMustBeXml"                            : "Valid XML is required for any template without a raw header.",
    "Push_TagNoCommas"                                      : "Tags must not contain ','."
};
},{}],130:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var PostMessageExchange = require('../Utilities/PostMessageExchange');

exports.supportsCurrentRuntime = function () {
    /// <summary>
    /// Determines whether or not this login UI is usable in the current runtime.
    /// </summary>
    return true;
};

exports.login = function (startUri, endUri, callback) {
    /// <summary>
    /// Displays the login UI and calls back on completion
    /// </summary>

    // Tell the runtime which form of completion signal we are looking for,
    // and which origin should be allowed to receive the result (note that this
    // is validated against whitelist on the server; we are only supplying this
    // origin to indicate *which* of the whitelisted origins to use).
    var completionOrigin = PostMessageExchange.getOriginRoot(window.location.href),
        runtimeOrigin = PostMessageExchange.getOriginRoot(startUri),
        // IE does not support popup->opener postMessage calls, so we have to
        // route the message via an iframe
        useIntermediateIframe = window.navigator.userAgent.indexOf("MSIE") >= 0 || window.navigator.userAgent.indexOf("Trident") >= 0,
        intermediateIframe = useIntermediateIframe && createIntermediateIframeForLogin(runtimeOrigin, completionOrigin),
        completionType = useIntermediateIframe ? "iframe" : "postMessage";

    startUri += startUri.indexOf('?') == -1 ? '?' : '&';
    startUri += "completion_type=" + completionType + "&completion_origin=" + encodeURIComponent(completionOrigin);

    // Browsers don't allow postMessage to a file:// URL (except by setting origin to "*", which is unacceptable)
    // so abort the process early with an explanation in that case.
    if (!(completionOrigin && (completionOrigin.indexOf("http:") === 0 || completionOrigin.indexOf("https:") === 0))) {
        var error = "Login is only supported from http:// or https:// URLs. Please host your page in a web server.";
        callback(error, null);
        return;
    }

    var loginWindow = window.open(startUri, "_blank", "location=no"),
        complete = function(errorValue, oauthValue) {
            // Clean up event handlers, windows, frames, ...
            window.clearInterval(checkForWindowClosedInterval);
            loginWindow.close();
            if (window.removeEventListener) {
                window.removeEventListener("message", handlePostMessage);
            } else {
                // For IE8
                window.detachEvent("onmessage", handlePostMessage);
            }
            if (intermediateIframe) {
                intermediateIframe.parentNode.removeChild(intermediateIframe);
            }
            
            // Finally, notify the caller
            callback(errorValue, oauthValue);
        },
        handlePostMessage = function(evt) {
            // Validate source
            var expectedSource = useIntermediateIframe ? intermediateIframe.contentWindow : loginWindow;
            if (evt.source !== expectedSource) {
                return;
            }

            // Parse message
            var envelope;
            try {
                envelope = JSON.parse(evt.data);
            } catch(ex) {
                // Not JSON - it's not for us. Ignore it and keep waiting for the next message.
                return;
            }

            // Process message only if it's for us
            if (envelope && envelope.type === "LoginCompleted" && (envelope.oauth || envelope.error)) {
                complete(envelope.error, envelope.oauth);
            }
        },
        checkForWindowClosedInterval = window.setInterval(function() {
            // We can't directly catch any "onclose" event from the popup because it's usually on a different
            // origin, but in all the mainstream browsers we can poll for changes to its "closed" property
            if (loginWindow && loginWindow.closed === true) {
                complete("canceled", null);
            }
        }, 250);

    if (window.addEventListener) {
        window.addEventListener("message", handlePostMessage, false);
    } else {
        // For IE8
        window.attachEvent("onmessage", handlePostMessage);
    }
    
    // Permit cancellation, e.g., if the app tries to login again while the popup is still open
    return {
        cancelCallback: function () {
            complete("canceled", null);
            return true; // Affirm that it was cancelled
        }
    };
};

function createIntermediateIframeForLogin(runtimeOrigin, completionOrigin) {
    var frame = document.createElement("iframe");
    frame.name = "zumo-login-receiver"; // loginviaiframe.html specifically looks for this name
    frame.src = runtimeOrigin +
        "/crossdomain/loginreceiver?completion_origin=" + encodeURIComponent(completionOrigin);
    frame.setAttribute("width", 0);
    frame.setAttribute("height", 0);
    frame.style.display = "none";
    document.body.appendChild(frame);
    return frame;
}
},{"../Utilities/PostMessageExchange":144}],131:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

// Note: Cordova is PhoneGap.
// This login UI implementation uses the InAppBrowser plugin,
// to install the plugin use the following command
//   cordova plugin add org.apache.cordova.inappbrowser

var requiredCordovaVersion = { major: 3, minor: 0 };

exports.supportsCurrentRuntime = function () {
    /// <summary>
    /// Determines whether or not this login UI is usable in the current runtime.
    /// </summary>

    // When running application inside of Ripple emulator, InAppBrowser functionality is not supported.
    // We should use Browser popup login method instead.
    return !!currentCordovaVersion() && !isRunUnderRippleEmulator();
};

exports.login = function (startUri, endUri, callback) {
    /// <summary>
    /// Displays the login UI and calls back on completion
    /// </summary>

    // Ensure it's a sufficiently new version of Cordova, and if not fail synchronously so that
    // the error message will show up in the browser console.
    var foundCordovaVersion = currentCordovaVersion(),
        message;

    if (!isSupportedCordovaVersion(foundCordovaVersion)) {
        message = "Not a supported version of Cordova. Detected: " + foundCordovaVersion +
                    ". Required: " + requiredCordovaVersion.major + "." + requiredCordovaVersion.minor;
        throw new Error(message);
    }
    if (!hasInAppBrowser) {
        message = 'A required plugin: "org.apache.cordova.inappbrowser" was not detected.';
        throw new Error(message);
    }

    // Initially we show a page with a spinner. This stays on screen until the login form has loaded.
    var redirectionScript = "<script>location.href = unescape('" + window.escape(startUri) + "')</script>",
        startPage = "data:text/html," + encodeURIComponent(getSpinnerMarkup() + redirectionScript);

    // iOS inAppBrowser issue requires this wrapping
    setTimeout(function () {
        var loginWindow = window.open(startPage, "_blank", "location=no"),
            flowHasFinished = false,
            loadEventHandler = function (evt) {
                if (!flowHasFinished && evt.url.indexOf(endUri) === 0) {
                    flowHasFinished = true;
                    setTimeout(function () {
                        loginWindow.close();
                    }, 500);
                    var result = parseOAuthResultFromDoneUrl(evt.url);
                    callback(result.error, result.oAuthToken);
                }
            };

        // Ideally we'd just use loadstart because it happens earlier, but it randomly skips
        // requests on iOS, so we have to listen for loadstop as well (which is reliable).
        loginWindow.addEventListener('loadstart', loadEventHandler);
        loginWindow.addEventListener('loadstop', loadEventHandler);

        loginWindow.addEventListener('exit', function (evt) {
            if (!flowHasFinished) {
                flowHasFinished = true;
                callback("UserCancelled", null);
            }
        });
    }, 500);
};

function isRunUnderRippleEmulator () {
    // Returns true when application runs under Ripple emulator 
    return window.parent && !!window.parent.ripple;
}

function currentCordovaVersion() {
    // If running inside Cordova, returns a string similar to "3.5.0". Otherwise, returns a falsey value.
    // Note: We can only detect Cordova after its deviceready event has fired, so don't call login until then.
    return window.cordova && window.cordova.version;
}

function isSupportedCordovaVersion(version) {
    var versionParts = currentCordovaVersion().match(/^(\d+).(\d+)./);
    if (versionParts) {
        var major = Number(versionParts[1]),
            minor = Number(versionParts[2]),
            required = requiredCordovaVersion;
        return (major > required.major) ||
               (major === required.major && minor >= required.minor);
    }
    return false;
}

function hasInAppBrowser() {
    return !window.open;
}

function parseOAuthResultFromDoneUrl(url) {
    var successMessage = extractMessageFromUrl(url, "#token="),
        errorMessage = extractMessageFromUrl(url, "#error=");
    return {
        oAuthToken: successMessage ? JSON.parse(successMessage) : null,
        error: errorMessage
    };
}

function extractMessageFromUrl(url, separator) {
    var pos = url.indexOf(separator);
    return pos < 0 ? null : decodeURIComponent(url.substring(pos + separator.length));
}

function getSpinnerMarkup() {
    // The default InAppBrowser experience isn't ideal, as it just shows the user a blank white screen
    // until the login form appears. This might take 10+ seconds during which it looks broken.
    // Also on iOS it's possible for the InAppBrowser to initially show the results of the *previous*
    // login flow if the InAppBrowser was dismissed before completion, which is totally undesirable.
    // To fix both of these problems, we display a simple "spinner" graphic via a data: URL until
    // the current login screen has loaded. We generate the spinner via CSS rather than referencing
    // an animated GIF just because this makes the client library smaller overall.
    var vendorPrefix = "webkitTransform" in document.documentElement.style ? "-webkit-" : "",
        numSpokes = 12,
        spokesMarkup = "";
    for (var i = 0; i < numSpokes; i++) {
        spokesMarkup += "<div style='-prefix-transform: rotateZ(" + (180 + i * 360 / numSpokes) + "deg);" +
                                    "-prefix-animation-delay: " + (0.75 * i / numSpokes) + "s;'></div>";
    }
    return [
        "<!DOCTYPE html><html>",
        "<head><meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1'></head>",
        "<body><div id='spinner'>" + spokesMarkup + "</div>",
        "<style type='text/css'>",
        "    #spinner { position: absolute; top: 50%; left: 50%; -prefix-animation: spinner 10s linear infinite; }",
        "    #spinner > div {",
        "        background: #333; opacity: 0; position: absolute; top: 11px; left: -2px; width: 4px; height: 21px; border-radius: 2px;",
        "        -prefix-transform-origin: 50% -11px; -prefix-animation: spinner-spoke 0.75s linear infinite;",
        "    }",
        "    @-prefix-keyframes spinner { 0% { -prefix-transform: rotateZ(0deg); } 100% { -prefix-transform: rotateZ(-360deg); } }",
        "    @-prefix-keyframes spinner-spoke { 0% { opacity: 0; } 5% { opacity: 1; } 70% { opacity: 0; } 100% { opacity: 0; } }",
        "</style>",
        "</body></html>"
    ].join("").replace(/-prefix-/g, vendorPrefix);
}
},{}],132:[function(require,module,exports){

exports.supportsCurrentRuntime = function () {
    /// <summary>
    /// Determines whether or not this login UI is usable in the current runtime.
    /// </summary>

    return isWebAuthBrokerAvailable();
};

exports.login = function (startUri, endUri, callback) {
    /// <summary>
    /// Displays the login UI and calls back on completion
    /// </summary>

    // Define shortcuts for namespaces
    var windowsWebAuthBroker = Windows.Security.Authentication.Web.WebAuthenticationBroker;
    var noneWebAuthOptions = Windows.Security.Authentication.Web.WebAuthenticationOptions.none;
    var successWebAuthStatus = Windows.Security.Authentication.Web.WebAuthenticationStatus.success;
    var activationKindWebAuthContinuation = Windows.ApplicationModel.Activation.ActivationKind.webAuthenticationBrokerContinuation;

    var webAuthBrokerSuccessCallback = null;
    var webAuthBrokerErrorCallback = null;
    var webAuthBrokerContinuationCallback = null;


    // define callbacks for WebAuthenticationBroker
    webAuthBrokerSuccessCallback = function (result) {
        var error = null;
        var token = null;

        if (result.responseStatus !== successWebAuthStatus) {
            error = result;
        }
        else {
            var callbackEndUri = result.responseData;
            var tokenAsJson = null;
            var i = callbackEndUri.indexOf('#token=');
            if (i > 0) {
                tokenAsJson = decodeURIComponent(callbackEndUri.substring(i + 7));
            }
            else {
                i = callbackEndUri.indexOf('#error=');
                if (i > 0) {
                    error = decodeURIComponent(callbackEndUri.substring(i + 7));
                }
            }

            if (tokenAsJson !== null) {
                try {
                    token = JSON.parse(tokenAsJson);
                }
                catch (e) {
                    error = e;
                }
            }
        }

        callback(error, token);
    };
    webAuthBrokerErrorCallback = function (error) {
        callback(error, null);
    };
    // Continuation callback is used when we're running on WindowsPhone which uses 
    // AuthenticateAndContinue method instead of AuthenticateAsync, which uses different async model
    // Continuation callback need to be assigned to Application's 'activated' event.
    webAuthBrokerContinuationCallback = function (activationArgs) {
        if (activationArgs.detail.kind === activationKindWebAuthContinuation) {
            var result = activationArgs.detail.webAuthenticationResult;
            if (result.responseStatus == successWebAuthStatus) {
                webAuthBrokerSuccessCallback(result);
            } else {
                webAuthBrokerErrorCallback(result);
            }
            WinJS.Application.removeEventListener('activated', webAuthBrokerContinuationCallback);
        }
    };

    if (endUri) {
        var windowsStartUri = new Windows.Foundation.Uri(startUri);
        var windowsEndUri = new Windows.Foundation.Uri(endUri);

        // If authenticateAndContinue method is available, we should use it instead of authenticateAsync
        if (windowsWebAuthBroker.authenticateAndContinue) {
            WinJS.Application.addEventListener('activated', webAuthBrokerContinuationCallback, true);
            windowsWebAuthBroker.authenticateAndContinue(windowsStartUri, windowsEndUri);
        } else {
            windowsWebAuthBroker.authenticateAsync(noneWebAuthOptions, windowsStartUri, windowsEndUri)
                                .done(webAuthBrokerSuccessCallback, webAuthBrokerErrorCallback);
        }
    } else {
        // If no endURI was given, then we'll use the single sign-on overload of the 
        // windowsWebAuthBroker. Single sign-on requires that the application's Package SID 
        // be registered with the Microsoft Azure Mobile Service, but it provides a better 
        // experience as HTTP cookies are supported so that users do not have to
        // login in everytime the application is launched.
        var redirectUri = windowsWebAuthBroker.getCurrentApplicationCallbackUri().absoluteUri;
        var startUriWithRedirect = startUri + "?sso_end_uri=" + encodeURIComponent(redirectUri);
        var windowsStartUriWithRedirect = new Windows.Foundation.Uri(startUriWithRedirect);

        // If authenticateAndContinue method is available, we should use it instead of authenticateAsync
        if (windowsWebAuthBroker.authenticateAndContinue) {
            WinJS.Application.addEventListener('activated', webAuthBrokerContinuationCallback, true);
            windowsWebAuthBroker.authenticateAndContinue(windowsStartUriWithRedirect);
        } else {
            windowsWebAuthBroker.authenticateAsync(noneWebAuthOptions, windowsStartUriWithRedirect)
                                .done(webAuthBrokerSuccessCallback, webAuthBrokerErrorCallback);
        }
    }
};

function isWebAuthBrokerAvailable() {
    // If running on windows8/8.1 or Windows Phone returns true, otherwise false
    return !!(window.Windows &&
        window.Windows.Security &&
        window.Windows.Security.Authentication &&
        window.Windows.Security.Authentication.Web &&
        window.Windows.Security.Authentication.Web.WebAuthenticationBroker);
}

},{}],133:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="Generated\MobileServices.DevIntellisense.js" />

var _ = require('./Utilities/Extensions');
var Validate = require('./Utilities/Validate');
var Platform = require('Platforms/Platform');
var MobileServiceSyncContext = require('./MobileServiceSyncContext').MobileServiceSyncContext;
var MobileServiceSyncTable = require('./MobileServiceSyncTable').MobileServiceSyncTable;
var MobileServiceTable = require('./MobileServiceTable').MobileServiceTable;
var MobileServiceLogin = require('./MobileServiceLogin').MobileServiceLogin;

var Push;
try {
    Push = require('./Push/Push').Push;
} catch (e) { }

var _zumoFeatures = {
    JsonApiCall: "AJ",               // Custom API call, where the request body is serialized as JSON
    GenericApiCall: "AG",            // Custom API call, where the request body is sent 'as-is'
    AdditionalQueryParameters: "QS", // Table or API call, where the caller passes additional query string parameters
    OptimisticConcurrency: "OC",     // Table update / delete call, using Optimistic Concurrency (If-Match headers)
    TableRefreshCall: "RF",          // Refresh table call
    TableReadRaw: "TR",              // Table reads where the caller uses a raw query string to determine the items to be returned
    TableReadQuery: "TQ",            // Table reads where the caller uses a function / query OM to determine the items to be returned
};
var _zumoFeaturesHeaderName = "X-ZUMO-FEATURES";

function MobileServiceClient(applicationUrl, gatewayUrl, applicationKey) {
    /// <summary>
    /// Initializes a new instance of the MobileServiceClient class.
    /// </summary>
    /// <param name="applicationUrl" type="string" mayBeNull="false">
    /// The URL to the Mobile Services application.
    /// </param>
    /// <param name="applicationKey" type="string" mayBeNull="false">
    /// The Mobile Service application's key.
    /// </param>

    Validate.isString(applicationUrl, 'applicationUrl');
    Validate.notNullOrEmpty(applicationUrl, 'applicationUrl');
    Validate.isString(applicationKey, 'applicationKey');

    this.applicationUrl = applicationUrl;
    this.applicationKey = applicationKey || null;
    this.gatewayUrl = gatewayUrl || null;

    var sdkInfo = Platform.getSdkInfo();
    var osInfo = Platform.getOperatingSystemInfo();
    var sdkVersion = sdkInfo.fileVersion.split(".").slice(0, 2).join(".");
    this.version = "ZUMO/" + sdkVersion + " (lang=" + sdkInfo.language + "; " +
                                            "os=" + osInfo.name + "; " +
                                            "os_version=" + osInfo.version + "; " +
                                            "arch=" + osInfo.architecture + "; " +
                                            "version=" + sdkInfo.fileVersion + ")";
    this.currentUser = null;
    this._serviceFilter = null;
    this._login = new MobileServiceLogin(this);

    var _syncContext = new MobileServiceSyncContext(this);

    this.getSyncContext = function() {
        /// <summary>
        /// Returns the associated MobileServiceSyncContext
        /// </summary>

        return _syncContext;
    };

    this.getTable = function (tableName) {
        /// <summary>
        /// Gets a reference to a table and its data operations.
        /// </summary>
        /// <param name="tableName">The name of the table.</param>
        /// <returns>A reference to the table.</returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');
        return new MobileServiceTable(tableName, this);
    };

    this.getSyncTable = function (tableName) {
        /// <summary>
        /// Gets a reference to a sync table and its data operations.
        /// </summary>
        /// <param name="tableName">The name of the table.</param>
        /// <returns>A reference to the sync table.</returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');
		
        return new MobileServiceSyncTable(tableName, this);
    };

    if (Push) {
        this.push = new Push(this, MobileServiceClient._applicationInstallationId);
    }
}

// Export the MobileServiceClient class
exports.MobileServiceClient = MobileServiceClient;

// Define the MobileServiceClient in a namespace (note: this has global effects
// unless the platform we're using chooses to ignore it because exports are
// good enough).
Platform.addToMobileServicesClientNamespace({ MobileServiceClient: MobileServiceClient });

MobileServiceClient.prototype.withFilter = function (serviceFilter) {
    /// <summary>
    /// Create a new MobileServiceClient with a filter used to process all
    /// of its HTTP requests and responses.
    /// </summary>
    /// <param name="serviceFilter" type="Function">
    /// The filter to use on the service.  The signature of a serviceFilter is
    ///    function(request, next, callback)
    ///  where
    ///    next := function(request, callback)
    ///    callback := function(error, response)
    /// </param>
    /// <returns type="MobileServiceClient">
    /// A new MobileServiceClient whose HTTP requests and responses will be
    /// filtered as desired.
    /// </returns>
    /// <remarks>
    /// The Mobile Services HTTP pipeline is a chain of filters composed
    /// together by giving each the next operation which it can invoke
    /// (zero, one, or many times as necessary).  The default continuation
    /// of a brand new MobileServiceClient will just get the HTTP response
    /// for the corresponding request.  Here's an example of a Handle
    /// implementation that will automatically retry a request that times
    /// out.
    ///     function(req, next, callback) {
    ///         next(req, function(err, rsp) {
    ///           if (rsp.statusCode >= 400) {
    ///               next(req, callback);
    ///           } else {
    ///               callback(err, rsp);
    ///           }
    ///         });
    ///     }
    /// Note that because these operations are asynchronous, this sample
    /// filter could end up actually making two HTTP requests before
    /// returning a response to the developer without the developer writing
    /// any special code to handle the situation.
    /// -
    /// Filters are composed just like standard function composition.  If
    /// we had new MobileServiceClient().withFilter(F1).withFilter(F2)
    /// .withFilter(F3), it's conceptually equivalent to saying:
    ///     var response = F3(F2(F1(next(request)));
    /// </remarks>

    Validate.notNull(serviceFilter, 'serviceFilter');

    // Clone the current instance
    var client = new MobileServiceClient(this.applicationUrl, this.gatewayUrl, this.applicationKey);
    client.currentUser = this.currentUser;

    // Chain the service filter with any existing filters
    var existingFilter = this._serviceFilter;
    client._serviceFilter = _.isNull(existingFilter) ?
        serviceFilter :
        function (req, next, callback) {
            // compose existingFilter with next so it can be used as the next
            // of the new serviceFilter
            var composed = function (req, callback) {
                existingFilter(req, next, callback);
            };
            serviceFilter(req, composed, callback);
        };

    return client;
};

MobileServiceClient.prototype._request = function (method, uriFragment, content, ignoreFilters, headers, features, callback) {
    /// <summary>
    /// Perform a web request and include the standard Mobile Services headers.
    /// </summary>
    /// <param name="method" type="string">
    /// The HTTP method used to request the resource.
    /// </param>
    /// <param name="uriFragment" type="String">
    /// URI of the resource to request (relative to the Mobile Services
    /// runtime).
    /// </param>
    /// <param name="content" type="Object">
    /// Optional content to send to the resource.
    /// </param>
    /// <param name="ignoreFilters" type="Boolean" mayBeNull="true">
    /// Optional parameter to indicate if the client filters should be ignored
    /// and the request should be sent directly. Is false by default.
    /// </param>
    /// <param name="headers" type="Object">
    /// Optional request headers
    /// </param>
    /// <param name="features" type="Array">
    /// Codes for features which are used in this request, sent to the server for telemetry.
    /// </param>
    /// <param name="callback" type="function(error, response)">
    /// Handler that will be called on the response.
    /// </param>

    // Account for absent optional arguments
    if (_.isNull(callback) && (typeof features === 'function')) {
        callback = features;
        features = null;
    }

    if (_.isNull(callback) && (typeof headers === 'function')) {
        callback = headers;
        headers = null;
    }

    if (_.isNull(callback) && (typeof ignoreFilters === 'function')) {
        callback = ignoreFilters;
        ignoreFilters = false;
    }
    
    if (_.isNull(callback) && (typeof content === 'function')) {
        callback = content;
        content = null;
    }

    Validate.isString(method, 'method');
    Validate.notNullOrEmpty(method, 'method');
    Validate.isString(uriFragment, 'uriFragment');
    Validate.notNull(uriFragment, 'uriFragment');
    Validate.notNull(callback, 'callback');

    // Create the absolute URI
    var options = { type: method.toUpperCase() };
    if (_.url.isAbsoluteUrl(uriFragment)) {
        options.url = uriFragment;
    } else {
        options.url = _.url.combinePathSegments(this.applicationUrl, uriFragment);
    }

    // Set MobileServices authentication, application, User-Agent and telemetry headers
    options.headers = {};
    if (!_.isNull(headers)) {
        _.extend(options.headers, headers);
    }
    options.headers["X-ZUMO-INSTALLATION-ID"] = MobileServiceClient._applicationInstallationId;
    if (!_.isNullOrEmpty(this.applicationKey)) {
        options.headers["X-ZUMO-APPLICATION"] = this.applicationKey;
    }
    if (this.currentUser && !_.isNullOrEmpty(this.currentUser.mobileServiceAuthenticationToken)) {
        options.headers["X-ZUMO-AUTH"] = this.currentUser.mobileServiceAuthenticationToken;
    }
    if (!_.isNull(MobileServiceClient._userAgent)) {
        options.headers["User-Agent"] = MobileServiceClient._userAgent;
    }
    if (!_.isNullOrEmpty["X-ZUMO-VERSION"]) {
        options.headers["X-ZUMO-VERSION"] = this.version;
    }

    if (_.isNull(options.headers[_zumoFeaturesHeaderName]) && features && features.length) {
        options.headers[_zumoFeaturesHeaderName] = features.join(',');
    }

    // Add any content as JSON
    if (!_.isNull(content)) {
        if (!_.isString(content)) {
            options.data = _.toJson(content);
        } else {
            options.data = content;
        }

        if(!_.hasProperty(options.headers, ['Content-Type','content-type','CONTENT-TYPE','Content-type'])) {
            options.headers['Content-Type'] = 'application/json';
        }
    } else {
        // options.data must be set to null if there is no content or the xhr object
        // will set the content-type to "application/text" for non-GET requests.
        options.data = null;
    }

    // Treat any >=400 status codes as errors.  Also treat the status code 0 as
    // an error (which indicates a connection failure).
    var handler = function (error, response) {
        if (!_.isNull(error)) {
            error = _.createError(error);
        } else if (!_.isNull(response) && (response.status >= 400 || response.status === 0)) {
            error = _.createError(null, response);
            response = null;
        }
        callback(error, response);
    };

    // Make the web request
    if (!_.isNull(this._serviceFilter) && !ignoreFilters) {
        this._serviceFilter(options, Platform.webRequest, handler);
    } else {
        Platform.webRequest(options, handler);
    }
};

MobileServiceClient.prototype.loginWithOptions = Platform.async(
     function (provider, options, callback) {
         /// <summary>
         /// Log a user into a Mobile Services application given a provider name with
         /// given options.
         /// </summary>
         /// <param name="provider" type="String" mayBeNull="false">
         /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google', 
         /// 'windowsazureactivedirectory' (can also use 'aad')
         /// or 'microsoftaccount'.
         /// </param>
         /// <param name="options" type="Object" mayBeNull="true">
         /// Contains additional parameter information, valid values are:
         ///    token: provider specific object with existing OAuth token to log in with
         ///    useSingleSignOn: Only applies to Windows 8 clients.  Will be ignored on other platforms.
         /// Indicates if single sign-on should be used. Single sign-on requires that the 
         /// application's Package SID be registered with the Microsoft Azure Mobile Service, 
         /// but it provides a better experience as HTTP cookies are supported so that users 
         /// do not have to login in everytime the application is launched.
         ///    parameters: Any additional provider specific query string parameters.
         /// </param>
         /// <param name="callback" type="Function" mayBeNull="true">
         /// Optional callback accepting (error, user) parameters.
         /// </param>
         this._login.loginWithOptions(provider, options, callback);
});

MobileServiceClient.prototype.login = Platform.async(
    function (provider, token, useSingleSignOn, callback) {
        /// <summary>
        /// Log a user into a Mobile Services application given a provider name and optional 
        /// authentication token.
        /// </summary>
        /// <param name="provider" type="String" mayBeNull="true">
        /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google', 
        /// 'windowsazureactivedirectory' (can also use 'aad')
        /// or 'microsoftaccount'. If no provider is specified, the 'token' parameter
        /// is considered a Microsoft Account authentication token. If a provider is specified, 
        /// the 'token' parameter is considered a provider-specific authentication token.
        /// </param>
        /// <param name="token" type="Object" mayBeNull="true">
        /// Optional, provider specific object with existing OAuth token to log in with.
        /// </param>
        /// <param name="useSingleSignOn" type="Boolean" mayBeNull="true">
        /// Only applies to Windows 8 clients.  Will be ignored on other platforms.
        /// Indicates if single sign-on should be used. Single sign-on requires that the 
        /// application's Package SID be registered with the Microsoft Azure Mobile Service, 
        /// but it provides a better experience as HTTP cookies are supported so that users 
        /// do not have to login in everytime the application is launched.
        /// </param>
        /// <param name="callback" type="Function" mayBeNull="true">
        /// Optional callback accepting (error, user) parameters.
        /// </param>
        this._login.login(provider, token, useSingleSignOn, callback);
    });

MobileServiceClient.prototype.logout = function () {
    /// <summary>
    /// Log a user out of a Mobile Services application.
    /// </summary>
    this.currentUser = null;
};

MobileServiceClient.prototype.invokeApi = Platform.async(
    function (apiName, options, callback) {   
        /// <summary>
        /// Invokes the specified custom api and returns a response object.
        /// </summary>
        /// <param name="apiName">
        /// The custom api to invoke.
        /// </param>
        /// <param name="options" mayBeNull="true">
        /// Contains additional parameter information, valid values are:
        /// body: The body of the HTTP request.
        /// method: The HTTP method to use in the request, with the default being POST,
        /// parameters: Any additional query string parameters, 
        /// headers: HTTP request headers, specified as an object.
        /// </param>
        /// <param name="callback" type="Function" mayBeNull="true">
        /// Optional callback accepting (error, results) parameters.
        /// </param>

        Validate.isString(apiName, 'apiName');

        // Account for absent optional arguments
        if (_.isNull(callback)) {
            if (typeof options === 'function') {
                callback = options;
                options = null;
            }
        }
        Validate.notNull(callback, 'callback');

        var parameters, method, body, headers;
        if (!_.isNull(options)) {
            parameters = options.parameters;
            if (!_.isNull(parameters)) {
                Validate.isValidParametersObject(options.parameters);
            }

            method = options.method;
            body = options.body;
            headers = options.headers;
        }

        headers = headers || {};

        if (_.isNull(method)) {
            method = "POST";
        }

        // if not specified, default to return results in JSON format
        if (_.isNull(headers.accept)) {
            headers.accept = 'application/json';
        }

        // Construct the URL
        var urlFragment = _.url.combinePathSegments("api", apiName);
        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        var features = [];
        if (!_.isNullOrEmpty(body)) {
            features.push(_.isString(body) ?
                _zumoFeatures.GenericApiCall :
                _zumoFeatures.JsonApiCall);
        }

        if (!_.isNull(parameters)) {
            features.push(_zumoFeatures.AdditionalQueryParameters);
        }

        // Make the request
        this._request(
            method,
            urlFragment,
            body,
            null,
            headers,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    callback(error, null);
                } else {
                    var contentType;
                    if (typeof response.getResponseHeader !== 'undefined') { // (when not using IframeTransport, IE9)
                        contentType = response.getResponseHeader('Content-Type');
                    }

                    // If there was no header / can't get one, try json
                    if (!contentType) {
                        try {
                            response.result = _.fromJson(response.responseText);
                        } catch(e) {
                            // Do nothing, since we don't know the content-type, failing may be ok
                        }
                    } else if (contentType.toLowerCase().indexOf('json') !== -1) {
                        response.result = _.fromJson(response.responseText);
                    }

                    callback(null, response);
                }
            });

    });

function getApplicationInstallationId() {
    /// <summary>
    /// Gets or creates the static application installation ID.
    /// </summary>
    /// <returns type="string">
    /// The application installation ID.
    /// </returns>

    // Get or create a new installation ID that can be passed along on each
    // request to provide telemetry data
    var applicationInstallationId = null;

    // Check if the config settings exist
    var path = "MobileServices.Installation.config";
    var contents = Platform.readSetting(path);
    if (!_.isNull(contents)) {
        // Parse the contents of the file as JSON and pull out the
        // application's installation ID.
        try {
            var config = _.fromJson(contents);
            applicationInstallationId = config.applicationInstallationId;
        } catch (ex) {
            // Ignore any failures (like invalid JSON, etc.) which will allow
            // us to fall through to and regenerate a valid config below
        }
    }

    // If no installation ID was found, generate a new one and save the config
    // settings.  This is pulled out as a separate function because we'll do it
    // even if we successfully read an existing config but there's no
    // installation ID.
    if (_.isNullOrEmpty(applicationInstallationId)) {
        applicationInstallationId = _.createUniqueInstallationId();

        // TODO: How many other settings should we write out as well?
        var configText = _.toJson({ applicationInstallationId: applicationInstallationId });
        Platform.writeSetting(path, configText);
    }

    return applicationInstallationId;
}

/// <summary>
/// Get or set the static _applicationInstallationId by checking the settings
/// and create the value if necessary.
/// </summary>
MobileServiceClient._applicationInstallationId = getApplicationInstallationId();

/// <summary>
/// Get or set the static _userAgent by calling into the Platform.
/// </summary>
MobileServiceClient._userAgent = Platform.getUserAgent();

/// <summary>
/// The features that are sent to the server for telemetry.
/// </summary>
MobileServiceClient._zumoFeatures = _zumoFeatures;

},{"./MobileServiceLogin":134,"./MobileServiceSyncContext":135,"./MobileServiceSyncTable":136,"./MobileServiceTable":137,"./Push/Push":140,"./Utilities/Extensions":143,"./Utilities/Validate":146,"Platforms/Platform":139}],134:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="Generated\MobileServices.DevIntellisense.js" />

var _ = require('./Utilities/Extensions');
var Validate = require('./Utilities/Validate');
var Platform = require('Platforms/Platform');

var loginUrl = "login";
var loginDone = "done";

function MobileServiceLogin(client, ignoreFilters) {
    /// <summary>
    /// Initializes a new instance of the MobileServiceLogin class.
    /// </summary>
    /// <param name="client" type="MobileServiceClient" mayBeNull="false">
    /// Reference to the MobileServiceClient associated with this login.
    /// </param>
    /// <param name="ignoreFilters" type="Boolean" mayBeNull="true">
    /// Optional parameter to indicate if the client filters should be ignored
    /// and requests should be sent directly. Is true by default. This should
    /// only be set to false for testing purposes when filters are needed to intercept
    /// and validate requests and responses.
    /// </param>

    // Account for absent optional arguments
    if (_.isNull(ignoreFilters)) {
        ignoreFilters = true;
    }

    // Validate arguments
    Validate.notNull(client);
    Validate.isObject(client, 'client');

    // Create read/write fields
    this._loginState = { inProcess: false, cancelCallback: null };
    this.ignoreFilters = ignoreFilters;

    // Create get accessors for read-only fields
    this.getMobileServiceClient = function () {
        /// <summary>
        /// Gets the MobileServiceClient associated with this table.
        /// <summary>
        /// <returns type="MobileServiceClient">
        /// The MobileServiceClient associated with this table.
        /// </returns>
        return client;
    };

    this.getLoginInProcess = function () {
        /// <summary>
        /// Indicates if a login is currently in process or not.
        /// <summary>
        /// <returns type="Boolean">
        /// True if a login is in process and false otherwise.
        /// </returns>
        return this._loginState.inProcess;
    };
}

// Export the MobileServiceLogin class
exports.MobileServiceLogin = MobileServiceLogin;

// Define the MobileServiceLogin in a namespace (note: this has global effects
// unless the platform we're using chooses to ignore it because exports are
// good enough).
Platform.addToMobileServicesClientNamespace({ MobileServiceLogin: MobileServiceLogin });

MobileServiceLogin.prototype.loginWithOptions = function (provider, options, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application given a provider name with
    /// given options.
    /// </summary>
    /// <param name="provider" type="String" mayBeNull="false">
    /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google', 
    /// 'windowsazureactivedirectory' (can also use 'aad')
    /// or 'microsoftaccount'.
    /// </param>
    /// <param name="options" type="Object" mayBeNull="true">
    /// Contains additional parameter information, valid values are:
    ///    token: provider specific object with existing OAuth token to log in with
    ///    useSingleSignOn: Only applies to Windows 8 clients.  Will be ignored on other platforms.
    /// Indicates if single sign-on should be used. Single sign-on requires that the 
    /// application's Package SID be registered with the Microsoft Azure Mobile Service, 
    /// but it provides a better experience as HTTP cookies are supported so that users 
    /// do not have to login in everytime the application is launched.
    ///    parameters: Any additional provider specific query string parameters.
    /// </param>
    /// <param name="callback" type="Function" mayBeNull="true">
    /// Optional callback accepting (error, user) parameters.
    /// </param>

    Validate.isString(provider, 'provider');
    Validate.notNull(provider, 'provider');

    if (_.isNull(callback)) {
        if (!_.isNull(options) && typeof options === 'function') {
            callback = options;
            options = null;
        } else {
            Validate.notNull(null, 'callback');
        }
    }    

    // loginWithOptions('a.b.c')
    if (!options && this._isAuthToken(provider)) {
        this.loginWithMobileServiceToken(provider, callback);
    } else {
        // loginWithOptions('facebook', {});
        // loginWithOptions('facebook');
        options = options || {};
        this.loginWithProvider(provider, options.token, options.useSingleSignOn, options.parameters, callback);
    }
};

MobileServiceLogin.prototype.login = function (provider, token, useSingleSignOn, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application given a provider name and optional token object
    /// Microsoft Account authentication token.
    /// </summary>
    /// <param name="provider" type="String" mayBeNull="true">
    /// Optional name of the authentication provider to use; one of 'facebook', 'twitter', 'google',
    /// 'windowsazureactivedirectory' (can also use 'aad'), or 'microsoftaccount'.
    /// </param>
    /// <param name="token" type="Object"  mayBeNull="true">
    /// Optional provider specific object with existing OAuth token to log in with or
    /// a JWT Mobile Services authentication token if the provider is null.
    /// </param>
    /// <param name="useSingleSignOn" type="Boolean" mayBeNull="true">
    /// Only applies to Windows 8 clients.  Will be ignored on other platforms.
    /// Indicates if single sign-on should be used. Single sign-on requires that the 
    /// application's Package SID be registered with the Microsoft Azure Mobile Service, 
    /// but it provides a better experience as HTTP cookies are supported so that users 
    /// do not have to login in everytime the application is launched.
    /// </param>
    /// <param name="callback" type="Function"  mayBeNull="true">
    /// Optional callback accepting (error, user) parameters.
    /// </param>

    // Account for absent optional arguments
    if (_.isNull(callback)) {
        if (!_.isNull(useSingleSignOn) && (typeof useSingleSignOn === 'function')) {
            callback = useSingleSignOn;
            useSingleSignOn = null;
        }
        else if (!_.isNull(token) && (typeof token === 'function')) {
            callback = token;
            useSingleSignOn = null;
            token = null;
        }
    }
    if (_.isNull(useSingleSignOn)) {
        if (_.isBool(token)) {
            useSingleSignOn = token;
            token = null;
        }
        else {
            useSingleSignOn = false;
        }
    }

    // Determine if the provider is actually a Mobile Services authentication token
    if (_.isNull(token) && this._isAuthToken(provider)) {
        token = provider;
        provider = null;
    }

    // Validate parameters; there must be either a provider, a token or both
    if (_.isNull(provider)) {
        Validate.notNull(token);
        Validate.isString(token);
    }
    if (_.isNull(token)) {
        Validate.notNull(provider);
        Validate.isString(provider);
        provider = provider.toLowerCase();
    }

    if (!_.isNull(provider)) {
        if (provider.toLowerCase() === 'windowsazureactivedirectory') {
            // The mobile service REST API uses '/login/aad' for Microsoft Azure Active Directory
            provider = 'aad';
        }
        this.loginWithProvider(provider, token, useSingleSignOn, {}, callback);
    }
    else {
        this.loginWithMobileServiceToken(token, callback);
    }
};

MobileServiceLogin.prototype._isAuthToken = function (value) {
    return value && _.isString(value) && value.split('.').length === 3;
};

MobileServiceLogin.prototype.loginWithMobileServiceToken = function(authenticationToken, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application given an Mobile Service authentication token.
    /// </summary>
    /// <param name="authenticationToken" type="String">
    /// OAuth access token that authenticates the user.
    /// </param>
    /// <param name="callback" type="Function">
    /// Optional callback accepting (error, user) parameters.
    /// </param>

    var self = this;
    var client = self.getMobileServiceClient();

    Validate.isString(authenticationToken, 'authenticationToken');
    Validate.notNullOrEmpty(authenticationToken, 'authenticationToken');

    client._request(
        'POST',
        loginUrl,
        { authenticationToken: authenticationToken },
        self.ignoreFilters,
        function(error, response) { 
            onLoginResponse(error, response, client, callback);
        });
};

MobileServiceLogin.prototype.loginWithProvider = function(provider, token, useSingleSignOn, parameters, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application given a provider name and optional token object.
    /// </summary>
    /// <param name="provider" type="String">
    /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google',
    /// 'windowsazureactivedirectory' (can also use 'aad'), or 'microsoftaccount'.
    /// </param>
    /// <param name="token" type="Object">
    /// Optional, provider specific object with existing OAuth token to log in with.
    /// </param>
    /// <param name="useSingleSignOn" type="Boolean">
    /// Optional, indicates if single sign-on should be used.  Single sign-on requires that the
    /// application's Package SID be registered with the Microsoft Azure Mobile Service, but it
    /// provides a better experience as HTTP cookies are supported so that users do not have to
    /// login in everytime the application is launched. Is false be default.
    /// </param>
    /// <param name="parameters" type="Object">
    /// Any additional provider specific query string parameters. 
    /// </param>
    /// <param name="callback" type="Function">
    /// The callback to execute when the login completes: callback(error, user).
    /// </param>

    // Validate arguments
    Validate.isString(provider, 'provider');
    if (!_.isNull(token)) {
        Validate.isObject(token, 'token');
    }

    // Throw if a login is already in process and is not cancellable
    if (this._loginState.inProcess) {
        var didCancel = this._loginState.cancelCallback && this._loginState.cancelCallback();
        if (!didCancel) {
            throw Platform.getResourceString("MobileServiceLogin_LoginErrorResponse");
        }
    }

    provider = provider.toLowerCase();
    
    // Either login with the token or the platform specific login control.
    if (!_.isNull(token)) {
        loginWithProviderAndToken(this, provider, token, parameters, callback);
    }
    else {
        loginWithLoginControl(this, provider, useSingleSignOn, parameters, callback);
    }
};

function onLoginComplete(error, token, client, callback) {
    /// <summary>
    /// Handles the completion of the login and calls the user's callback with
    /// either a user or an error.
    /// </summary>
    /// <param name="error" type="string" mayBeNull="true">
    /// Optional error that may have occurred during login. Will be null if the
    /// login succeeded and their is a token.
    /// </param>
    /// <param name="token" type="string" mayBeNull="true">
    /// Optional token that represents the logged-in user. Will be null if the
    /// login failed and their is an error.
    /// </param>
    /// <param name="client" type="MobileServiceClient">
    /// The Mobile Service client associated with the login.
    /// </param>
    /// <param name="callback" type="Function" mayBeNull="true">
    /// The callback to execute when the login completes: callback(error, user).
    /// </param>
    var user = null;

    if (_.isNull(error)) {

        // Validate the token
        if (_.isNull(token) ||
            !_.isObject(token) ||
            !_.isObject(token.user) ||
            !_.isString(token.authenticationToken)) {
            error = Platform.getResourceString("MobileServiceLogin_InvalidResponseFormat");
        }
        else {
            // Set the current user on the client and return it in the callback
            client.currentUser = token.user;
            client.currentUser.mobileServiceAuthenticationToken = token.authenticationToken;
            user = client.currentUser;
        }
    }

    if (!_.isNull(callback)) {
        callback(error, user);
    }
}

function onLoginResponse(error, response, client, callback) {
    /// <summary>
    /// Handles the completion of the login HTTP call and calls the user's callback with
    /// either a user or an error.
    /// </summary>
    /// <param name="error" type="string" mayBeNull="true">
    /// Optional error that may have occurred during login. Will be null if the
    /// login succeeded and their is a token.
    /// </param>
    /// <param name="response" type="string" mayBeNull="true">
    /// Optional HTTP login response from the Mobile Service. Will be null if the
    /// login failed and their is an error.
    /// </param>
    /// <param name="client" type="MobileServiceClient">
    /// The Mobile Service client associated with the login.
    /// </param>
    /// <param name="callback" type="Function" mayBeNull="true">
    /// The callback to execute when the login completes: callback(error, user).
    /// </param>

    var mobileServiceToken = null;
    if (_.isNull(error)) {
        try {
            mobileServiceToken = _.fromJson(response.responseText);
        }
        catch (e) {
            error = e;
        }
    }

    onLoginComplete(error, mobileServiceToken, client, callback);
}

function loginWithProviderAndToken(login, provider, token, parameters, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application given a provider name and token object.
    /// </summary>
    /// <param name="login" type="MobileServiceLogin">
    /// The login instance that holds the context used with the login process.
    /// </param>
    /// <param name="provider" type="String">
    /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google', or 
    /// 'microsoftaccount'. The provider should already have been validated.
    /// </param>
    /// <param name="token" type="Object">
    /// Provider specific object with existing OAuth token to log in with.
    /// </param>
    /// <param name="parameters" type="Object">
    /// Any additional provider specific query string parameters.
    /// </param>
    /// <param name="callback" type="Function" mayBeNull="true">
    /// The callback to execute when the login completes: callback(error, user).
    /// </param>

    var client = login.getMobileServiceClient();

    // This design has always been problematic, because the operation can take arbitrarily
    // long and there is no way for the UI to cancel it. We should probably remove this
    // one-at-a-time restriction.
    login._loginState = { inProcess: true, cancelCallback: null };

    var url = loginUrl + '/' + provider;
    if (!_.isNull(parameters)) {
        var queryString = _.url.getQueryString(parameters);
        url = _.url.combinePathAndQuery(url, queryString);
    }

    // Invoke the POST endpoint to exchange provider-specific token for a 
    // Microsoft Azure Mobile Services token
    client._request(
        'POST',
        url,
        token,
        login.ignoreFilters,
        function (error, response) {
            login._loginState = { inProcess: false, cancelCallback: null };
            onLoginResponse(error, response, client, callback);
        });
}

function loginWithLoginControl(login, provider, useSingleSignOn, parameters, callback) {
    /// <summary>
    /// Log a user into a Mobile Services application using a platform specific
    /// login control that will present the user with the given provider's login web page.
    /// </summary>
    /// <param name="login" type="MobileServiceLogin">
    /// The login instance that holds the context used with the login process.
    /// </param>
    /// <param name="provider" type="String">
    /// Name of the authentication provider to use; one of 'facebook', 'twitter', 'google', or 'microsoftaccount'.
    /// </param>
    /// <param name="useSingleSignOn" type="Boolean">
    /// Optional, indicates if single sign-on should be used.  Single sign-on requires that the
    /// application's Package SID be registered with the Microsoft Azure Mobile Service, but it
    /// provides a better experience as HTTP cookies are supported so that users do not have to
    /// login in everytime the application is launched. Is false be default.
    /// </param>
    /// <param name="parameters" type="Object">
    /// Any additional provider specific query string parameters.
    /// </param>
    /// <param name="callback" type="Function"  mayBeNull="true">
    /// The callback to execute when the login completes: callback(error, user).
    /// </param>

    var client = login.getMobileServiceClient();
    var startUri = _.url.combinePathSegments(
        client.gatewayUrl || client.applicationUrl,
        loginUrl,
        provider);
    var endUri = null;

    if (!_.isNull(parameters)) {
        var queryString = _.url.getQueryString(parameters);
        startUri = _.url.combinePathAndQuery(startUri, queryString);
    }

    // If not single sign-on, then we need to construct a non-null end uri.
    if (!useSingleSignOn) {
        endUri = _.url.combinePathSegments(
            client.gatewayUrl || client.applicationUrl,
            loginUrl,
            loginDone);
    }
    
    login._loginState = { inProcess: true, cancelCallback: null }; // cancelCallback gets set below

    // Call the platform to launch the login control, capturing any
    // 'cancel' callback that it returns
    var platformResult = Platform.login(
        startUri,
        endUri,
        function (error, mobileServiceToken) {
            login._loginState = { inProcess: false, cancelCallback: null };
            onLoginComplete(error, mobileServiceToken, client, callback);
        });
    
    if (login._loginState.inProcess && platformResult && platformResult.cancelCallback) {
        login._loginState.cancelCallback = platformResult.cancelCallback;
    }
}

},{"./Utilities/Extensions":143,"./Utilities/Validate":146,"Platforms/Platform":139}],135:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="Generated\MobileServices.DevIntellisense.js" />

var Validate = require('./Utilities/Validate');
var Platform = require('Platforms/Platform');
var _ = require('./Utilities/Extensions');

function MobileServiceSyncContext(client) {
    /// <summary>
    /// Creates an instance of the MobileServiceSyncContext class
    /// </summary>
    /// <param name="client" type="MobileServiceClient" mayBeNull="false">
    /// The MobileServiceClient used to make requests.
    /// </param>

    Validate.notNull(client, 'client');

    var _store;

    this.initialize = function (store) {
        /// <summary>
        /// Initializes the sync context with an instance of the store to be used
        /// </summary>

        Validate.notNull(store);

        _store = store;
    };

    // TODO(shrirs): Add tracking operations to the operations table for insert/update/delete
    this.insert = function (tableName, instance) {
        /// <summary>
        /// Insert a new object into the given sync table.
        /// </summary>
        /// <param name="tableName" type="string">
        /// Name of the sync table in which the object is to be inserted
        /// </param>
        /// <param name="instance" type="Object">
        /// The object to be inserted into the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the inserted object when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(instance, 'instance');
        Validate.notNull(instance.id, 'instance.id'); //TODO(shrirs): instance.id is a valid scenario, handle it

        Validate.notNull(_store, '_store');

        return _store.lookup(tableName, instance.id).then(function(result) {
            if (result !== null) {
                throw "An object with the same ID already exists in the table";
            }

            _store.upsert(tableName, instance);
        }).then(function() {
            return instance;
        });
    };

    this.update = function (tableName, instance) {
        /// <summary>
        /// Update an object in the given sync table.
        /// </summary>
        /// <param name="tableName" type="string">
        /// Name of the sync table in which the object is to be updated
        /// </param>
        /// <param name="instance" type="Object">
        /// The object to be updated
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(instance, 'instance');
        Validate.notNull(instance.id, 'instance.id');

        Validate.notNull(_store, '_store');

        return _store.upsert(tableName, instance);
    };

    this.lookup = function (tableName, id) {
        /// <summary>
        /// Gets an object from the given sync table.
        /// </summary>
        /// <param name="tableName" type="string">
        /// Name of the sync table to be used for performing the object lookup
        /// </param>
        /// <param name="id" type="string">
        /// The id of the object to get from the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the looked up object when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(id, 'id');

        Validate.notNull(_store, '_store');

        return _store.lookup(tableName, id);
    };

    this.del = function (tableName, instance) {
        /// <summary>
        /// Delete an object from the given sync table
        /// </summary>
        /// <param name="tableName" type="string">
        /// Name of the sync table to delete the object from
        /// </param>
        /// <param name="instance" type="Object">
        /// The object to delete from the sync table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(instance);
        Validate.notNull(instance.id);

        return _store.del(tableName, instance);
    };

    this.read = function (query) {
        /// <summary>
        /// Read a local table
        /// </summary>
        /// <param name="query" type="Object">
        /// A QueryJS object representing the query to be performed while reading the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the read results when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        Validate.notNull(query, 'query');
        Validate.isObject(query, 'query');

        return _store.read(query);
    };
}

exports.MobileServiceSyncContext = MobileServiceSyncContext;

},{"./Utilities/Extensions":143,"./Utilities/Validate":146,"Platforms/Platform":139}],136:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="Generated\MobileServices.DevIntellisense.js" />

var Validate = require('./Utilities/Validate');
var Platform = require('Platforms/Platform');
var Query = require('query.js/lib/Query').Query;

function MobileServiceSyncTable(tableName, client) {
    /// <summary>
    /// Creates an instance of the MobileServiceSyncTable class.
    /// </summary>
    /// <param name="tableName" type="String">
    /// Name of the table.
    /// </param>
    /// <param name="client" type="MobileServiceClient">
    /// The MobileServiceClient used to make requests.
    /// </param>

    Validate.isString(tableName, 'tableName');
    Validate.notNullOrEmpty(tableName, 'tableName');

    Validate.notNull(client, 'client');

    this.getTableName = function () {
        /// <summary>
        /// Gets the name of the table.
        /// </summary>
        /// <returns type="String">The name of the table.</returns>

        return tableName;
    };

    this.getClient = function () {
        /// <summary>
        /// Gets the MobileServiceClient associated with this table.
        /// </summary>
        /// <returns type="MobileServiceClient">
        /// The MobileServiceClient associated with this table.
        /// </returns>

        return client;
    };

    this.insert = function (instance) {
        /// <summary>
        /// Insert a new object into the sync table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The object to insert into the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the inserted object when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        return client.getSyncContext().insert(tableName, instance);
    };

    this.update = function (instance) {
        /// <summary>
        /// Update an object in the sync table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The object to update
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        return client.getSyncContext().update(tableName, instance);
    };

    this.lookup = function (id) {
        /// <summary>
        /// Gets an object from the sync table.
        /// </summary>
        /// <param name="id" type="string">
        /// The id of the object to get from the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the looked up object when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        return client.getSyncContext().lookup(tableName, id);
    };

    this.del = function (instance) {
        /// <summary>
        /// Delete an object from the sync table
        /// </summary>
        /// <param name="instance" type="Object">
        /// The instance to delete from the sync table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        return client.getSyncContext().del(tableName, instance);
    };

    this._read = function (query) {
        return client.getSyncContext().read(query);
    };

    this.read = function (query) {
        /// <summary>
        /// Read the sync table
        /// </summary>
        /// <param name="query" type="Object">
        /// A QueryJS object representing the query to be performed while reading the table.
        /// This parameter is optional and can be skipped to read the entire table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the read results when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        if (query === undefined) {
            query = new Query(tableName);
        }

        return this._read(query);
    };
}

// Copy select Query operators to MobileServiceSyncTable so queries can be created
// compactly.  We'll just add them to the MobileServiceSyncTable prototype and then
// forward on directly to a new Query instance.
var queryOperators =
    ['where', 'select', 'orderBy', 'orderByDescending', 'skip', 'take', 'includeTotalCount'];

var copyOperator = function (operator) {
    MobileServiceSyncTable.prototype[operator] = function () {
        /// <summary>
        /// Creates a new query.
        /// </summary>

        // Create a query associated with this table
        var table = this;
        var query = new Query(table.getTableName());

        // Add a .read() method on the query which will execute the query.
        // This method is defined here per query instance because it's
        // implicitly tied to the table.
        query.read = function () {
            return table._read(query);
        };

        // Invoke the query operator on the newly created query
        return query[operator].apply(query, arguments);
    };
};

var i = 0;
for (; i < queryOperators.length; i++) {
    // Avoid unintended closure capture
    copyOperator(queryOperators[i]);
}

// Export the MobileServiceSyncTable class
exports.MobileServiceSyncTable = MobileServiceSyncTable;

},{"./Utilities/Validate":146,"Platforms/Platform":139,"query.js/lib/Query":126}],137:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="Generated\MobileServices.DevIntellisense.js" />

var _ = require('./Utilities/Extensions');
var Validate = require('./Utilities/Validate');
var Platform = require('Platforms/Platform');
var Query = require('query.js/lib/Query').Query;

// Name of the reserved Mobile Services ID member.
var idPropertyName = "id";

// The route separator used to denote the table in a uri like
// .../{app}/collections/{coll}.
var tableRouteSeperatorName = "tables";
var idNames = ["ID", "Id", "id", "iD"];
var nextLinkRegex = /^(.*?);\s*rel\s*=\s*(\w+)\s*$/;

var MobileServiceSystemProperties = {
    None: 0,
    CreatedAt: 1,
    UpdatedAt: 2,
    Version: 4,
    All: 0xFFFF
};

var MobileServiceSystemColumns = {
    CreatedAt: "__createdAt",
    UpdatedAt: "__updatedAt",
    Version: "__version"
};

Platform.addToMobileServicesClientNamespace({
    MobileServiceTable:
        {
            SystemProperties: MobileServiceSystemProperties
        }
});

function MobileServiceTable(tableName, client) {
    /// <summary>
    /// Initializes a new instance of the MobileServiceTable class.
    /// </summary>
    /// <param name="tableName" type="String">
    /// Name of the table.
    /// </param>
    /// <param name="client" type="MobileServiceClient" mayBeNull="false">
    /// The MobileServiceClient used to make requests.
    /// </param>

    this.getTableName = function () {
        /// <summary>
        /// Gets the name of the table.
        /// </summary>
        /// <returns type="String">The name of the table.</returns>
        return tableName;
    };

    this.getMobileServiceClient = function () {
        /// <summary>
        /// Gets the MobileServiceClient associated with this table.
        /// </summary>
        /// <returns type="MobileServiceClient">
        /// The MobileServiceClient associated with this table.
        /// </returns>
        return client;
    };

    this.systemProperties = 0;
}

// Export the MobileServiceTable class
exports.MobileServiceTable = MobileServiceTable;

// We have an internal _read method using callbacks since it's used by both
// table.read(query) and query.read().
MobileServiceTable.prototype._read = function (query, parameters, callback) {
    /// <summary>
    /// Query a table.
    /// </summary>
    /// <param name="query" type="Object" mayBeNull="true">
    /// The query to execute.  It can be null or undefined to get the entire
    /// collection.
    /// </param>
    /// <param name="parameters" type="Object" mayBeNull="true">
    /// An object of user-defined parameters and values to include in the request URI query string.
    /// </param>
    /// <param name="callback" type="Function">
    /// The callback to invoke when the query is complete.
    /// </param>

    // Account for absent optional arguments
    if (_.isNull(callback))
    {
        if (_.isNull(parameters) && (typeof query === 'function')) {
            callback = query;
            query = null;
            parameters = null;
        } else if (typeof parameters === 'function') {
            callback = parameters;
            parameters = null;
            if (!_.isNull(query) && _.isObject(query)) {
                // This 'query' argument could be either the query or the user-defined 
                // parameters object since both are optional.  A query is either (a) a simple string 
                // or (b) an Object with an toOData member. A user-defined parameters object is just 
                // an Object.  We need to detect which of these has been passed in here.
                if (!_.isString(query) && _.isNull(query.toOData)) {
                    parameters = query;
                    query = null;
                }
            }
        }
    }

    // Validate the arguments
    if (query && _.isString(query)) {
        Validate.notNullOrEmpty(query, 'query');
    }
    if (!_.isNull(parameters)) {
        Validate.isValidParametersObject(parameters, 'parameters');
    }
    Validate.notNull(callback, 'callback');

    // Get the query string
    var tableName = this.getTableName();
    var queryString = null;
    var projection = null;
    var features = [];
    if (_.isString(query)) {
        queryString = query;
        if (!_.isNullOrEmpty(query)) {
            features.push(WindowsAzure.MobileServiceClient._zumoFeatures.TableReadRaw);
        }
    } else if (_.isObject(query) && !_.isNull(query.toOData)) {
        if (query.getComponents) {
            features.push(WindowsAzure.MobileServiceClient._zumoFeatures.TableReadQuery);
            var components = query.getComponents();
            projection = components.projection;
            if (components.table) {
                // If the query has a table name, make sure it's compatible with
                // the table executing the query
                
                if (tableName !== components.table) {
                    var message = _.format(Platform.getResourceString("MobileServiceTable_ReadMismatchedQueryTables"), tableName, components.table);
                    callback(_.createError(message), null);
                    return;
                }

                // The oDataQuery will include the table name; we need to remove
                // because the url fragment already includes the table name.
                var oDataQuery = query.toOData();
                queryString = oDataQuery.replace(new RegExp('^/' + components.table), '');
            }
        }
    }

    addQueryParametersFeaturesIfApplicable(features, parameters);

    // Add any user-defined query string parameters
    parameters = addSystemProperties(parameters, this.systemProperties, queryString);
    if (!_.isNull(parameters)) {
        var userDefinedQueryString = _.url.getQueryString(parameters);
        if (!_.isNullOrEmpty(queryString)) {
            queryString += '&' + userDefinedQueryString;
        }
        else {
            queryString = userDefinedQueryString;
        }
    }
    
    // Construct the URL
    var urlFragment = queryString;
    if (!_.url.isAbsoluteUrl(urlFragment)) {
        urlFragment = _.url.combinePathSegments(tableRouteSeperatorName, tableName);
        if (!_.isNull(queryString)) {
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }
    }

    // Make the request
    this.getMobileServiceClient()._request(
        'GET',
        urlFragment,
        null,
        false,
        null,
        features,
        function (error, response) {
            var values = null;
            if (_.isNull(error)) {
                // Parse the response
                values = _.fromJson(response.responseText);

                // If the values include the total count, we'll attach that
                // directly to the array
                if (values &&
                    !Array.isArray(values) &&
                    typeof values.count !== 'undefined' &&
                    typeof values.results !== 'undefined') {
                    // Create a new total count property on the values array
                    values.results.totalCount = values.count;
                    values = values.results;
                }

                // If we have a projection function, apply it to each item
                // in the collection
                if (projection !== null) {
                    var i = 0;
                    for (i = 0; i < values.length; i++) {
                        values[i] = projection.call(values[i]);
                    }
                }

                // Grab link header when possible
                if (Array.isArray(values) && response.getResponseHeader && _.isNull(values.nextLink)) {
                    try {
                        var link = response.getResponseHeader('Link');
                        if (!_.isNullOrEmpty(link)) {
                            var result = nextLinkRegex.exec(link);

                            // Only add nextLink when relation is next
                            if (result && result.length === 3 && result[2] == 'next') {
                                values.nextLink = result[1];
                            }
                        }
                    } catch (ex) {
                        // If cors doesn't allow us to access the Link header
                        // Just continue on without it
                    }
                }
            }
            callback(error, values);
        });
};

MobileServiceTable.prototype.read = Platform.async(MobileServiceTable.prototype._read);

MobileServiceTable.prototype.insert = Platform.async(
    function (instance, parameters, callback) {
        /// <summary>
        /// Insert a new object into a table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The instance to insert into the table.
        /// </param>
        /// <param name="parameters" type="Object" mayBeNull="true">
        /// An object of user-defined parameters and values to include in the request URI query string.
        /// </param>
        /// <param name="callback" type="Function">
        /// The callback to invoke when the insert is complete.
        /// </param>

        // Account for absent optional arguments
        if (_.isNull(callback) && (typeof parameters === 'function')) {
            callback = parameters;
            parameters = null;
        }

        // Validate the arguments
        Validate.notNull(instance, 'instance');
        if (!_.isNull(parameters)) {
            Validate.isValidParametersObject(parameters);
        }
        Validate.notNull(callback, 'callback');

        // Integer Ids can not have any Id set
        for (var i in idNames) {
            var id = instance[idNames[i]];

            if (!_.isNullOrZero(id)) {
                if (_.isString(id)) {
                    // String Id's are allowed iif using 'id'
                    if (idNames[i] !== idPropertyName) {
                        throw _.format(
                            Platform.getResourceString("MobileServiceTable_InsertIdAlreadySet"),
                            idPropertyName);
                    } else {
                        Validate.isValidId(id, idPropertyName);
                    }
                } else {
                    throw _.format(
                        Platform.getResourceString("MobileServiceTable_InsertIdAlreadySet"),
                        idPropertyName);
                }
            }
        }

        var features = addQueryParametersFeaturesIfApplicable([], parameters);

        // Construct the URL
        var urlFragment = _.url.combinePathSegments(tableRouteSeperatorName, this.getTableName());
        parameters = addSystemProperties(parameters, this.systemProperties);
        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        // Make the request
        this.getMobileServiceClient()._request(
            'POST',
            urlFragment,
            instance,
            false,
            null,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    callback(error, null);
                } else {
                    var result = getItemFromResponse(response);
                    result = Platform.allowPlatformToMutateOriginal(instance, result);
                    callback(null, result);
                }
            });
    });

MobileServiceTable.prototype.update = Platform.async(
    function (instance, parameters, callback) {
        /// <summary>
        /// Update an object in a given table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The instance to update in the table.
        /// </param>
        /// <param name="parameters" type="Object" mayBeNull="true">
        /// An object of user-defined parameters and values to include in the request URI query string.
        /// </param>
        /// <param name="callback" type="Function">
        /// The callback to invoke when the update is complete.
        /// </param>
        var version,
            headers = {},
            features = [],
            serverInstance;

        // Account for absent optional arguments
        if (_.isNull(callback) && (typeof parameters === 'function')) {
            callback = parameters;
            parameters = null;
        }

        // Validate the arguments
        Validate.notNull(instance, 'instance');
        Validate.isValidId(instance[idPropertyName], 'instance.' + idPropertyName);
        if (!_.isNull(parameters)) {
            Validate.isValidParametersObject(parameters, 'parameters');
        }
        Validate.notNull(callback, 'callback');

        if (_.isString(instance[idPropertyName])) {
            version = instance.__version;
            serverInstance = removeSystemProperties(instance);
        } else {
            serverInstance = instance;
        }

        if (!_.isNullOrEmpty(version)) {
            headers['If-Match'] = getEtagFromVersion(version);
            features.push(WindowsAzure.MobileServiceClient._zumoFeatures.OptimisticConcurrency);
        }

        features = addQueryParametersFeaturesIfApplicable(features, parameters);
        parameters = addSystemProperties(parameters, this.systemProperties);

        // Construct the URL
        var urlFragment =  _.url.combinePathSegments(
                tableRouteSeperatorName,
                this.getTableName(),
                encodeURIComponent(instance[idPropertyName].toString()));
        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        // Make the request
        this.getMobileServiceClient()._request(
            'PATCH',
            urlFragment,
            serverInstance,
            false,
            headers,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    setServerItemIfPreconditionFailed(error);
                    callback(error);
                } else {
                    var result = getItemFromResponse(response);
                    result = Platform.allowPlatformToMutateOriginal(instance, result);
                    callback(null, result);
                }
            });
    });

MobileServiceTable.prototype.refresh = Platform.async(
    function (instance, parameters, callback) {
        /// <summary>
        ///  Refresh the current instance with the latest values from the
        ///  table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The instance to refresh.
        /// </param>
        /// <param name="parameters" type="Object" mayBeNull="true">
        /// An object of user-defined parameters and values to include in the request URI query string.
        /// </param>
        /// <param name="callback" type="Function">
        /// The callback to invoke when the refresh is complete.
        /// </param>

        // Account for absent optional arguments
        if (_.isNull(callback) && (typeof parameters === 'function')) {
            callback = parameters;
            parameters = null;
        }

        // Validate the arguments
        Validate.notNull(instance, 'instance');
        if (!_.isValidId(instance[idPropertyName], idPropertyName))
        {
            if (typeof instance[idPropertyName] === 'string' && instance[idPropertyName] !== '') {
                throw _.format(Platform.getResourceString("Validate_InvalidId"), idPropertyName);
            } else {
                callback(null, instance);
            }
            return;
        }

        if (!_.isNull(parameters)) {
            Validate.isValidParametersObject(parameters, 'parameters');
        }
        Validate.notNull(callback, 'callback');

        // Construct the URL
        var urlFragment = _.url.combinePathSegments(
                tableRouteSeperatorName,
                this.getTableName());

        if (typeof instance[idPropertyName] === 'string') {
            var id = encodeURIComponent(instance[idPropertyName]).replace(/\'/g, '%27%27');
            urlFragment = _.url.combinePathAndQuery(urlFragment, "?$filter=id eq '" + id + "'");
        } else {
            urlFragment = _.url.combinePathAndQuery(urlFragment, "?$filter=id eq " + encodeURIComponent(instance[idPropertyName].toString()));
        }

        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        var features = [WindowsAzure.MobileServiceClient._zumoFeatures.TableRefreshCall];
        features = addQueryParametersFeaturesIfApplicable(features, parameters);

        // Make the request
        this.getMobileServiceClient()._request(
            'GET',
            urlFragment,
            instance,
            false,
            null,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    callback(error, null);
                } else {
                    var result = _.fromJson(response.responseText);
                    if (Array.isArray(result)) {
                        result = result[0]; //get first object from array
                    }

                    if (!result) {
                        var message =_.format(
                            Platform.getResourceString("MobileServiceTable_NotSingleObject"),
                            idPropertyName);
                        callback(_.createError(message), null);
                    }

                    result = Platform.allowPlatformToMutateOriginal(instance, result);
                    callback(null, result);
                }
            });
    });

MobileServiceTable.prototype.lookup = Platform.async(
    function (id, parameters, callback) {
        /// <summary>
        /// Gets an instance from a given table.
        /// </summary>
        /// <param name="id" type="Number" integer="true">
        /// The id of the instance to get from the table.
        /// </param>
        /// <param name="parameters" type="Object" mayBeNull="true">
        /// An object of user-defined parameters and values to include in the request URI query string.
        /// </param>
        /// <param name="callback" type="Function">
        /// The callback to invoke when the lookup is complete.
        /// </param>

        // Account for absent optional arguments
        if (_.isNull(callback) && (typeof parameters === 'function')) {
            callback = parameters;
            parameters = null;
        }

        // Validate the arguments
        Validate.isValidId(id, idPropertyName);
        if (!_.isNull(parameters)) {
            Validate.isValidParametersObject(parameters);
        }
        Validate.notNull(callback, 'callback');

        // Construct the URL
        var urlFragment = _.url.combinePathSegments(
                tableRouteSeperatorName,
                this.getTableName(),
                encodeURIComponent(id.toString()));

        var features = addQueryParametersFeaturesIfApplicable([], parameters);

        parameters = addSystemProperties(parameters, this.systemProperties);
        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        // Make the request
        this.getMobileServiceClient()._request(
            'GET',
            urlFragment,
            null,
            false,
            null,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    callback(error, null);
                } else {
                    var result = getItemFromResponse(response);
                    callback(null, result);
                }
            });
    });

MobileServiceTable.prototype.del = Platform.async(
    function (instance, parameters, callback) {
        /// <summary>
        /// Delete an object from a given table.
        /// </summary>
        /// <param name="instance" type="Object">
        /// The instance to delete from the table.
        /// </param>
        /// <param name="parameters" type="Object" mayBeNull="true">
        /// An object of user-defined parameters and values to include in the request URI query string.
        /// </param>
        /// <param name="callback" type="Function">
        /// The callback to invoke when the delete is complete.
        /// </param>

        // Account for absent optional arguments
        if (_.isNull(callback) && (typeof parameters === 'function')) {
            callback = parameters;
            parameters = null;
        }        

        // Validate the arguments
        Validate.notNull(instance, 'instance');
        Validate.isValidId(instance[idPropertyName], 'instance.' + idPropertyName);
        Validate.notNull(callback, 'callback');

        var headers = {};
        var features = [];
        if (_.isString(instance[idPropertyName])) {
            if (!_.isNullOrEmpty(instance.__version)) {
                headers['If-Match'] = getEtagFromVersion(instance.__version);
                features.push(WindowsAzure.MobileServiceClient._zumoFeatures.OptimisticConcurrency);
            }
        }

        features = addQueryParametersFeaturesIfApplicable(features, parameters);

        parameters = addSystemProperties(parameters, this.systemProperties);
        if (!_.isNull(parameters)) {
            Validate.isValidParametersObject(parameters);
        }

        // Contruct the URL
        var urlFragment =  _.url.combinePathSegments(
                tableRouteSeperatorName,
                this.getTableName(),
                encodeURIComponent(instance[idPropertyName].toString()));
        if (!_.isNull(parameters)) {
            var queryString = _.url.getQueryString(parameters);
            urlFragment = _.url.combinePathAndQuery(urlFragment, queryString);
        }

        // Make the request
        this.getMobileServiceClient()._request(
            'DELETE',
            urlFragment,
            null,
            false,
            headers,
            features,
            function (error, response) {
                if (!_.isNull(error)) {
                    setServerItemIfPreconditionFailed(error);
                }
                callback(error);
            });
    });

// Copy select Query operators to MobileServiceTable so queries can be created
// compactly.  We'll just add them to the MobileServiceTable prototype and then
// forward on directly to a new Query instance.
var queryOperators =
    ['where', 'select', 'orderBy', 'orderByDescending', 'skip', 'take', 'includeTotalCount'];
var copyOperator = function (operator) {
    MobileServiceTable.prototype[operator] = function () {
        /// <summary>
        /// Creates a new query.
        /// </summary>

        // Create a query associated with this table
        var table = this;
        var query = new Query(table.getTableName());

        // Add a .read() method on the query which will execute the query.
        // This method is defined here per query instance because it's
        // implicitly tied to the table.
        query.read = Platform.async(
            function (parameters, callback) {
                /// <summary>
                /// Execute the query.
                /// </summary>                
                table._read(query, parameters, callback);
            });

        // Invoke the query operator on the newly created query
        return query[operator].apply(query, arguments);
    };
};
var i = 0;
for (; i < queryOperators.length; i++) {
    // Avoid unintended closure capture
    copyOperator(queryOperators[i]);
}

// Table system properties
function removeSystemProperties(instance) {
    var copy = {};
    for(var property in instance) {
        if (property.substr(0, 2) !== '__') {
            copy[property] = instance[property];
        }
    }
    return copy;
}

function addSystemProperties(parameters, properties, querystring) {
    if (properties === MobileServiceSystemProperties.None || (typeof querystring === 'string' && querystring.toLowerCase().indexOf('__systemproperties') >= 0)) {
        return parameters;
    }

    // Initialize an object if none passed in
    parameters = parameters || {};

    // Don't override system properties if already set
    if(!_.isNull(parameters.__systemProperties)) {
        return parameters;
    }

    if (properties === MobileServiceSystemProperties.All) {
        parameters.__systemProperties = '*';
    } else {
        var options = [];
        if (MobileServiceSystemProperties.CreatedAt & properties) {
            options.push(MobileServiceSystemColumns.CreatedAt);
        }
        if (MobileServiceSystemProperties.UpdatedAt & properties) {
            options.push(MobileServiceSystemColumns.UpdatedAt);
        }
        if (MobileServiceSystemProperties.Version & properties) {
            options.push(MobileServiceSystemColumns.Version);
        }
        parameters.__systemProperties = options.join(',');
    }

    return parameters;
}

// Add double quotes and unescape any internal quotes
function getItemFromResponse(response) {
    var result = _.fromJson(response.responseText);
    if (response.getResponseHeader) {
        var eTag = response.getResponseHeader('ETag');
        if (!_.isNullOrEmpty(eTag)) {
            result.__version = getVersionFromEtag(eTag);
        }
    }
    return result;
}

// Converts an error to precondition failed error
function setServerItemIfPreconditionFailed(error) {
    if (error.request && error.request.status === 412) {
        error.serverInstance = _.fromJson(error.request.responseText);
    }
}

// Add wrapping double quotes and escape all double quotes
function getEtagFromVersion(version) {
    var result = version.replace(/\"/g, '\\\"');
    return "\"" + result + "\"";
}

// Remove surrounding double quotes and unescape internal quotes
function getVersionFromEtag(etag) {
    var len = etag.length,
        result = etag;

    if (len > 1 && etag[0] === '"' && etag[len - 1] === '"') {
        result = etag.substr(1, len - 2);
    }
    return result.replace(/\\\"/g, '"');
}

// Updates and returns the headers parameters with features used in the call
function addQueryParametersFeaturesIfApplicable(features, userQueryParameters) {
    var hasQueryParameters = false;
    if (userQueryParameters) {
        if (Array.isArray(userQueryParameters)) {
            hasQueryParameters = userQueryParameters.length > 0;
        } else if (_.isObject(userQueryParameters)) {
            for (var k in userQueryParameters) {
                hasQueryParameters = true;
                break;
            }
        }
    }

    if (hasQueryParameters) {
        features.push(WindowsAzure.MobileServiceClient._zumoFeatures.AdditionalQueryParameters);
    }

    return features;
}

},{"./Utilities/Extensions":143,"./Utilities/Validate":146,"Platforms/Platform":139,"query.js/lib/Query":126}],138:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var Platform = require('Platforms/Platform');
var Validate = require('../../Utilities/Validate');
var _ = require('../../Utilities/Extensions');
var Query = require('azure-mobile-apps/src/query');
var formatSql = require('azure-mobile-apps/src/data/sql/query/format');

var idPropertyName = "id";
var tables = {};

var MobileServiceSQLiteStore = function (dbName) {
    /// <summary>
    /// Initializes a new instance of the MobileServiceSQLiteStore class.
    /// </summary>

    this._db = window.sqlitePlugin.openDatabase({ name: dbName });

    this.defineTable = Platform.async(function (tableDefinition, callback) {
        /// <summary>Defines the local table in the sqlite store</summary>
        /// <param name="tableDefinition">Table definition object defining the table name and columns
        /// Example of a valid tableDefinition object:
        /// tableDefinition : {
        ///     name: "todoItemTable",
        ///     columnDefinitions : {
        ///         id : "INTEGER",
        ///         description : MobileServiceSQLiteStore.ColumnType.TEXT,
        ///         price : "REAL"
        ///     }
        /// }
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        // Platform.async silently appends a callback argument to the original list of arguments.
        // Validate the argument length to ensure the callback argument is indeed the callback 
        // provided by Platform.async.
        Validate.length(arguments, 2, 'arguments');

        Validate.notNull(callback, 'callback');

        Validate.notNull(tableDefinition, 'tableDefinition');
        Validate.isString(tableDefinition.name, 'tableDefinition.name');
        Validate.notNullOrEmpty(tableDefinition.name, 'tableDefinition.name');

        var columnDefinitions = tableDefinition.columnDefinitions;

        // Validate the specified column types
        for (var columnName in columnDefinitions) {
            var columnType = columnDefinitions[columnName];

            Validate.isString(columnType, 'columnType');
            Validate.notNullOrEmpty(columnType, 'columnType');
        }

        this._db.transaction(function(transaction) {

            var pragmaStatement = _.format("PRAGMA table_info({0});", tableDefinition.name);

            transaction.executeSql(pragmaStatement, [], function (transaction, result) {

                // If table already exists, add missing columns, if any.
                // Else, create the table
                if (result.rows.length > 0) {

                    // Columns that are present in the table already
                    var existingColumns = {};

                    // Remove columns that are already present in the table from the columnDefinitions array
                    for (var i = 0; i < result.rows.length; i++) {
                        var column = result.rows.item(i);
                        existingColumns[column.name] = true;
                    }

                    addMissingColumns(transaction, tableDefinition, existingColumns);

                } else {
                    createTable(transaction, tableDefinition);
                }
            });

        }, function (error) {
            callback(error);
        }, function(result) {
            callback();
        });
    });

    //TODO(shrirs): instance needs to be an array instead of an object
    this.upsert = Platform.async(function (tableName, instance, callback) {
        /// <summary>Updates or inserts an object in the local table</summary>
        /// <param name="tableName">Name of the local table in which the object is to be upserted</param>
        /// <param name="instance">Object to be inserted or updated in the table</param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        // Platform.async silently appends a callback argument to the original list of arguments.
        // Validate the argument length to ensure the callback argument is indeed the callback 
        // provided by Platform.async.
        Validate.length(arguments, 3, 'arguments');

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(instance, 'instance');

        // Note: The default maximum number of parameters allowed by sqlite is 999
        // See: http://www.sqlite.org/limits.html#max_variable_number
        // TODO(shrirs): Add support for tables with more than 999 columns

        var columnNames = '',
            columnParams = '',
            updateClause = '',
            insertValues = [],
            updateValues = [];

        for (var property in instance) {
            if (columnNames !== '') {
                columnNames += ', ';
                columnParams += ', ';
            }

            if (updateClause !== '') {
                updateClause += ', ';
            }

            columnNames += property;
            columnParams += '?';

            if (property !== idPropertyName) {
                updateClause += property + ' = ?';
                updateValues.push(instance[property]);
            }

            insertValues.push(instance[property]);
        }

        updateValues.push(instance[idPropertyName]);

        var insertStatement = _.format("INSERT OR IGNORE INTO {0} ({1}) VALUES ({2})", tableName, columnNames, columnParams);
        var updateStatement = _.format("UPDATE {0} SET {1} WHERE {2} = ? COLLATE NOCASE", tableName, updateClause, idPropertyName);

        this._db.transaction(function (transaction) {
            transaction.executeSql(insertStatement, insertValues);
            transaction.executeSql(updateStatement, updateValues);
        }, function (error) {
            callback(error);
        }, function () {
            callback();
        });
    });

    // TODO(shrirs): Implement equivalents of readWithQuery and deleteUsingQuery
    this.lookup = Platform.async(function (tableName, id, callback) {
        /// <summary>Perform a lookup against a local table</summary>
        /// <param name="tableName">Name of the local table in which look up is to be performed</param>
        /// <param name="id">ID of the object to be looked up</param>
        /// <returns type="Promise">
        /// A promise that is resolved with the looked up object when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        // Platform.async silently appends a callback argument to the original list of arguments.
        // Validate the argument length to ensure the callback argument is indeed the callback 
        // provided by Platform.async.
        Validate.length(arguments, 3, 'arguments');

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        Validate.notNull(id, 'id');

        var lookupStatement = _.format("SELECT * FROM [{0}] WHERE {1} = ? COLLATE NOCASE", tableName, idPropertyName);

        this._db.executeSql(lookupStatement, [id], function (result) {

            var instance = null;
            if (result.rows.length !== 0) {
                instance = result.rows.item(0); 
            }

            callback(null, instance);
        }, function (err) {
            callback(err);
        });
    });

    //TODO(shrirs): instance needs to be an array instead of an object
    this.del = Platform.async(function (tableName, instance, callback) {
        /// <summary>The items to delete from the local table</summary>
        /// <param name="tableName">Name of the local table in which delete is to be performed</param>
        /// <param name="instance">Object to delete from the table</param>
        /// <returns type="Promise">
        /// A promise that is resolved when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        // Platform.async silently appends a callback argument to the original list of arguments.
        // Validate the argument length to ensure the callback argument is indeed the callback 
        // provided by Platform.async.
        Validate.length(arguments, 3, 'arguments');

        Validate.isString(tableName, 'tableName');
        Validate.notNullOrEmpty(tableName, 'tableName');

        var deleteStatement = _.format("DELETE FROM {0} WHERE {1} = ? COLLATE NOCASE", tableName, idPropertyName);

        this._db.executeSql(deleteStatement, [instance[idPropertyName]], function (result) {
            callback();
        }, function(error) {
            callback(error);
        });
    });

    function getStatementParameters(statement) {
        var params = [];

        if (statement.parameters) {
            statement.parameters.forEach(function (param) {
                params.push(param.value);
            });
        }

        return params;
    }

    this.read = Platform.async(function (query, callback) {
        /// <summary>
        /// Read a table
        /// </summary>
        /// <param name="query" type="Object">
        /// A QueryJS object representing the query to be performed while reading the table.
        /// </param>
        /// <returns type="Promise">
        /// A promise that is resolved with the read results when the operation is completed successfully.
        /// If the operation fails, the promise is rejected
        /// </returns>

        // Platform.async silently appends a callback argument to the original list of arguments.
        // Validate the argument length to ensure the callback argument is indeed the callback 
        // provided by Platform.async.
        Validate.length(arguments, 2, 'arguments');

        Validate.notNull(query, 'query');
        Validate.isObject(query, 'query');

        var count,
            result = [],
            odataQuery = Query.toOData(query),
            statements = formatSql(odataQuery, { flavor: 'sqlite' });

        this._db.transaction(function (transaction) {
            if (statements.length >= 1) {
                transaction.executeSql(statements[0].sql, getStatementParameters(statements[0]), function (transaction, res) {
                    for (var j = 0; j < res.rows.length; j++) {
                        result.push(res.rows.item(j));
                    }
                });
            }

            // Check if there are multiple statements. If yes, the second is for the result count.
            if (statements.length >= 2) {
                transaction.executeSql(statements[1].sql, getStatementParameters(statements[1]), function (transaction, res) {
                    count = res.rows.item(0).count;
                });
            }
        }, function (error) {
            callback(error);
        }, function () {
            if (count !== undefined) {
                result = {
                    result: result,
                    count: count
                };
            }
            callback(null, result);
        });
    });
};

function createTable(transaction, tableDefinition) {
    var columnDefinitions = tableDefinition.columnDefinitions;
    var columnDefinitionClauses = [];

    for (var columnName in columnDefinitions) {
        var columnType = columnDefinitions[columnName];

        var columnDefinitionClause = _.format("[{0}] {1}", columnName, columnType);

        // TODO(shrirs): Handle cases where id property may be missing
        if (columnName === idPropertyName) {
            columnDefinitionClause += " PRIMARY KEY";
        }

        columnDefinitionClauses.push(columnDefinitionClause);
    }

    var createTableStatement = _.format("CREATE TABLE [{0}] ({1})", tableDefinition.name, columnDefinitionClauses.join());

    transaction.executeSql(createTableStatement);
}

// Add missing columns to the table
function addMissingColumns(transaction, tableDefinition, existingColumns) {

    // SQLite does not support adding multiple columns using a single statement; Add one column at a time
    var columnDefinitions = tableDefinition.columnDefinitions;
    for (var columnName in columnDefinitions) {

        // If this column does not already exist, we need to create it
        if (!existingColumns[columnName]) {
            var alterStatement = _.format("ALTER TABLE {0} ADD COLUMN {1} {2}", tableDefinition.name, columnName, columnDefinitions[columnName]);
            transaction.executeSql(alterStatement);
        }
    }
}

// Valid SQL types
MobileServiceSQLiteStore.ColumnType = {
    NULL: "NULL",
    INTEGER: "INTEGER",
    REAL: "REAL",
    TEXT: "TEXT",
    BLOB: "BLOB"
};

// Export
Platform.addToMobileServicesClientNamespace({ MobileServiceSQLiteStore: MobileServiceSQLiteStore });

exports.MobileServiceSQLiteStore = MobileServiceSQLiteStore;

Platform.addToMobileServicesClientNamespace({ MobileServiceSQLiteStore: MobileServiceSQLiteStore });

},{"../../Utilities/Extensions":143,"../../Utilities/Validate":146,"Platforms/Platform":139,"azure-mobile-apps/src/data/sql/query/format":99,"azure-mobile-apps/src/query":102}],139:[function(require,module,exports){
(function (global){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="..\Generated\MobileServices.DevIntellisense.js" />
/*global $__fileVersion__:false, $__version__:false */

var _ = require('../../Utilities/Extensions');
var Validate = require('../../Utilities/Validate');
var Promises = require('../../Utilities/Promises');
var Constants = require('../../Generated/Constants');
var inMemorySettingStore = {};

try {
    var key = '___z';
    localStorage.setItem(key, key);
    localStorage.removeItem(key);
    inMemorySettingStore = localStorage;
} catch (e) {
    // localStorage is not available
}

var bestAvailableTransport = null;
var knownTransports = [ // In order of preference
    require('../../Transports/DirectAjaxTransport'),
    require('../../Transports/IframeTransport')
];
var knownLoginUis = [ // In order of preference
    require('../../LoginUis/WebAuthBroker'),
    require('../../LoginUis/CordovaPopup'),
    require('../../LoginUis/BrowserPopup')
];

// Matches an ISO date and separates out the fractional part of the seconds
// because IE < 10 has quirks parsing fractional seconds
var isoDateRegex = /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(?:\.(\d*))?Z$/;

// Feature-detect IE8's date serializer
var dateSerializerOmitsDecimals = !JSON.stringify(new Date(100)).match(/\.100Z"$/);

exports.async = function async(func) {
    /// <summary>
    /// Wrap a function that takes a callback into platform specific async
    /// operation (i.e., keep using callbacks or switch to promises).
    /// </summary>
    /// <param name="func" type="Function">
    /// An async function with a callback as its last parameter 
    /// </param>
    /// <returns type="Function">
    /// Function that when invoked will return a promise.
    /// </returns>

    return function () {
        // Capture the context of the original call
        var that = this;
        var args = arguments;

        // Create a new promise that will wrap the async call
        return new Promises.Promise(function (complete, error) {

            // Add a callback to the args which will call the appropriate
            // promise handlers
            var callback = function (err) {
                if (_.isNull(err)) {
                    // Call complete with all the args except for err
                    complete.apply(null, Array.prototype.slice.call(arguments, 1));
                } else {
                    error(err);
                }
            };
            Array.prototype.push.call(args, callback);

            try {
                // Invoke the async method which will in turn invoke our callback
                // which will in turn invoke the promise's handlers
                func.apply(that, args);
            } catch (ex) {
                // Thread any immediate errors like parameter validation
                // through the the callback
                callback(_.createError(ex));
            }
        });
    };
};

exports.addToMobileServicesClientNamespace = function (declarations) {
    /// <summary>
    /// Define a collection of declarations in the Mobile Services Client namespace.
    /// </summary>
    /// <param name="declarations" type="Object">
    /// Object consisting of names and values to define in the namespace.
    /// </param>

    // First ensure our 'WindowsAzure' namespace exists
    var namespaceObject = global.WindowsAzure = global.WindowsAzure || {};
    
    // Now add each of the declarations to the namespace
    for (var key in declarations) {
        if (declarations.hasOwnProperty(key)) {
            namespaceObject[key] = declarations[key];
        }
    }
};

exports.readSetting = function readSetting(name) {
    /// <summary>
    /// Read a setting from a global configuration store.
    /// </summary>
    /// <param name="name" type="String">
    /// Name of the setting to read.
    /// </param>
    /// <returns type="String" mayBeNull="true">
    /// The value of the setting or null if not set.
    /// </returns>

    return inMemorySettingStore[name];
};

exports.writeSetting = function writeSetting(name, value) {
    /// <summary>
    /// Write a setting to a global configuration store.
    /// </summary>
    /// <param name="name" type="String">
    /// Name of the setting to write.
    /// </param>
    /// <param name="value" type="String" mayBeNull="true">
    /// The value of the setting.
    /// </returns>

    inMemorySettingStore[name] = value;
};

exports.webRequest = function (request, callback) {
    /// <summary>
    /// Make a web request.
    /// </summary>
    /// <param name="request" type="Object">
    /// Object describing the request (in the WinJS.xhr format).
    /// </param>
    /// <param name="callback" type="Function">
    /// The callback to execute when the request completes.
    /// </param>

    return getBestTransport().performRequest(request, callback);
};

exports.getUserAgent = function () {
    // Browsers don't allow you to set a custom user-agent in ajax requests. Trying to do so
    // will cause an exception. So we don't.
    return null;
};

exports.getOperatingSystemInfo = function () {
    return {
        name: "--",
        version: "--",
        architecture: "--"
    };
};

exports.getSdkInfo = function () {
    var isCordovaEnvironment = window && window.cordova && window.cordova.version;

    return {
        language: isCordovaEnvironment ? "Cordova" : "Web",
        fileVersion: Constants.FileVersion
    };
};

exports.login = function (startUri, endUri, callback) {
    // Force logins to go over HTTPS because the runtime is hardcoded to redirect
    // the server flow back to HTTPS, and we need the origin to match.
    var findProtocol = /^[a-z]+:/,
        requiredProtocol = 'https:';
    startUri = startUri.replace(findProtocol, requiredProtocol);
    endUri = endUri.replace(findProtocol, requiredProtocol);

    return getBestProvider(knownLoginUis).login(startUri, endUri, callback);
};

exports.toJson = function (value) {
    /// <summary>
    /// Convert an object into JSON format.
    /// </summary>
    /// <param name="value" type="Object">The value to convert.</param>
    /// <returns type="String">The value as JSON.</returns>

    // We're wrapping this so we can hook the process and perform custom JSON
    // conversions.  Note that we don't have to add a special hook to correctly
    // serialize dates in ISO8061 because JSON.stringify does that by defualt.
    // TODO: Convert geolocations once they're supported
    // TODO: Expose the ability for developers to convert custom types
    return JSON.stringify(value, function (key, stringifiedValue) {
        if (dateSerializerOmitsDecimals && this && _.isDate(this[key])) {
            // IE8 doesn't include the decimal part in its serialization of dates
            // For consistency, we extract the non-decimal part from the string
            // representation, and then append the expected decimal part.
            var msec = this[key].getMilliseconds(),
                msecString = String(msec + 1000).substring(1);
            return stringifiedValue.replace(isoDateRegex, function (all, datetime) {
                return datetime + "." + msecString + "Z";
            });
        } else {
            return stringifiedValue;
        }
    });
};

exports.tryParseIsoDateString = function (text) {
    /// <summary>
    /// Try to parse an ISO date string.
    /// </summary>
    /// <param name="text" type="String">The text to parse.</param>
    /// <returns type="Date">The parsed Date or null.</returns>

    Validate.isString(text);

    // Check against a lenient regex
    var matchedDate = isoDateRegex.exec(text);
    if (matchedDate) {
        // IE9 only handles precisely 0 or 3 decimal places when parsing ISO dates,
        // and IE8 doesn't parse them at all. Fortunately, all browsers can handle 
        // 'yyyy/mm/dd hh:MM:ss UTC' (without fractional seconds), so we can rewrite
        // the date to that format, and the apply fractional seconds.
        var dateWithoutFraction = matchedDate[1],
            fraction = matchedDate[2] || "0",
            milliseconds = Math.round(1000 * Number("0." + fraction)); // 6 -> 600, 65 -> 650, etc.
        dateWithoutFraction = dateWithoutFraction
            .replace(/\-/g, "/")   // yyyy-mm-ddThh:mm:ss -> yyyy/mm/ddThh:mm:ss
            .replace("T", " ");    // yyyy/mm/ddThh:mm:ss -> yyyy/mm/dd hh:mm:ss

        // Try and parse - it will return NaN if invalid
        var ticks = Date.parse(dateWithoutFraction + " UTC");
        if (!isNaN(ticks)) {
            return new Date(ticks + milliseconds); // ticks are just milliseconds since 1970/01/01
        }
    }

    // Doesn't look like a date
    return null;
};

exports.getResourceString = function (resourceName) {
    // For now, we'll just always use English
    return Constants.Resources["en-US"][resourceName];
};


exports.allowPlatformToMutateOriginal = function (original, updated) {
    // For the Web/HTML client, we don't modify the original object.
    // This is the more typical arrangement for most JavaScript data access.
    return updated;
};

function getBestTransport() {
    // We cache this just because it gets called such a lot
    if (!bestAvailableTransport) {
        bestAvailableTransport = getBestProvider(knownTransports);
    }

    return bestAvailableTransport;
}

function getBestProvider(providers) {
    /// <summary>
    /// Given an array of objects which each have a 'supportsCurrentRuntime' function,
    /// returns the first instance where that function returns true.
    /// </summary>

    for (var i = 0; i < providers.length; i++) {
        if (providers[i].supportsCurrentRuntime()) {
            return providers[i];
        }
    }

    throw new Error("Unsupported browser - no suitable providers are available.");
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../Generated/Constants":129,"../../LoginUis/BrowserPopup":130,"../../LoginUis/CordovaPopup":131,"../../LoginUis/WebAuthBroker":132,"../../Transports/DirectAjaxTransport":141,"../../Transports/IframeTransport":142,"../../Utilities/Extensions":143,"../../Utilities/Promises":145,"../../Utilities/Validate":146}],140:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
var Validate = require('../Utilities/Validate'),
    Platform = require('Platforms/Platform'),
    _ = require('../Utilities/Extensions');

exports.Push = Push;

function Push(client, installationId) {
    this.client = client;
    this.installationId = installationId;
}

/// <summary>
/// Register a push channel with the Mobile Apps backend to start receiving notifications.
/// </summary>
/// <param name="platform" type="string">
/// The device platform being used - wns, gcm or apns.
/// </param>
/// <param name="pushChannel" type="string">
/// The push channel identifier or URI.
/// </param>
/// <param name="templates" type="string">
/// An object containing template definitions. Template objects should contain body, headers and tags properties.
/// </param>
/// <param name="secondaryTiles" type="string">
/// An object containing template definitions to be used with secondary tiles when using WNS.
/// </param>
Push.prototype.register = Platform.async(
    function (platform, pushChannel, templates, secondaryTiles, callback) {
        Validate.isString(platform, 'platform');
        Validate.notNullOrEmpty(platform, 'platform');

        // in order to support the older callback style completion, we need to check optional parameters
        if (_.isNull(callback) && (typeof templates === 'function')) {
            callback = templates;
            templates = null;
        }

        if (_.isNull(callback) && (typeof secondaryTiles === 'function')) {
            callback = secondaryTiles;
            secondaryTiles = null;
        }

        var requestContent = {
            installationId: this.installationId,
            pushChannel: pushChannel,
            platform: platform,
            templates: stringifyTemplateBodies(templates),
            secondaryTiles: stringifyTemplateBodies(secondaryTiles)
        };

        executeRequest(this.client, 'PUT', pushChannel, requestContent, this.installationId, callback);
    }
);

/// <summary>
/// Unregister a push channel with the Mobile Apps backend to stop receiving notifications.
/// </summary>
/// <param name="pushChannel" type="string">
/// The push channel identifier or URI.
/// </param>
Push.prototype.unregister = Platform.async(
    function (pushChannel, callback) {
        executeRequest(this.client, 'DELETE', pushChannel, null, this.installationId, callback);
    }
);

function executeRequest(client, method, pushChannel, content, installationId, callback) {
    Validate.isString(pushChannel, 'pushChannel');
    Validate.notNullOrEmpty(pushChannel, 'pushChannel');

    client._request(
        method,
        'push/installations/' + encodeURIComponent(installationId),
        content,
        null,
        { 'If-Modified-Since': 'Mon, 27 Mar 1972 00:00:00 GMT' },
        callback
    );
}

function stringifyTemplateBodies(templates) {
    var result = {};
    for (var templateName in templates) {
        if (templates.hasOwnProperty(templateName)) {
            // clone the template so we are not modifying the original
            var template = _.extend({}, templates[templateName]);
            if (typeof template.body !== 'string') {
                template.body = JSON.stringify(template.body);
            }
            result[templateName] = template;
        }
    }
    return result;
}
},{"../Utilities/Extensions":143,"../Utilities/Validate":146,"Platforms/Platform":139}],141:[function(require,module,exports){
(function (global){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="..\Generated\MobileServices.DevIntellisense.js" />

// This transport is for modern browsers - it uses XMLHttpRequest with Cross-Origin Resource Sharing (CORS)

exports.name = "DirectAjaxTransport";

exports.supportsCurrentRuntime = function () {
    /// <summary>
    /// Determines whether or not this transport is usable in the current runtime.
    /// </summary>

    // Feature-detect support for CORS (for IE, it's in version 10+)
    return (typeof global.XMLHttpRequest !== "undefined") &&
           ('withCredentials' in new global.XMLHttpRequest());
};

exports.performRequest = function (request, callback) {
    /// <summary>
    /// Make a web request.
    /// </summary>
    /// <param name="request" type="Object">
    /// Object describing the request (in the WinJS.xhr format).
    /// </param>
    /// <param name="callback" type="Function">
    /// The callback to execute when the request completes.
    /// </param>

    var headers = request.headers || {},
        url = request.url.replace(/#.*$/, ""), // Strip hash part of URL for consistency across browsers
        httpMethod = request.type ? request.type.toUpperCase() : "GET",
        xhr = new global.XMLHttpRequest();

    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(null, xhr);
        }
    };

    xhr.open(httpMethod, url);

    for (var key in headers) {
        if (request.headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, request.headers[key]);
        }
    }

    xhr.send(request.data);
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],142:[function(require,module,exports){
(function (global){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="..\Generated\MobileServices.DevIntellisense.js" />

// This transport is for midlevel browsers (IE8-9) that don't support CORS but do support postMessage.
// It creates an invisible <iframe> that loads a special bridge.html page from the runtime domain.
// To issue a request, it uses postMessage to pass the request into the <iframe>, which in turn makes
// a same-domain Ajax request to the runtime. To associate postMessage replies with the original
// request, we track an array of promises that eventually time out if not resolved (see PostMessageExchange).

var Promises = require('../Utilities/Promises'),
    PostMessageExchange = require('../Utilities/PostMessageExchange'),
    loadBridgeFramePromises = [], // One per target proto/host/port triplet
    messageExchange = PostMessageExchange.instance;

exports.name = "../../Transports/IframeTransport";

exports.supportsCurrentRuntime = function () {
    /// <summary>
    /// Determines whether or not this transport is usable in the current runtime.
    /// </summary>

    return typeof global.postMessage !== "undefined";
};

exports.performRequest = function (request, callback) {
    /// <summary>
    /// Make a web request.
    /// </summary>
    /// <param name="request" type="Object">
    /// Object describing the request (in the WinJS.xhr format).
    /// </param>
    /// <param name="callback" type="Function">
    /// The callback to execute when the request completes.
    /// </param>

    var originRoot = PostMessageExchange.getOriginRoot(request.url);
    whenBridgeLoaded(originRoot, function (bridgeFrame) {
        var message = {
            type: request.type,
            url: request.url,
            headers: request.headers,
            data: request.data
        };
        messageExchange.request(bridgeFrame.contentWindow, message, originRoot).then(function (reply) {
            fixupAjax(reply);
            callback(null, reply);
        }, function (error) {
            callback(error, null);
        });
    });
};

function fixupAjax(xhr) {
    if (xhr) {
        // IE sometimes converts status 204 into 1223
        // http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        if (xhr.status === 1223) {
            xhr.status = 204;
        }
    }
}

function whenBridgeLoaded(originRoot, callback) {
    /// <summary>
    /// Performs the callback once the bridge iframe has finished loading.
    /// Lazily creates the bridge iframe if necessary. Note that each proto/host/port
    /// triplet (i.e., same-domain origin) needs a separate bridge.
    /// </summary>

    var cacheEntry = loadBridgeFramePromises[originRoot];

    if (!cacheEntry) {
        cacheEntry = loadBridgeFramePromises[originRoot] = new Promises.Promise(function (complete, error) {
            var bridgeFrame = document.createElement("iframe"),
                callerOrigin = PostMessageExchange.getOriginRoot(window.location.href),
                handleBridgeLoaded = function() {
                    complete(bridgeFrame);
                };
            
            if (bridgeFrame.addEventListener) {
                bridgeFrame.addEventListener("load", handleBridgeLoaded, false);
            } else {
                // For IE8
                bridgeFrame.attachEvent("onload", handleBridgeLoaded);
            }

            bridgeFrame.src = originRoot + "/crossdomain/bridge?origin=" + encodeURIComponent(callerOrigin);
            
            // Try to keep it invisible, even if someone does $("iframe").show()
            bridgeFrame.setAttribute("width", 0);
            bridgeFrame.setAttribute("height", 0);
            bridgeFrame.style.display = "none";

            global.document.body.appendChild(bridgeFrame);
        });
    }

    cacheEntry.then(callback);
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../Utilities/PostMessageExchange":144,"../Utilities/Promises":145}],143:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="..\Generated\MobileServices.DevIntellisense.js" />

// Declare JSHint globals
/*global XMLHttpRequest:false */

var Validate = require('./Validate');
var Platform = require('Platforms/Platform');
var _ = exports;

exports.isNull = function (value) {
    /// <summary>
    /// Gets a value indicating whether the provided value is null (or
    /// undefined).
    /// </summary>
    /// <param name="value" type="Object" mayBeNull="true">
    /// The value to check.
    /// </param>
    /// <returns type="Boolean">
    /// A value indicating whether the provided value is null (or undefined).
    /// </returns>
    
    return value === null || value === undefined;
};

exports.isNullOrZero = function (value) {
    /// <summary>
    /// Gets a value indicating whether the provided value is null (or
    /// undefined) or zero / empty string
    /// </summary>
    /// <param name="value" type="Object" mayBeNull="true">
    /// The value to check.
    /// </param>
    /// <returns type="Boolean">
    /// A value indicating whether the provided value is null (or undefined) or zero or empty string.
    /// </returns>

    return value === null || value === undefined || value === 0 || value === '';
};

exports.isNullOrEmpty = function (value) {
    /// <summary>
    /// Gets a value indicating whether the provided value is null (or
    /// undefined) or empty.
    /// </summary>
    /// <param name="value" type="Object" mayBeNull="true">
    /// The value to check.
    /// </param>
    /// <returns type="Boolean">
    /// A value inHdicating whether the provided value is null (or undefined).
    /// </returns>

    return _.isNull(value) || value.length === 0;
};

exports.format = function (message) {
    /// <summary>
    /// Format a string by replacing all of its numbered arguments with
    /// parameters to the method. Arguments are of the form {0}, {1}, ..., like
    /// in .NET.
    /// </summary>
    /// <param name="message" type="string" mayBeNull="false">
    /// The format string for the message.
    /// </param>
    /// <param name="arguments" type="array" optional="true">
    /// A variable number of arguments that can be used to format the message.
    /// </param>
    /// <returns type="string">The formatted string.</returns>

    Validate.isString(message, 'message');

    // Note: There are several flaws in this implementation that we are
    // ignoring for simplicity as it's only used internally.  Examples that
    // could be handled better include:
    //    format('{0} {1}', 'arg') => 'arg {1}'
    //    format('{0} {1}', '{1}', 'abc') => 'abc abc'
    //    format('{0}', '{0}') => <stops responding>

    if (!_.isNullOrEmpty(message) && arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            var pattern = '{' + (i - 1) + '}';
            while (message.indexOf(pattern) !== -1) {
                message = message.replace(pattern, arguments[i]);
            }
        }
    }

    return message;
};

exports.has = function (value, key) {
    /// <summary>
    /// Determine if an object defines a given property.
    /// </summary>
    /// <param name="value" type="Object">The object to check.</param>
    /// <param name="key" type="String">
    /// The name of the property to check for.
    /// </param>
    /// <returns type="Boolean">
    /// A value indicating whether the object defines the property.
    /// </returns>

    Validate.notNull(key, 'key');
    Validate.isString(key, 'key');

    return !_.isNull(value) && value.hasOwnProperty(key);
};

exports.hasProperty = function (object, properties) {
    /// <summary>
    /// Determines if an object has any of the passed in properties
    /// </summary>
    /// <returns type="boolean">True if it contains any one of the properties
    /// </returns>
    for (var i = 0; i < properties.length; i++) {
        if (_.has(object, properties[i])) {
            return true;
        }
    }
    return false;
};

exports.extend = function extend(target, members) {
    /// <summary>
    /// Extends the target with the members of the members object.
    /// </summary>
    /// <param name="target" type="Object">The target object to extend.</param>
    /// <param name="members" type="Object">The members object to add to the target.</param>
    /// <returns type="Object">The target object extended with the members.
    /// </returns>
    for (var member in members) {
        if (members.hasOwnProperty(member)) {
            target[member] = members[member];
        }
    }
    return target;
};

exports.isObject = function (value) {
    /// <summary>
    /// Determine if a value is an object.
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is an object (or null), false othwerise.
    /// </returns>

    return _.isNull(value) || (typeof value === 'object' && !_.isDate(value));
};

exports.isValidId = function (value) {
    /// <summary>
    /// Determine if a value is an acceptable id for use by the mobile service
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is a string or number, meeting all criteria, or false othwerise.
    /// </returns>
    if (_.isNullOrZero(value)) {
        return false;
    }

    if (_.isString(value)) {
        // Strings must contain at least one non whitespace character
        if (value.length === 0 || value.length > 255 || value.trim().length === 0) {
            return false;
        }

        var ex = /[+"\/?`\\]|[\u0000-\u001F]|[\u007F-\u009F]|^\.{1,2}$/;
        if (value.match(ex) !== null) {
            return false;
        }

        return true;

    } else if (_.isNumber(value)) {
        return value > 0;
    }

    return false;
};

exports.isString = function (value) {
    /// <summary>
    /// Determine if a value is a string.
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is a string (or null), false othwerise.
    /// </returns>

    return _.isNull(value) || (typeof value === 'string');
};

exports.isNumber = function (value) {
    /// <summary>
    /// Determine if a value is a number.
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is a number, false othwerise.
    /// </returns>

    return !_.isNull(value) && (typeof value === 'number');
};

exports.isBool = function (value) {
    /// <summary>
    /// Determine if a value is a boolean.
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is a boolean, false othwerise.
    /// </returns>
    return !_.isNull(value) && (typeof value == 'boolean');
};

function classOf(value) {
    return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

exports.isDate = function (value) {
    /// <summary>
    /// Determine if a value is a date.
    /// </summary>
    /// <param name="value" type="Object">The value to check.</param>
    /// <returns type="boolean">
    /// True if the value is a date, false othwerise.
    /// </returns>
    return !_.isNull(value) && (classOf(value) == 'date');
};

exports.toJson = function (value) {
    /// <summary>
    /// Convert an object into JSON format.
    /// </summary>
    /// <param name="value" type="Object">The value to convert.</param>
    /// <returns type="String">The value as JSON.</returns>

    return Platform.toJson(value);
};

exports.fromJson = function (value) {
    /// <summary>
    /// Convert an object from JSON format.
    /// </summary>
    /// <param name="value" type="String">The value to convert.</param>
    /// <returns type="Object">The value as an object.</returns>

    var jsonValue = null;
    if (!_.isNullOrEmpty(value)) {
        // We're wrapping this so we can hook the process and perform custom JSON
        // conversions
        jsonValue = JSON.parse(
            value,
            function (k, v) {
                // Try to convert the value as a Date
                if (_.isString(v) && !_.isNullOrEmpty(v)) {
                    var date = exports.tryParseIsoDateString(v);
                    if (!_.isNull(date)) {
                        return date;
                    }
                }

                // TODO: Convert geolocations once they're supported
                // TODO: Expose the ability for developers to convert custom types

                // Return the original value if we couldn't do anything with it
                return v;
            });
    }

    return jsonValue;
};

exports.createUniqueInstallationId = function () {
    /// <summary>
    /// Create a unique identifier that can be used for the installation of
    /// the current application.
    /// </summary>
    /// <returns type="String">Unique identifier.</returns>

    var pad4 = function (str) { return "0000".substring(str.length) + str; };
    var hex4 = function () { return pad4(Math.floor(Math.random() * 0x10000 /* 65536 */).toString(16)); };

    return (hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4());
};

exports.mapProperties = function (instance, action) {
    /// <summary>
    /// Map a function over the key/value pairs in an instance.
    /// </summary>
    /// <param name="instance" type="Object">
    /// The instance to map over.
    /// </param>
    /// <param name="action" type="function (key, value)">
    /// The action to map over the key/value pairs.
    /// </param>
    /// <returns elementType="object">Mapped results.</returns>

    var results = [];
    if (!_.isNull(instance)) {
        var key = null;
        for (key in instance) {
            results.push(action(key, instance[key]));
        }
    }
    return results;
};

exports.pad = function (value, length, ch) {
    /// <summary>
    /// Pad the a value with a given character until it reaches the desired
    /// length.
    /// </summary>
    /// <param name="value" type="Object">The value to pad.</param>
    /// <param name="length" type="Number">The desired length.</param>
    /// <param name="ch" type="String">The character to pad with.</param>
    /// <returns type="String">The padded string.</returns>

    Validate.notNull(value, 'value');
    Validate.isInteger(length, 'length');
    Validate.isString(ch, 'ch');
    Validate.notNullOrEmpty(ch, 'ch');
    Validate.length(ch, 1, 'ch');

    var text = value.toString();
    while (text.length < length) {
        text = ch + text;
    }
    return text;
};

exports.trimEnd = function (text, ch) {
    /// <summary>
    /// Trim all instance of a given characher from the end of a string.
    /// </summary>
    /// <param name="text" type="String" mayBeNull="false">
    /// The string to trim.
    /// <param name="ch" type="String" mayBeNull="false">
    /// The character to trim.
    /// </param>
    /// <returns type="String">The trimmed string.</returns>

    Validate.isString(text, 'text');
    Validate.notNull(text, 'text');
    Validate.isString(ch, 'ch');
    Validate.notNullOrEmpty('ch', 'ch');
    Validate.length(ch, 1, 'ch');

    var end = text.length - 1;
    while (end >= 0 && text[end] === ch) {
        end--;
    }

    return end >= 0 ?
        text.substr(0, end + 1) :
        '';
};

exports.trimStart = function (text, ch) {
    /// <summary>
    /// Trim all instance of a given characher from the start of a string.
    /// </summary>
    /// <param name="text" type="String" mayBeNull="false">
    /// The string to trim.
    /// </param>
    /// <param name="ch" type="String" mayBeNull="false">
    /// The character to trim.
    /// </param>
    /// <returns type="String">The trimmed string.</returns>

    Validate.isString(text, 'text');
    Validate.notNull(text, 'text');
    Validate.isString(ch, 'ch');
    Validate.notNullOrEmpty(ch, 'ch');
    Validate.length(ch, 1, 'ch');

    var start = 0;
    while (start < text.length && text[start] === ch) {
        start++;
    }

    return start < text.length ?
        text.substr(start, text.length - start) :
        '';
};

exports.compareCaseInsensitive = function (first, second) {
    /// <summary>
    /// Compare two strings for equality while igorning case.
    /// </summary>
    /// <param name="first" type="String">First value.</param>
    /// <param name="second" type="String">Second value.</param>
    /// <returns type="Boolean">Whether the strings are the same.</returns>

    // NOTE: We prefer uppercase on Windows for historical reasons where it was
    // possible to have alphabets where several uppercase characters mapped to
    // the same lowercase character.

    if (_.isString(first) && !_.isNullOrEmpty(first)) {
        first = first.toUpperCase();
    }

    if (_.isString(first) && !_.isNullOrEmpty(second)) {
        second = second.toUpperCase();
    }

    return first === second;
};

/// <field name="url" type="Object">
/// Path specific utilities for working with URIs.
/// </field>
exports.url = {
    /// <field name="separator" type="String">
    /// The path separator character used for combining path segments.
    /// </field>
    separator: '/',

    combinePathSegments: function () {
        /// <summary>
        /// Combine several segments into a path.
        /// </summary>
        /// <param parameterArray="true" elementType="String">
        /// The segments of the path that should be combined.
        /// </param>
        /// <returns type="String">The combined path.</returns>

        // Normalize the segements
        var segments = [];
        var i = 0;
        Validate.notNullOrEmpty(arguments, 'arguments');
        for (i = 0; i < arguments.length; i++) {
            var segment = arguments[i];
            Validate.isString(segment, _.format('argument[{0}]', i));

            if (i !== 0) {
                segment = _.trimStart(segment || '', _.url.separator);
            }
            if (i < arguments.length - 1) {
                segment = _.trimEnd(segment || '', _.url.separator);
            }

            segments.push(segment);
        }

        // Combine the segments
        return segments.reduce(
            function (a, b) { return a + _.url.separator + b; });
    },

    getQueryString: function (parameters) {
        /// <summary>
        /// Converts an Object instance into a query string
        /// </summary>
        /// <param name="parameters" type="Object">The parameters from which to create a query string.</param>
        /// <returns type="String">A query string</returns>
        
        Validate.notNull(parameters, 'parameters');
        Validate.isObject(parameters, 'parameters');

        var pairs = [];
        for (var parameter in parameters) {
            var value = parameters[parameter];
            if (exports.isObject(value)) {
                value = exports.toJson(value);
            }
            pairs.push(encodeURIComponent(parameter) + "=" + encodeURIComponent(value));
        }

        return pairs.join("&");
    },

    combinePathAndQuery: function (path, queryString) {
        /// <summary>
        /// Concatenates the URI query string to the URI path.
        /// </summary>
        /// <param name="path" type="String>The URI path</param>
        /// <param name="queryString" type="String>The query string.</param>
        /// <returns type="String>The concatenated URI path and query string.</returns>
        Validate.notNullOrEmpty(path, 'path');
        Validate.isString(path, 'path');
        if (_.isNullOrEmpty(queryString)) {
            return path;
        }
        Validate.isString(queryString, 'queryString');

        if (path.indexOf('?') >= 0) {
            return path + '&' + exports.trimStart(queryString, '?');
        } else {
            return path + '?' + exports.trimStart(queryString, '?');
        }
    },

    isAbsoluteUrl: function (url) {
        /// <summary>
        /// Currently just a simple check if the url begins with http:// or https:/
        /// </summary>
        if (_.isNullOrEmpty(url)) {
            return false;
        }

        var start = url.substring(0, 7).toLowerCase();
        return (start  == "http://" || start == "https:/");
    }
};

exports.tryParseIsoDateString = function (text) {
    /// <summary>
    /// Try to parse an ISO date string.
    /// </summary>
    /// <param name="text" type="String">The text to parse.</param>
    /// <returns type="Date">The parsed Date or null.</returns>

    return Platform.tryParseIsoDateString(text);
};

exports.createError = function (exceptionOrMessage, request) {
    /// <summary>
    /// Wrap an error thrown as an exception.
    /// </summary>
    /// <param name="exceptionOrMessage">
    /// The exception or message to throw.
    /// </param>
    /// <param name="request">
    /// The failing request.
    /// </param>
    /// <returns>An object with error details</returns>

    // Create an error object to return
    var error = { message: Platform.getResourceString("Extensions_DefaultErrorMessage") };
    error.toString = function () {
        return error.message;
    };

    if (request) {
        error.request = request;
        if (request.status === 0) {
            // Provide a more helpful message for connection failures
            error.message = Platform.getResourceString("Extensions_ConnectionFailureMessage");
        } else {
            // Try to pull out an error message from the response before
            // defaulting to the status
            var isText = false;
            if (request.getResponseHeader) {
                var contentType = request.getResponseHeader('Content-Type');
                if (contentType) {
                    isText = contentType.toLowerCase().indexOf("text") >= 0;
                }
            }

            try {
                var response = JSON.parse(request.responseText);
                if (typeof response === 'string') {
                    error.message = response;
                } else {
                    error.message =
                        response.error ||
                        response.description ||
                        request.statusText ||
                        Platform.getResourceString("Extensions_DefaultErrorMessage");
                }
            } catch (ex) {
                if (isText) {
                    error.message = request.responseText;
                } else {
                    error.message =
                        request.statusText ||
                        Platform.getResourceString("Extensions_DefaultErrorMessage");
                }
            }
        }
    } else if (_.isString(exceptionOrMessage) && !_.isNullOrEmpty(exceptionOrMessage)) {
        // If it's a string, just use that as the message
        error.message = exceptionOrMessage;
    } else if (!_.isNull(exceptionOrMessage)) {
        // Otherwise we'll use the object as an exception and leave the
        // default error message
        error.exception = exceptionOrMessage;
    }

    return error;
};
},{"./Validate":146,"Platforms/Platform":139}],144:[function(require,module,exports){
(function (global){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

// window.postMessage does not have a concept of responses, so this class associates messages
// with IDs so that we can identify which message a reply refers to.

var Promises = require('./Promises'),
    messageTimeoutDuration = 5 * 60 * 1000; // If no reply after 5 mins, surely there will be no reply

function PostMessageExchange() {
    var self = this;
    self._lastMessageId = 0;
    self._hasListener = false;
    self._pendingMessages = {};
}

PostMessageExchange.prototype.request = function (targetWindow, messageData, origin) {
    /// <summary>
    /// Issues a request to the target window via postMessage
    /// </summary>
    /// <param name="targetWindow" type="Object">
    /// The window object (on an actual window, or iframe) to send the request to
    /// </param>
    /// <param name="messageData" type="Object">
    /// A JSON-serializable object to pass to the target
    /// </param>
    /// <param name="origin" type="String">
    /// The expected origin (e.g., "http://example.com:81") of the recipient window.
    /// If at runtime the origin does not match, the request will not be issued.
    /// </param>
    /// <returns type="Object">
    /// A promise that completes once the target window sends back a reply, with
    /// value equal to that reply.
    /// </returns>

    var self = this,
        messageId = ++self._lastMessageId,
        envelope = { messageId: messageId, contents: messageData };

    self._ensureHasListener();

    return new Promises.Promise(function (complete, error) {
        // Track callbacks and origin data so we can complete the promise only for valid replies
        self._pendingMessages[messageId] = {
            messageId: messageId,
            complete: complete,
            error: error,
            targetWindow: targetWindow,
            origin: origin
        };

        // Don't want to leak memory, so if there's no reply, forget about it eventually
        self._pendingMessages[messageId].timeoutId = global.setTimeout(function () {
            var pendingMessage = self._pendingMessages[messageId];
            if (pendingMessage) {
                delete self._pendingMessages[messageId];
                pendingMessage.error({ status: 0, statusText: "Timeout", responseText: null });
            }
        }, messageTimeoutDuration);

        targetWindow.postMessage(JSON.stringify(envelope), origin);
    });
};

PostMessageExchange.prototype._ensureHasListener = function () {
    if (this._hasListener) {
        return;
    }
    this._hasListener = true;

    var self = this,
        boundHandleMessage = function () {
            self._handleMessage.apply(self, arguments);
        };

    if (window.addEventListener) {
        window.addEventListener('message', boundHandleMessage, false);
    } else {
        // For IE8
        window.attachEvent('onmessage', boundHandleMessage);
    }
};

PostMessageExchange.prototype._handleMessage = function (evt) {
    var envelope = this._tryDeserializeMessage(evt.data),
        messageId = envelope && envelope.messageId,
        pendingMessage = messageId && this._pendingMessages[messageId],
        isValidReply = pendingMessage && pendingMessage.targetWindow === evt.source &&
                       pendingMessage.origin === getOriginRoot(evt.origin);
    
    if (isValidReply) {
        global.clearTimeout(pendingMessage.timeoutId); // No point holding this in memory until the timeout expires
        delete this._pendingMessages[messageId];
        pendingMessage.complete(envelope.contents);
    }
};

PostMessageExchange.prototype._tryDeserializeMessage = function (messageString) {
    if (!messageString || typeof messageString !== 'string') {
        return null;
    }

    try {
        return JSON.parse(messageString);
    } catch (ex) {
        // It's not JSON, so it's not a message for us. Ignore it.
        return null;
    }
};

function getOriginRoot(url) {
    // Returns the proto/host/port part of a URL, i.e., the part that defines the access boundary
    // for same-origin policy. This is of the form "protocol://host:port", where ":port" is omitted
    // if it is the default port for that protocol.
    var parsedUrl = parseUrl(url),
        portString = parsedUrl.port ? parsedUrl.port.toString() : null,
        isDefaultPort = (parsedUrl.protocol === 'http:' && portString === '80') ||
                        (parsedUrl.protocol === 'https:' && portString === '443'),
        portSuffix = (portString && !isDefaultPort) ? ':' + portString : '';
    return parsedUrl.protocol + '//' + parsedUrl.hostname + portSuffix;
}

function parseUrl(url) {
    // https://gist.github.com/2428561 - works on IE8+. Could switch to a more manual, less magic
    // parser in the future if we need to support IE < 8.
    var elem = global.document.createElement('a');
    elem.href = url;
    return elem;
}

exports.instance = new PostMessageExchange();
exports.getOriginRoot = getOriginRoot;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Promises":145}],145:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

// In WinJS, we use WinJS.Promise.
// There's no native equivalent for regular JavaScript in the browser, so we implement it here.
// This implementation conforms to Promises/A+, making it compatible with WinJS.Promise.

// Note: There is a standard Promises/A+ test suite, to which this implementation conforms.
// See test\Microsoft.Azure.Zumo.Web.Test\promiseTests

// Declare JSHint globals
/*global setTimeout:false */

(function (exports) {
    "use strict";

    var resolutionState = { success: {}, error: {} },
        bind = function (func, target) { return function () { func.apply(target, arguments); }; }, // Older browsers lack Function.prototype.bind
        isGenericPromise = function (obj) { return obj && (typeof obj.then === "function"); };

    function Promise(init) {
        this._callbackFrames = [];
        this._resolutionState = null;
        this._resolutionValueOrError = null;
        this._resolveSuccess = bind(this._resolveSuccess, this);
        this._resolveError = bind(this._resolveError, this);

        if (init) {
            init(this._resolveSuccess, this._resolveError);
        }
    }

    Promise.prototype.then = function (success, error) {
        var callbackFrame = { success: success, error: error, chainedPromise: new Promise() };

        // If this promise is already resolved, invoke callbacks immediately. Otherwise queue them.
        if (this._resolutionState) {
            this._invokeCallback(callbackFrame);
        } else {
            this._callbackFrames.push(callbackFrame);
        }

        return callbackFrame.chainedPromise;
    };

    Promise.prototype._resolveSuccess = function (val) { this._resolve(resolutionState.success, val); };
    Promise.prototype._resolveError = function (err) { this._resolve(resolutionState.error, err); };

    Promise.prototype._resolve = function (state, valueOrError) {
        if (this._resolutionState) {
            // Can't affect resolution state when already resolved. We silently ignore the request, without throwing an error,
            // to prevent concurrent resolvers from affecting each other during race conditions.
            return;
        }

        this._resolutionState = state;
        this._resolutionValueOrError = valueOrError;

        // Notify all queued callbacks
        for (var i = 0, j = this._callbackFrames.length; i < j; i++) {
            this._invokeCallback(this._callbackFrames[i]);
        }
    };

    Promise.prototype._invokeCallback = function (frame) {
        var callbackToInvoke = this._resolutionState === resolutionState.success ? frame.success : frame.error;
        if (typeof callbackToInvoke === "function") {
            // Call the supplied callback either to transform the result (for success) or to handle the error (for error)
            // The setTimeout ensures handlers are always invoked asynchronosly, even if the promise was already resolved,
            // to avoid callers having to differentiate between sync/async cases
            setTimeout(bind(function () {
                var passthroughValue, passthroughState, callbackDidNotThrow = true;
                try {
                    passthroughValue = callbackToInvoke(this._resolutionValueOrError);
                    passthroughState = resolutionState.success;
                } catch (ex) {
                    callbackDidNotThrow = false;
                    passthroughValue = ex;
                    passthroughState = resolutionState.error;
                }

                if (callbackDidNotThrow && isGenericPromise(passthroughValue)) {
                    // By returning a futher promise from a callback, you can insert it into the chain. This is the basis for composition.
                    // This rule is in the Promises/A+ spec, but not Promises/A.
                    passthroughValue.then(frame.chainedPromise._resolveSuccess, frame.chainedPromise._resolveError);
                } else {
                    frame.chainedPromise._resolve(passthroughState, passthroughValue);
                }
            }, this), 1);
        } else {
            // No callback of the applicable type, so transparently pass existing state/value down the chain
            frame.chainedPromise._resolve(this._resolutionState, this._resolutionValueOrError);
        }
    };

    // -----------
    // Everything from here on is extensions beyond the Promises/A+ spec intended to ease code
    // sharing between WinJS and browser-based Mobile Services apps

    Promise.prototype.done = function (success, error) {
        this.then(success, error).then(null, function(err) {
            // "done" throws any final errors as global uncaught exceptions. The setTimeout
            // ensures the exception won't get caught in the Promises machinery or user code.
            setTimeout(function () { throw new Error(err); }, 1);
        });
        return undefined; // You can't chain onto a .done()
    };

    // Note that we're not implementing any of the static WinJS.Promise.* functions because
    // the Mobile Services client doesn't even expose any static "Promise" object that you
    // could reference static functions on. Developers who want to use any of the WinJS-style
    // static functions (any, join, theneach, ...) can use any Promises/A-compatible library
    // such as when.js.
    //
    // Additionally, we don't implement .cancel() yet because Mobile Services operations don't
    // support cancellation in WinJS yet either. This could be added to both WinJS and Web
    // client libraries in the future.

    exports.Promise = Promise;
})(exports);
},{}],146:[function(require,module,exports){
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\base.js" />
/// <reference path="C:\Program Files (x86)\Microsoft SDKs\Windows\v8.0\ExtensionSDKs\Microsoft.WinJS.1.0\1.0\DesignTime\CommonConfiguration\Neutral\Microsoft.WinJS.1.0\js\ui.js" />
/// <reference path="..\Generated\MobileServices.DevIntellisense.js" />

var _ = require('./Extensions');
var Platform = require('Platforms/Platform');

exports.notNull = function (value, name) {
    /// <summary>
    /// Ensure the value is not null (or undefined).
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true">
    /// Optional name of the value to throw.
    /// </param>

    if (_.isNull(value)) {
        throw _.format(Platform.getResourceString("Validate_NotNullError"), name || 'Value');
    }
};

exports.notNullOrEmpty = function (value, name) {
    /// <summary>
    /// Ensure the value is not null, undefined, or empty.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (_.isNullOrEmpty(value)) {
        throw _.format(Platform.getResourceString("Validate_NotNullOrEmptyError"), name || 'Value');
    }
};

exports.notNullOrZero = function (value, name) {
    /// <summary>
    /// Ensure the value is not null, undefined, zero, or empty.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (_.isNullOrZero(value)) {
        throw _.format(Platform.getResourceString("Validate_NotNullOrEmptyError"), name || 'Value');
    }
};

exports.isValidId = function (value, name) {
    /// <summary>
    /// Ensure the value is a valid id for mobile services.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (!_.isValidId(value)) {
        throw _.format(Platform.getResourceString("Validate_InvalidId"), name || 'id');
    }
};

exports.isDate = function (value, name) {
    /// <summary>
    /// Ensure the value is a date.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>
    
    exports.notNull(value, name);    
    if (!_.isDate(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'Date',
            typeof value);
    }
};

exports.isNumber = function (value, name) {
    /// <summary>
    /// Ensure the value is a number.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    exports.notNull(value, name);

    if (!_.isNumber(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'Number',
            typeof value);
    }
};

exports.isValidParametersObject = function (value, name) {
    /// <summary>
    /// Ensure the Object instance of user-defined parameters is valid.
    /// </summary>
    /// <param name="value">The parameters to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    exports.notNull(value, name);
    exports.isObject(value, name);

    for (var parameter in value) {
        if (parameter.indexOf('$') === 0) {
            throw _.format(
                Platform.getResourceString("Validate_InvalidUserParameter"),
                name,
                parameter);
        }
    }
};

exports.isInteger = function (value, name) {
    /// <summary>
    /// Ensure the value is an integer.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    exports.notNull(value, name);
    exports.isNumber(value, name);

    if (parseInt(value, 10) !== parseFloat(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'number',
            typeof value);
    }
};

exports.isString = function (value, name) {
    /// <summary>
    /// Ensure the value is a string.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (!_.isString(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'string',
            typeof value);
    }
};

exports.isObject = function (value, name) {
    /// <summary>
    /// Ensure the value is an Object.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (!_.isObject(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'object',
            typeof value);
    }
};

exports.isArray = function (value, name) {
    /// <summary>
    /// Ensure the value is an Array.
    /// </summary>
    /// <param name="value" mayBeNull="true">The value to check.</param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    if (!Array.isArray(value)) {
        throw _.format(
            Platform.getResourceString("Validate_TypeCheckError"),
            name || 'Value',
            'array',
            typeof value);
    }
};

exports.length = function (value, length, name) {
    /// <summary>
    /// Ensure the value is of a given length.
    /// </summary>
    /// <param name="value" type="String">
    /// The value to check.
    /// </param>
    /// <param name="length" type="Number" integer="true">
    /// The desired length of the value.
    /// </param>
    /// <param name="name" mayBeNull="true" optional="true" type="String">
    /// Optional name of the value to throw.
    /// </param>

    exports.notNull(value, name);
    exports.isInteger(length, 'length');

    if (value.length !== length) {
        throw _.format(
            Platform.getResourceString("Validate_LengthUnexpected"),
            name || 'Value',
            length,
            value.length);
    }
};

},{"./Extensions":143,"Platforms/Platform":139}]},{},[138,133]);
